[{"content":"写在前面 本文取自Stanford CS106L Winter2025 Assignment5: Treebook 本作业主要需要我们在其他人完成了一个类的情况下，将此类变得更加适用、更加好用，主要包括运算符重载、special member function等方面，总的来说不算难（比上次的好多了）\n具体思路 Viewing Profiles 目前，我们拥有一个User类，其中值得注意的是_friends这个field，它简单来说是一个vector，但更底层，是使用指针来实现的。 此题需要我们重载\u0026lt;\u0026lt;这个操作符，使得其打印时更符合我们人类的直觉 关于如何重载此操作符，如果没有思路，可以先看看这篇文章为自己的类重载 \u0026lt;\u0026lt; 运算符 User(name=Alice, friends=[Bob, Charlie])，可以看出，除了简单的必须存在的字符串以外，我们还需要打印自己的name，friends的name， 自己的name很简单，类中已经给出方法get_name() friends的name，就需要思考了，首先friends在private里，这意味着我们不能简单访问它们，而是使用friend function，其次还应明白如何访问一个指针元素，最后还要注意当我们到最后一个friend时，要改变打印的内容，因此可以写出代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const User\u0026amp; us) { os \u0026lt;\u0026lt; \u0026#34;User(name=\u0026#34; \u0026lt;\u0026lt; us.get_name() \u0026lt;\u0026lt; \u0026#34;, friends=[\u0026#34;; for (size_t i = 0; i \u0026lt; us.size(); ++i) { if (i == us.size() - 1) { os \u0026lt;\u0026lt; us._friends[i]; } else { os \u0026lt;\u0026lt; us._friends[i] \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; } } os \u0026lt;\u0026lt; \u0026#34;])\u0026#34;; return os; } Unfriendly Behaviour 此题需要我们实现Special Member Functions，具体为\nDestructor 一般来说析构函数是不需要自己显式声明的，但若遇见了与内存相关的内容，就需要我们显式声明了，在此处，_friends就使用了内存，在全部完成后，需要释放内存 1 ~User(); 1 2 3 User::~User() { delete[] _friends; } Copy Constructor 复制一个已存在的对象，将其声明为新的对象，值得注意的是，需要手动分配内存以保证_friends的正确性，在此处，笔者使用的是教授教的C++11的新方法， 1 User(const User\u0026amp; user); 1 2 3 4 5 6 7 8 9 User::User(const User\u0026amp; user): _name(user._name), _size(user._size), _capacity(user._capacity), _friends(new std::string[user._capacity]) { for (size_t i = 0; i \u0026lt; user._size; ++i) { _friends[i] = user._friends[i]; } } Copy Assignment 以上课时的内容为基准，举一反三既可 1 User\u0026amp; operator=(const User\u0026amp; user); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 User\u0026amp; User::operator=(const User\u0026amp; user) { if (this == \u0026amp;user) { return *this; } delete[] _friends; _name = user._name; _size = user._size; _capacity = user._capacity; _friends = new std::string[user._capacity]; for (size_t i = 0; i \u0026lt; user._size; i++) { _friends[i] = user._friends[i]; } return *this; } Move Constructor \u0026amp; Move Assignment 此处要用到的内容为移动语义的知识，为了防止被移动，我们要显示删除这两个SMF，简单声明即可 1 2 User(User\u0026amp;\u0026amp; user) = delete; User\u0026amp; operator=(User\u0026amp;\u0026amp; user) = delete; Always Be Friending 此处需要我们重载两个操作符，以使得其更符合此类的操作\noperator+= 将一个用户添加到另一个用户上以成为其朋友，值得注意的是，这是相互的，一个人对另一个人敞开心扉后，另一个人也应如此。 最后还应按照题目要求返回*this 1 User\u0026amp; operator+=(User\u0026amp; rhs); 1 2 3 4 5 User\u0026amp; User::operator+=(User\u0026amp; rhs) { this-\u0026gt;add_friend(rhs.get_name()); rhs.add_friend(this-\u0026gt;get_name()); return *this; } operator\u0026lt; 简单判断第一个字符的先后即可 1 bool operator\u0026lt;(const User\u0026amp; rhs) const; 1 2 3 bool User::operator\u0026lt;(const User\u0026amp; rhs) const { return this-\u0026gt;get_name()[0] \u0026lt; rhs.get_name()[0]; } GitHub地址\n","date":"2025-04-18T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment5-treebook/","title":"CS106L Winter2025 Assignment5 Treebook"},{"content":"写在前面 本文取自Stanford CS106L Winter2025 Assignment4: Ispell 本任务主要要求我们实现一个拼写检查程序，即若我们给出的单词有误会给出较为合理的建议。主要用到的知识有容器、Lambda函数等内容。\n具体思路 题目大意 将所有常见的英语单词字典添加到内存中，若在字典中找不到该单词则认为拼写错误 若可以通过添加、删除、替换、交换等操作且此操作只需要进行一次的，则将其添加到建议列表中 不能使用for/while循环 tokenize 题目大意 此方法最终会实现一个将String分割成一系列Token，对于一个Token来说其作为一个结构体，包括struct Token { std::string content; size_t src_offset; }; 假设现有一字符串history will absolve me，我们可以将其以空格为边界分成四个Token\n{ content: \u0026quot;history\u0026quot;, src_offset: 0 } { content: \u0026quot;will\u0026quot;, src_offset: 8 } { content: \u0026quot;absolve\u0026quot;, src_offset: 13 } { content: \u0026quot;me\u0026quot;, src_offset: 21 } 可以看出，content会以第一个字母为起点，空格为终点存储一个单词，sec_offset为此第一个字母在整个字符串中的索引，其中需要包括空格。 代码实现 Identify all iterators to space characters 此任务需要我们找出所有空白字符并将其作为迭代器保存到vector中，题目给了我们函数find_all(Iterator begin, Iterator end, UnaryPred pred)，它可以返回此迭代器中所有符合pred条件的所有迭代器并将其保存在vector中，那么我们就需要用参数source来作为迭代器，String类提供了作为迭代器的接口，begin end，条件题目也给了我们判断此字符是否为空格的函数isspace，可以写出代码，\n1 auto space = find_all(source.begin(), source.end(), isspace); Generate tokens between consecutive space characters 目前，我们已经拥有了所有空字符的迭代器，现在需要我们将两个空字符迭代器之间的内容保存为一个Token，Token的迭代器会自动处理两边的空白，只需要提供起始迭代器与终止迭代器即可，此时就可以找到一个Token，但其中不止存在一个Token，所以我们还需要遍历整个字符串，但题目要求不能使用for/while循环，所以使用另一个函数 std::transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOp binary_op) 此函数参数可以分为三个部分\nfirst1 last1 first2，对于此输入范围，函数要求给定两个相等的输入范围，一个从first1开始到last1结束，另一个从first2开始 d_first 将结果存储到d_first中，大小与上文输入范围相同 binary_op 应用于两个部分 对于binary_op应创建一个lambda函数，其中参数为两个迭代器，和字符串，以创建Token，其中source应按引用传递， 对于d_first应先创建一个集合以存储我们创建的Token，再使用std::inserter函数以保存创建的Token 对于输入范围，应选择两个连续的迭代器，以遍历所有迭代器 1 2 3 4 5 6 7 std::set\u0026lt;Token\u0026gt; tokens; std::transform(space.begin(), space.end() - 1, space.begin() + 1, std::inserter(tokens, tokens.end()), [\u0026amp;source] (auto it1, auto it2) { return Token { source, it1, it2}; } ); Get rid of empty tokens 此时我们所创建的Token可能有一些Token是含有空白字符的，我们要将其删掉， std::erase_if(std::set\u0026lt;Key, Compare, Alloc\u0026gt;\u0026amp; c, Pred pred) 对于c，传递我们上文给的集合tokens即可 对于pred，创建一个lambda函数，以判断token是否为空\n1 2 3 4 5 std::erase_if(tokens, [] (Token token) { return token.content.empty(); } ); spellcheck 题目大意 该方法接受tokenize所得到的token来进一步给出建议，并返回一个Mispelling，其中包括一个错误的Token，和一系列建议的单词 大致过程为\n跳过正确拼写的单词 查找距离正确单词仅“一步之遥”的单词 删除没有建议的错误拼写单词 代码实现 Skip words that are already correctly spelled. 若一个单词已经存在在了dictionary中了，我们就认为它是正确的，思路很简单，在此处需要学习的是std::ranges::views::filter，在此笔者使用题目给的较为简洁的方法，即使用namespace来简洁化\n1 2 namespace rv = std::ranges::views; auto view = source | rv::filter(/* A lambda function predicate */); 我们的任务只需要填写这个lambda函数，此函数参数为Token，lambda参数为dictionary，此处的dictionary应按引用传递，来判断此Token是否在dictionary中\n1 2 3 auto view = source | rv::filter([\u0026amp;dictionary] (Token token) { return !dictionary.contains(token.content); }); Find one-edit-away words in the dictionary using Damerau-Levenshtein 根据题目提示，此时我们应该与上题相结合\n1 2 3 4 namespace rv = std::ranges::views; auto view = source | rv::filter(/* A lambda function predicate */) | rv::transform(/* A lambda function taking a Token -\u0026gt; Mispelling */); 此lambda函数应接受一个Token，返回距离为一的所有单词，求距离是否为一，使用题目给的函数levenshtein来判断即可 最后需要返回一个Mispelling对象\n1 2 3 4 5 6 7 | rv::transform([dictionary] (Token token) -\u0026gt; Mispelling { auto view = dictionary | rv::filter([token] (std::string str) { return levenshtein(token.content, str) == 1; }); std::set\u0026lt;std::string\u0026gt; suggestions(view.begin(), view.end()); return Mispelling { token, suggestions }; }); Drop misspellings with no suggestions. 在此我们需要找到没有办法进行任何修改使其变为正常单词的单词了，故此处还需要使用filter来判断是否符合此情况，过滤完成后返回最新的Mispelling\n1 2 3 | rv::filter([] (Mispelling miss) {return !miss.suggestions.empty();}); return std::set\u0026lt;Mispelling\u0026gt; (view.begin(), view.end()); }; GitHub地址\n","date":"2025-04-17T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment4-ispell/","title":"CS106L Winter2025 Assignment4 Ispell"},{"content":"遇到的问题 最后的编译过不去，不知道为什么卡在 Installing CastXML就不动了 ：（\n具体思路 自由发挥创造一个类，没什么好解释的，创造性很强，我没有更好的想法，就用了上课用的StanfordID类来做 class.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;string\u0026gt; #include \u0026lt;sstream\u0026gt; class StanfordID { private: std::string name; std::string sunet; int idNumber; std::string getInitialName(std::string name); public: StanfordID(std::string name, std::string sunet, int idNumber); StanfordID(); const std::string getName(); const std::string getSunet(); const int getIdNumber(); void setName(std::string name); }; class.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026#34;class.h\u0026#34; #include \u0026lt;string\u0026gt; StanfordID::StanfordID(std::string name, std::string sunet, int idNumber) { this-\u0026gt;name = name; this-\u0026gt;sunet = sunet; if (this-\u0026gt;idNumber \u0026gt; 0) { this-\u0026gt;idNumber = idNumber; } } std::string StanfordID::getInitialName(std::string name) { std::stringstream ss; ss \u0026lt;\u0026lt; name; std::string first; std::string last; ss \u0026gt;\u0026gt; first \u0026gt;\u0026gt; last; std::string res; res += first[0]; res += last[0]; return res; } StanfordID::StanfordID() { this-\u0026gt;name = \u0026#34;YuTaki X\u0026#34;; this-\u0026gt;sunet = \u0026#34;172@60\u0026#34;; this-\u0026gt;idNumber = 190; } const std::string StanfordID::getName() { return this-\u0026gt;name; } const std::string StanfordID::getSunet() { return this-\u0026gt;sunet; } const int StanfordID::getIdNumber() { return this-\u0026gt;idNumber; } void StanfordID::setName(std::string name) { this-\u0026gt;name = name; } sandbox.cpp\n1 2 3 4 #include \u0026#34;class.h\u0026#34; void sandbox() { StanfordID id(\u0026#34;Yammy Xi\u0026#34;, \u0026#34;183@80\u0026#34;, 187); } ","date":"2025-04-11T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment3-make-a-class/","title":"CS106L Winter2025 Assignment3 Make a Class"},{"content":"写在前面 本作业取自Stanford CS106L Winter 2025 第2个Assignment。主要考察对读取文件内容、容器等内容的考察，总体难度不大，但是有几个坑，笔者会在下方标注坑处，如果你的测试过不去，大概率就是这里出了问题。\n具体思路 kYourName 将上方的名字改成自己的\n1 std::string kYourName = \u0026#34;YuTaki X\u0026#34;; get_applicants 本题需要从一个.txt文件中读取其中内容，并将其中内容放到一个set里，具体思路即为\n打开文件 读取每行的内容 将此内容放到set中 直到没有内容可读取 可以写出 1 2 3 4 5 6 7 8 9 10 11 12 13 std::set\u0026lt;std::string\u0026gt; get_applicants(std::string filename) { std::set\u0026lt;std::string\u0026gt; students; std::ifstream inputFile; inputFile.open(filename); if (inputFile.is_open()) { std::string line; while (std::getline(inputFile, line)) { students.insert(line); } } inputFile.close(); return students; } find_matches 本体需要让我们找出与name有相同initials名字的人，并将其指针加入到一个queue中\n坑点1 什么是initials？ 比如你的名字是Zhang San，那么initials就是ZS\n具体思路为\n写一个辅助函数，用于得到每个名字的initials 迭代查询set里的每个元素，若有与之相同的，则将其指针加入queue中 你需要知道的内容有 如何获取一个字符串中每个单词的第一个字母 坑点2 在用stringstream时，要在前面include \u0026lt;sstream\u0026gt;\n如何迭代set 如何表示一个指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;sstream\u0026gt; std::string helper(std::string name) { std::stringstream ss; ss \u0026lt;\u0026lt; name; std::string first; std::string last; ss \u0026gt;\u0026gt; first \u0026gt;\u0026gt; last; std::string res; res += first[0]; res += last[0]; return res; } std::queue\u0026lt;const std::string*\u0026gt; find_matches(std::string name, std::set\u0026lt;std::string\u0026gt;\u0026amp; students) { std::queue\u0026lt;const std::string*\u0026gt; res; for (const auto\u0026amp; student : students) { if (helper(name) == helper(student)) { res.push(\u0026amp;student); } } return res; } get_match 选择你自己喜欢的方法来从queue中再进一步得到一个特殊的名字（我的名字已经够特殊的了，就不再写了，其实是懒）\n1 2 3 4 5 6 7 std::string get_match(std::queue\u0026lt;const std::string*\u0026gt;\u0026amp; matches) { if (!matches.empty()) { return *matches.front(); } else { return \u0026#34;NO MATCHES FOUND.\u0026#34;; } } 写在后面 总体不难，都是些小问题容易恼火 GitHub地址\n","date":"2025-04-09T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment2-marriage-pact/","title":"CS106L Winter2025 Assignment2 Marriage Pact"},{"content":"具体思路 本lab大致内容为让我们使用数组来实现一颗树，且树要有类似于BST的搜索功能，但这里的比较方法不是简单的比较，而是每个节点都存在一个优先级，值越小优先级越大。题目给了我们许多脚手架，我的建议是一直看下去知道size()方法，连同注释也要一起看，这样就会对整个内容有个大致的了解，这很重要。 以下做题顺序以lab建议我们的做题顺序为准。\nleft/right/parentIndex(int i) 这三个方法只需要用题目给我们的representing a tree with an array来做即可，具体为\n节点n的左节点的位置位于2n 节点n的右节点的位置位于2n+1 节点n的父节点的位置位于n/2 可写出代码 1 2 3 4 5 6 7 8 9 10 11 private static int leftIndex(int i) { return 2 * i; } private static int rightIndex(int i) { return 2 * i + 1; } private static int parentIndex(int i) { return i / 2; } swim(int index) 先看一下题目对于swim的定义\n将刚才添加的项与其父项交换 直到刚才添加的项比其父项大，否则一直交换值 这样一步一步向上游的感觉就称之为swim 问：这里的比较比的是什么？ 答：各个数组元素为一个节点，每个节点存在一个优先级mypriority 使用上文给我们的方法min即可比较两节点之间的优先级大小，可以写出代码， 1 2 3 4 5 6 7 8 9 private void swim(int index) { // Throws an exception if index is invalid. DON\u0026#39;T CHANGE THIS LINE. validateSinkSwimArg(index); while (min(index, parentIndex(index)) == index \u0026amp;\u0026amp; inBounds(parentIndex(index))) { swap(index, parentIndex(index)); index = parentIndex(index); } } sink(int index) 先看一下题目对sink的定义 将新节点逐渐sink下来，由于树的不变量，它必须要比其两个子树大才能保持原位，若比其两子树都小则要选择一个更小的，从更小的身上swap下来，直到比两子树大，故可以写出代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private void sink(int index) { // Throws an exception if index is invalid. DON\u0026#39;T CHANGE THIS LINE. validateSinkSwimArg(index); while (true) { int left = leftIndex(index); int right = rightIndex(index); int smallest = index; if (min(left, smallest) == left) { smallest = left; } if (min(right, smallest) == right ) { smallest = right; } if (smallest != index) { swap(index, smallest); index = smallest; } else { break; } } } insert(T item, double priority) 看一下题目对add an item的要求\n将要添加的节点放在树最底部的位置，即数组最后面的位置 swim此节点 对于此树，数组0的位置没有任何东西，故不能简单的用size来表示当前树有多少个节点，而是用size+1，故写出代码 1 2 3 4 5 6 7 8 9 10 11 public void insert(T item, double priority) { /* If the array is totally full, resize. */ if (size + 1 == contents.length) { resize(contents.length * 2); } Node currentNode = new Node(item, priority); size += 1; contents[size] = currentNode; swim(size); } peek() 根据注释要求，简单返回第一个节点的item即可，不过在此还是考虑一下边界情况\n1 2 3 4 5 if (size \u0026lt;= 0) { return null; } else { return contents[1].myItem; } removeMin() 看一下题目给的定义\n将根节点与最右边（最小）的节点交换 删除最右边的节点 sink新节点 但在这里还需要返回被删除的节点，故应该在最前面加上初始化，最后再return，简单写出代码 1 2 3 4 5 6 7 8 public T removeMin() { T res = peek(); swap(1, size); contents[size] = null; size--; sink(1); return res; } GitHub地址\n","date":"2025-04-06T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-lab-10-priority-queues/","title":"CS61B SP18 Lab 10 Priority Queues"},{"content":"HW3: Hashing 具体思路 Simple Oomage 首先观察一下这个类，存在三个实例变量，red、blue和green，只要这三个值在0-255之间并且是5的倍数，就称为有效。\nequals 普通的equals只是检查目标地址是否相同，若相同则返回true，反之false，但在这里不可行。同时还应注意的是为了保证比较的两个类是完全相同的两个类，而不是子类或其他，应使用getClass方法来判断，观察Date类的equals方法可模仿写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override public boolean equals(Object o) { if (o == this) { return true; } if (o == null) { return false; } if (o.getClass() != this.getClass()) { return false; } SimpleOomage that = (SimpleOomage) o; return (this.red == that.red) \u0026amp;\u0026amp; (this.green == that.green) \u0026amp;\u0026amp; (this.blue == that.blue); } A Simple hashCode 此题需要我们完成一个哈希函数，作为一个好的哈希函数，应该要做到能平均的放到每一个哈希表中，不会出现一组数据只放在一个哈希表内，对于题目给我们的数可知，这三个数均为0-255之间且为5的倍数的数字，那么一组数最多只有52个数字（0-51），因此我们可以从这两个地方入手，写出\n1 2 3 4 5 6 7 8 9 10 11 12 @Override public int hashCode() { if (!USE_PERFECT_HASH) { return red + green + blue; } else { // Write a perfect hash function for Simple Oomages. int rIndex = red / 5; int gIndex = green / 5; int bIndex = blue / 5; return rIndex * 52 * 52 + gIndex * 52 + bIndex; } } testHashCodePerfect 本体需要我们编写一个测试，来测试目前给的哈希函数是错误的，先观察一下当前的哈希函数，这只是简单的将三个数字相加，没有做任何区分，可以想到，若把数字交换一下，这同样也会给出一样的值，但从本质上来说，它们是不同的，可以写出\n1 2 3 4 5 @Test public void testHashCodePerfect() { SimpleOomage ooA = new SimpleOomage(5, 10, 20); SimpleOomage ooA2 = new SimpleOomage(10, 20, 5); assertNotEquals(ooA.hashCode(), ooA2.hashCode()); A Perfect hashCode 将USE_PERFECT_HASH改为true即可\n1 private static final boolean USE_PERFECT_HASH = true; ","date":"2025-04-05T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-hw-3-hashing/","title":"CS61B SP18 HW 3 Hashing"},{"content":"写在前面 本文取自Stanford CS106L的第一个作业，以下为笔者对本作业的思考以及对C++的一些思考。\nCS106L作为C++的课程名不虚传，其特性只有自己写题时才能感知出来，一个简单的操作居然会有许多不同的方法来实现，笔者十分震惊，在这之前笔者对于C++仅是只闻其名，不闻其人。\n关于此题，若你有有任何问题或更好的方法，欢迎与我联系。\n点这里向我发邮件\n具体思路 Part 0: Read the code and fill in the Course struct 本题一共有两个任务\n整体看一下代码 补充完整结构Course 首先观察一下整体代码，并说一下整个作业需要我们完成什么。本作业需要我们通过一个csv文件，来看看在一个特定的学期当中，有哪些课被学生选了并允许达到开课的要求，而有哪些课是没有被选的，在这里我们创建一个结构体Course其中包括三个参数，title课程名称、number_of_units此课程共有几个单元以及quarter学期，值得注意的是，国外学期用的是季节+年份来表示。\n在下面有一个函数parse_csv即将一个csv文件转变为一个Course数组来存放。\n还有write_courses_offered和write_courses_not_offered，分别代表将数组中的可以开课的课程存入一个csv文件和将数组中不可以开课的课程存入另一个csv文件当中。\n下一部分看看结构体Course，观察题目给我们的csv文件可以发现，title和quarter均为字符串的形式，故它们的类型均为String，对于number_of_units笔者一开始认为其应该为int类型，但之后会用到一个spilt函数，其类型属于String，即将一个字符串分成好几个不同的字符串，故这里的number_of_units也应该为String类型，\n1 2 3 4 5 struct Course { std::string title; std::string number_of_units; std::string quarter; }; 接下来看代码中的注释，告诉我们看一下main函数，并告知我们这三个函数需要更改一下签名，观察可得，从始至终用的都是同一个结构体数组，而不是一直复制一个不断更改，故可以知道这里的数组应该是引用类型，即指向的是地址，改变一次，下一次也接着改变，故对于parse_csv函数来说需要将签名改为引用类型，而对于write_courses_offered函数来说，它存在特殊要求，最后是需要将参数数组在其原基础上做更改，所以也需要改为引用类型，对于write_courses_not_offered则没有这种要求，故不需要更改，\n1 2 void write_courses_offered(std::vector\u0026lt;Course\u0026gt;\u0026amp; all_courses) void write_courses_not_offered(std::vector\u0026lt;Course\u0026gt; unlisted_courses) Part 1: parse_csv 本题需要我们完成parse_csv函数，此函数主要是读取一个csv文件的内容，并将其中的内容保存在一个Course数组中，简单思考一下，\n应该要使用IO流的方法来读取外部文件的内容，需要注意的是如何打开、关闭一个文件 每一行都对应了一个Course故要一行一行的读取内容，在这里应使用getline()函数 最上面一行的内容不属于Course应忽略，有多种方式可以忽略，如ignore函数，或仅读取却不做任何操作 一行内容存放了三个不同的值，应使用split函数（应include此文件），对于此函数，其返回的是一个字符串数组，故可以使用[]表达式来取值 关于如何对一个结构体数组添加元素，有许多方法可以做到，如push_back函数或emplace_back（这也是笔者对C++很震惊的一点，一个操作居然有如此多种方法可以实现） 故可以写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void parse_csv(std::string filename, std::vector\u0026lt;Course\u0026gt;\u0026amp; courses) { std::ifstream inputFile; inputFile.open(filename); if (inputFile.is_open()) { std::string line; std::getline(inputFile, line); std::vector\u0026lt;std::string\u0026gt; splitString; while (std::getline(inputFile, line)) { splitString = split(line, \u0026#39;,\u0026#39;); Course c; c.title = splitString[0]; c.number_of_units = splitString[1]; c.quarter = splitString[2]; courses.push_back({c}); } } inputFile.close(); } Part 2: write_courses_offered 本题需要将已经存在的一个Course数组进行筛选，选出quarter不为null的课程，写入一个新csv文件，并在最后将此存在的数组删除这些为null的课程，值得注意的点有，\n将数组中的内容写入文件中，应使用ofstream来做，记得打开文件也要关闭文件 对于新csv文件的第一行会有一个特殊的内容需要单独写入 需要记录下来哪些是需要删除的课程，并在最后使用题目给我们的delete_elem_from_vector函数来删除 故简单写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void write_courses_offered(std::vector\u0026lt;Course\u0026gt;\u0026amp; all_courses) { std::ofstream outfile; outfile.open(COURSES_OFFERED_PATH); std::vector\u0026lt;Course\u0026gt; course_need_to_delete; if (outfile.is_open()) { outfile \u0026lt;\u0026lt; \u0026#34;Title,Number of Units,Quarter\u0026#34; \u0026lt;\u0026lt; std::endl; for (Course c: all_courses) { if (c.quarter != \u0026#34;null\u0026#34;) { outfile \u0026lt;\u0026lt; c.title \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; c.number_of_units \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; c.quarter \u0026lt;\u0026lt; std::endl; course_need_to_delete.push_back({c}); } } } outfile.close(); for (auto\u0026amp; c : course_need_to_delete) { delete_elem_from_vector(all_courses, c); } } Part 3: write_courses_not_offered 此题需要将一个已经存在的Course数组进行筛选，选出quarter为null的课程，写入一个新csv文件，但不需要删除，故大致部分与上文无二，还少了最后一个部分，不赘述，\n1 2 3 4 5 6 7 8 9 10 11 12 void write_courses_not_offered(std::vector\u0026lt;Course\u0026gt; unlisted_courses) { /* (STUDENT TODO) Your code goes here... */ std::ofstream outfile; outfile.open(COURSES_NOT_OFFERED_PATH); if (outfile.is_open()) { outfile \u0026lt;\u0026lt; \u0026#34;Title,Number of Units,Quarter\u0026#34; \u0026lt;\u0026lt; std::endl; for (Course c : unlisted_courses) { outfile \u0026lt;\u0026lt; c.title \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; c.number_of_units \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; c.quarter \u0026lt;\u0026lt; std::endl; } } outfile.close(); } 常见问题 不要忘了将main函数的注释给删掉，才能进行autograde评分。笔者在这里起码缠了半个小时（要疯了） ","date":"2025-03-31T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment1-simpleenroll/","title":"CS106L Winter2025 Assignment1 SimpleEnroll"},{"content":"写在前面 本lab取自UCB CS61B SP18 Lab9，具体内容为使用二叉搜索树和哈希表实现map。\n若本文存在错误或有更好的想法，欢迎与我联系。\n点这里向我发邮件\n具体思路 BSTMap 概念回顾 首先回忆一下什么是BST。对于一棵树来说，存在\n一系列节点 一系列用来连接这些节点的边（对于任意两个节点仅有一条边来连接） 对于一个存在根节点的树来说，我们称一个节点就是一棵树\n每个节点都存在一个父节点（除根节点以外） 一个没有子节点的节点称为叶子 对于一个二叉树，每个节点存在0、1或2个节点（子树）\n对于一个二叉搜索树，要将搜索的概念引入二叉树中，左边的节点总是要小于右边的，右边的节点总是要大于左边的，中间的节点总是在其中间存在。\nget 对于此方法，我们要递归的找到需要的值，基本思路为若目标值小于当前节点，则往左树寻找，若大于当前节点，则往右数寻找，若等于当前节点，则返回。\n值得注意的是，对于key的比较，应使用Java提供的compareTo方法，这可以让我们比较其他类型的值。简单写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private V getHelper(K key, Node p) { if (p == null) { return null; } int cmp = key.compareTo(p.key); if (cmp \u0026lt; 0) { return getHelper(key, p.left); } else if (cmp \u0026gt; 0) { return getHelper(key, p.right); } else { return p.value; } } public V get(K key) { return getHelper(key, root); } put 对于此方法，与上方法大差不差，总体思路还是比较目标值与当前值的大小，分三种情况讨论即可，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private Node putHelper(K key, V value, Node p) { // if found, do nothing if (p == null) { return new Node(key, value); } // if not found, create a new node, int cmp = key.compareTo(p.key); if (cmp \u0026lt; 0) { p.left = putHelper(key, value, p.left); } else if (cmp \u0026gt; 0) { p.right = putHelper(key, value, p.right); } else { p.value = value; } return p; } public void put(K key, V value) { root = putHelper(key, value, root); size++; } size 在put内添加一个变量，每put一个值，size就自增即可，\n1 2 3 public int size() { return size; } MyHashMap 对于本类，并没有用太多HashTable的底层实现，不过在此，笔者还是想写下一些自己的回顾，以便之后复习。\n对于一个哈希表来说，值得注意的是哈希函数与当前数组存放满之后链表的存放方法，对于哈希函数，每个不同的数据存在不同的哈希函数，但正如algs4所说，创造一个性能好的哈希函数是前沿计算机科学家需要做的事情，我能做的只有站在巨人的肩膀上使用它们。对于拉链法，即当当前数组存放满之后，要在数组之后引入一个指针指向一系列链表，十分巧妙，很好的将内存与时间平衡了起来。\nget 此方法与数组访问元素的方法很像，不同的是，此时的索引应使用哈希函数来变换一下，\n1 2 3 4 5 6 7 public V get(K key) { if (key == null) { return null; } else { return buckets[hash(key)].get(key); } } put 此方法与数组存放元素的方法也很想，不同的是，一个数组的内存总是有限的，若链表的长度过长，时间上也会有损伤，故需要扩大数组 ，很想之前实现过的ArrayDequeue，应实现一个resize方法，简单思路为创建一个新数组，将数组大小扩大，并将原数组的元素存放进去即可，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private MyHashMap(int cap) { buckets = new ArrayMap[cap]; this.clear(); } private void resize(int cap) { MyHashMap\u0026lt;K, V\u0026gt; resizeBucket = new MyHashMap\u0026lt;\u0026gt;(cap); for (int i = 0; i \u0026lt; buckets.length; i++) { for (K key : buckets[i].keySet()) { resizeBucket.put(key, buckets[i].get(key)); } } this.size = resizeBucket.size; this.buckets = resizeBucket.buckets; } public void put(K key, V value) { if (loadFactor() \u0026gt; MAX_LF) { resize(2 * buckets.length); } if (!containsKey(key)) { size++; } buckets[hash(key)].put(key, value); } size 与上文相同，不赘述，\n1 2 3 public int size() { return size; } 点这里看完整代码实现\n","date":"2025-03-26T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-lab9-tree-maps-vs.-hash-maps/","title":"CS61B SP18 Lab9 Tree Maps vs. Hash Maps"},{"content":"写在前面 本HW取自UCB CS61B SP18的HW2: Percolation。\n主要内容为在给定数据结构的情况下，实现一个现实生活中的应用，很好的锻炼了我们对已有API情况下编写代码的能力。\n本文为笔者参考了多方笔记所写，在此感谢所有付出的人，具体参考资料可看最后。\n虽已完成，却仍有许多不解，若你有更好的想法或我需要改进的地方，望不吝赐教。\n点这里向我发邮件~\n具体思路 背景介绍 本HW需要我们使用不相交集的API通过Monte Carlo模拟来估计渗流阈值。\n问：什么是渗流？\n答：简单来说，可以想象一个竖着拜访的箱子，箱子内部有许多小箱子，在最开始它们全都是被锁上的，在最上方有水会流下来，我们需要不断打开小箱子，直到通过重力的作用，有一个完整的路径可以让水从最顶部流到最底部。\nPercolation.java 此部分不会一开始就给出最终答案，而是会以笔者正常的思考一步一步完成最后的内容\n此类需要我们完成一个渗流模型程序，其中包括构造函数、打开一个箱子、整个系统是否渗流等操作。\npublic Percolation(int N) 根据题目描述，构造函数需要我们创建一个N * N的二维网格结构，且所有格子最开始都是锁上的。很容易想到这里需要让我们创建一个二维数组，但此二维数组的类型是什么呢？仔细想想，所有格子最开始是锁上的，是否可以将锁上与打开想象成false和true，因此我们就需要创建一个二维布尔数组。同时，题目给出要求构造函数所要求的时间为二次函数，满足。下方给出了一个极端情况，当N \u0026lt;= 0时应抛出异常，此时我们可以写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 public class Percolation { private boolean[][] grid; private int N; public Percolation(int N) { this.N = N; if (N \u0026lt;= 0) { throw new IllegalArgumentException(); } this.grid = new boolean[N][N]; } public void open(int row, int col) 此方法需要我们完成打开箱子的操作，简单想想，我们之前把箱子抽象为布尔，那打开一个箱子是不是就是将false变为true，且需要满足此时这个箱子不是被打开的，简单做一个if判断即可，可以写出，\n1 2 3 4 5 6 7 8 9 10 11 public void open(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } else { if (!grid[row][col]) { grid[row][col] = true; } else { return; } } } public boolean isOpen(int row, int col) 此方法需要我们完成一个特定的箱子此时是否被打开的操作，一个箱子作为一个布尔值，只需要判断当前布尔值是多少即可，同时题目给出我们要求，若给定参数不合法应抛出异常，故可以写出，\n1 2 3 4 5 6 public boolean isOpen(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } return grid[row][col]; } public boolean isFull(int row, int col) 此方法需要我们判断这个特定的箱子是否是“满”的，如何理解这个Full？根据Josh教授给出的提示，简单来说只要此时这个箱子与最上面一行的箱子中的任何其中一个相连，即视他为isFull，故我们只需要判断这个箱子是否与最上面的箱子之一相连即可，那么问题又来了，我该用什么来表示这个箱子与其他箱子相连呢？我们直到，这个特定的箱子不一定是第二行的，它可以是最后一行，可以是任何一行，所以我们还需要思考它怎么与其他任意一个箱子相连呢？因为我们知道对于两个不相邻的箱子来说，只要它们中间的箱子是打开的，那它们也算是相连的，这里就需要用到我们学习的不相交集的概念了。我们可以把整个二维数组想象成一个不相交集，每打开一个箱子，我们就会将其添加进去。思路明确，想想第一步应该做什么，首先应该创建一个不相交集，故我们可以在构造函数中添加，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Percolation { private boolean[][] grid; private int N; private WeightedQuickUnionUF wquuf; public Percolation(int N) { this.N = N; if (N \u0026lt;= 0) { throw new IllegalArgumentException(); } this.grid = new boolean[N][N]; this.wquuf = new WeightedQuickUnionUF(N * N); } } 有了不相交集，我们就应该判断一个箱子是否与另一个箱子相连，在这里应该是在open方法中添加，每当我们打开一个箱子后，就要在不相交集中添加一个元素，查看不相交集的API，可以发现union(int p, int q)方法是很符合我们所想要的内容的，但我们仔细观察一下，这里的参数需要的是两个整型，我们表示一个箱子用的是一个数组，很明显不符，因此我们就需要把每个箱子添加一个唯一的index，根据Josh教授的提示，我们可以看出，\n需要添加一个特定的方法xyTo1D将一个以xy表示的数组创建一个特定的index，这个方法很好写，仔细观察就可以看出来，\n1 2 3 private int xyTo1D(int row, int col) { return row * N + col; } 有了这个方法我们就可以把每个数组连接起来了，在这里，一个箱子是会与四周的任意一个箱子连接的，故会有四种可能，其中，每个边界如上边指挥与左下右相连，而不会与上方再次相连了，因为他们之间已经没有东西了，故可以写出，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public void open(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } else { if (!grid[row][col]) { grid[row][col] = true; openSiteSum++; } else { return; } } int index = xyTo1D(row, col); // 现开始考虑四周如果是打开的情况，与之相连 // 上边，原节点至少是第二行 if (row \u0026gt; 0 \u0026amp;\u0026amp; isOpen(row - 1, col)) { wquuf.union(xyTo1D(row - 1, col), index); } // 下边，原节点至多是倒数第二行 if (row \u0026lt; N - 1 \u0026amp;\u0026amp; isOpen(row + 1, col)) { wquuf.union(xyTo1D(row + 1, col), index); } // 左边，至少是第二列 if (col \u0026gt; 0 \u0026amp;\u0026amp; isOpen(row, col - 1)) { wquuf.union(xyTo1D(row, col - 1), index); } // 右边，至多是倒数第二列 if (col \u0026lt; N - 1 \u0026amp;\u0026amp; isOpen(row, col + 1)) { wquuf.union(xyTo1D(row, col + 1), index); } } 现在我们已经完成了箱子与箱子之间相连的部分了，该相信isFull该怎么完成了，根据上文可知，这个就是判断这个特定的箱子是否与最上方的任意一个箱子所连接，故我们可以写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 public boolean isFull(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } int index = xyTo1D(row, col); for (int i = 0; i \u0026lt; N; i++) { if (wquuf.connecter(index, xyTo1D(0, i))) { return true; } else { return false; } } } 但是我们可以发现，这需要我们判断上面每一个箱子，这属于线性时间，不符合题目所要求的常数时间，所以此方法不可取，还需寻找其他方法，根据Josh教授给出的提示，\n我们可以在上下两部分都给出一个虚拟箱子，并让上虚拟箱子与第一行的相连，让下虚拟仙子与最后一行相连，只要上虚拟箱子与特定箱子相连，即表示Full，故可以写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class Percolation { private boolean[][] grid; private int N; private WeightedQuickUnionUF wquuf; private int virtualTopSite; private int virtualBottomSite; public Percolation(int N) { this.N = N; if (N \u0026lt;= 0) { throw new IllegalArgumentException(); } this.grid = new boolean[N][N]; this.wquuf = new WeightedQuickUnionUF(N * N + 2); this.virtualTopSite = N * N; this.virtualBottomSite = N * N + 1; } public void open(int row, int col) { // 前省略 int index = xyTo1D(row, col); // 将上方的虚拟节点连接到第一行 if (row == 0) { wquuf.union(virtualTopSite, index); } // 将下方的虚拟节点连接到最后一行 if (row == N - 1) { wquuf.union(virtualBottomSite, index); } // 后省略 } public boolean isFull(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } int index = xyTo1D(row, col); return wquuf.connected(index, virtualTopSite); } } 在这里值得注意的是，我们需要事先给两虚拟箱子分配一个值，但不能是负值（笔者在这里就错过），不仅如此还要将不相交集多分配两个以便存放虚拟箱子。\npublic int numberOfOpenSites() 此方法需要我们给出目前有多少个打开的箱子，很容易实现，就像之前的size一样，只要在每次打开一个箱子后加一即可，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Percolation { // 前省略 private int openSiteSum; public Percolation(int N) { // 前省略 this.openSiteSum = 0; } public void open(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } else { if (!grid[row][col]) { grid[row][col] = true; openSiteSum++; } else { return; } } // 后省略 public int numberOfOpenSites() { return openSiteSum; } } public boolean percolates() 此方法需要我们判断此系统是否已经渗流，可以想到，一个系统渗流，就代表其最上方与最下方相连，再根据我们之前所创建的虚拟箱子，很容易写出，\n1 2 3 public boolean percolates() { return wquuf.connected(virtualTopSite, virtualBottomSite); } 但是在这里会出现一个问题，Josh教授给我们指出来了，\n当已存在一个渗流，另一个不满足渗流标准时，就会出现问题，故在这里我们就需要创建一个新的不相交集，此不相交集仅保存上虚拟箱子，而不保存下虚拟箱子，这样在判断isFull的时候就不会有问题了，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class Percolation { // 前省略 private WeightedQuickUnionUF wquufWithBackWash; //后省略 public Percolation(int N) { // 前省略 this.wquufWithBackWash = new WeightedQuickUnionUF(N * N + 1); } public void open(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } else { if (!grid[row][col]) { grid[row][col] = true; openSiteSum++; } else { return; } } int index = xyTo1D(row, col); // 将上方的虚拟节点连接到第一行 if (row == 0) { wquuf.union(virtualTopSite, index); wquufWithBackWash.union(virtualTopSite, index); } // 将下方的虚拟节点连接到最后一行 if (row == N - 1) { wquuf.union(virtualBottomSite, index); } // 现开始考虑四周如果是打开的情况，与之相连 // 上边，原节点至少是第二行 if (row \u0026gt; 0 \u0026amp;\u0026amp; isOpen(row - 1, col)) { wquuf.union(xyTo1D(row - 1, col), index); wquufWithBackWash.union(xyTo1D(row - 1, col), index); } // 下边，原节点至多是倒数第二行 if (row \u0026lt; N - 1 \u0026amp;\u0026amp; isOpen(row + 1, col)) { wquuf.union(xyTo1D(row + 1, col), index); wquufWithBackWash.union(xyTo1D(row + 1, col), index); } // 左边，至少是第二列 if (col \u0026gt; 0 \u0026amp;\u0026amp; isOpen(row, col - 1)) { wquuf.union(xyTo1D(row, col - 1), index); wquufWithBackWash.union(xyTo1D(row, col - 1), index); } // 右边，至多是倒数第二列 if (col \u0026lt; N - 1 \u0026amp;\u0026amp; isOpen(row, col + 1)) { wquuf.union(xyTo1D(row, col + 1), index); wquufWithBackWash.union(xyTo1D(row, col + 1), index); } } public boolean isFull(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } int index = xyTo1D(row, col); return wquufWithBackWash.connected(index, virtualTopSite); } } public static void main(String[] args) 关于这个main方法，大家可以写一些自己的测试，但不要删掉也不要不写，否则autograde过不去。\nPercolationStats.java 在此类，就需要我们完成Mento Carol模拟了，具体步骤可以看题目描述，在此不赘述。\n本类一样不会直接给出答案，而是会一步步思考\npublic PercolationStats(int N, int T, PercolationFactory pf) 此构造函数需要我们在N * N的二维数组下完成T次Mento Carol模拟，故我们就需要在这里完成整个模拟过程，而不需要再创建一个其他方法或其他。\n首先看模拟第一步，初始化所有sites并将其设为关闭状态。这就是用我们上文完成的渗流模型即可，值得注意的是，这里参数并没有给我们上文完成的类，而是给了另一个类似于中转站的类，不过也没关系，简单new即可，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class PercolationStats { private int N; private int T; private Percolation p; public PercolationStats(int N, int T, PercolationFactory pf) { this.N = N; this.T = T; if (N \u0026lt;= 0 || T \u0026lt;= 0) { throw new IllegalArgumentException(); } this.threshold = new double[T]; for (int i = 0; i \u0026lt; T; i++) { // 初始化site，全为blocked this.p = pf.make(N); } } 第二步，重复操作，意味着需要循环，\n在所有关闭的site随机选择一个site，意味着需要使用random函数 打开这个site 当渗流完成时，将其比例添加至渗流阈值，意味着我们需要知道公式，以及创建一个新数组 详情可以看题目描述，简单写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class PercolationStats { private int N; private int T; private double[] threshold; private Percolation p; public PercolationStats(int N, int T, PercolationFactory pf) { this.N = N; this.T = T; if (N \u0026lt;= 0 || T \u0026lt;= 0) { throw new IllegalArgumentException(); } this.threshold = new double[T]; for (int i = 0; i \u0026lt; T; i++) { // 初始化site，全为blocked this.p = pf.make(N); while (!p.percolates()) { // 随机打开一个site int randomRow = StdRandom.uniform(N); int randomCol = StdRandom.uniform(N); p.open(randomRow, randomCol); } threshold[i] = (double) p.numberOfOpenSites() / (N * N); } } } public double mean() 此方法需要我们完成渗流阈值样本平均值，题目给出我们提示使用StdStats库即可，里面有求样本平均值的函数，\n1 2 3 public double mean() { return StdStats.mean(threshold); } public double stddev() 此方法与上题一样，求渗流阈值的样本标准差，\n1 2 3 public double stddev() { return StdStats.stddev(threshold); } public double confidenceLow() 此方法求置信区间的左边界，公式题目已写，简单翻译即可，\n1 2 3 public double confidenceLow() { return mean() - ((1.96 * stddev()) / Math.sqrt(T)); } public double confidenceHigh() 此题与上题别无二致，不赘述，\n1 2 3 public double confidenceHigh() { return mean() + ((1.96 * stddev()) / Math.sqrt(T)); } 至此，所有内容均已完成，可以用模拟来看看自己的程序是否对，也可以看看教授给出的模拟后的样子。\n详细内容可以看我的GitHub仓库\n写在后面 本HW一开始确实很难想到，看了Josh教授的提示才能写个七七八八，不过总体来说不难。\n参考资料 「CS61B」Note(1) HW2 Percolation\nCS61B 算法作业：Percolation（蒙特卡洛渗流模拟）的Java 实现\ncs61b实验记录（四）HW2，lab9\n","date":"2025-03-23T00:00:00Z","image":"https://YuTaki23.github.io/p/cs61b-sp18-hw2-percolation/image2_hu_d7fb689556947c4b.png","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-hw2-percolation/","title":"CS61B SP18 HW2 Percolation"},{"content":"写在前面 本Homework取自UCB CS61B SP18的HW1。\n本HW需要我们从十分底层开始一步一步抽象直到最后完成一个模拟音乐的程序，很好的锻炼了我们对于Java项目的组织能力与Java的特性如继承与多态等。\n本文章为笔者在完成了所有任务后返回来写的，并非一步一步的思考，故少了许多碎碎念，多了一分严谨。但是故弟子不必不如师，师不必贤与弟子。若本文章存在错误或更好的想法，欢迎与我联系。\n点这里向我发邮箱~\n具体步骤 Task1: BoundedQueue 本任务向我们介绍了接口的概念，并要求我们完成一个名为BoundedQueue的一个接口，对于接口，我们声明它使用interface关键字，接口不用实现具体方法，只需要给出具体有什么具体方法（除了default）即可。在这里还需要将此接口作为包的一部分存在，大部分内容在任务要求已经告诉我们了，故可得，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package synthesizer; public interface BoundedQueue\u0026lt;T\u0026gt; { /** * @return 返回buffer的size */ int capacity(); /** * @return 返回当前buffer内有多少个items */ int fillCount(); /** * @param x 将x添加到最后 */ void enqueue(T x); /** * @return 删除并返回第一个item */ T dequeue(); /** * @return 返回但不要删除第一个item */ T peek(); } 本任务还要求我们完成两个default方法，十分显然，不赘述，具体可看我在下面写的注释，\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * @return 若当前buffer为空则返回true，否则返回false */ default boolean isEmpty() { return this.fillCount() == 0; } /** * @return 若当前buffer全满返回true，否则返回false */ default boolean isFull() { return this.capacity() == this.fillCount(); } Task 2: AbstractBoundedQueue 本任务要求我们实现一个继承上一个类的抽象类，即加上abstract与implements关键字，同时对于上文实现的两个default方法，需要在这里显式声明一下，并调用super方法其他跟着任务需求即可完成，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package synthesizer; public abstract class AbstractBoundedQueue\u0026lt;T\u0026gt; implements BoundedQueue\u0026lt;T\u0026gt; { protected int fillCount; protected int capacity; @Override public int capacity() { return this.capacity; } @Override public int fillCount() { return this.fillCount; } @Override public boolean isEmpty() { return BoundedQueue.super.isEmpty(); } @Override public boolean isFull() { return BoundedQueue.super.isFull(); } @Override public abstract T peek(); @Override public abstract T dequeue(); @Override public abstract void enqueue(T x); } Task 3: ArrayRingBuffer 本任务以类中TODO注释为顺序解释\nTODO1: Make sure to make this class a part of the synthesizer package 简单的显式声明一下属于这个包即可，\n1 package synthesizer; TODO2: Make sure to make this class and all of its methods public 确保一下类与方法均为public，教授已经帮我们做过了。\nTODO3: Make sure to make this class extend AbstractBoundedQueue\u0026lt; t \u0026gt; 这里改一下，t应该变成大写T，\n1 public class ArrayRingBuffer\u0026lt;T\u0026gt; extends AbstractBoundedQueue\u0026lt;T\u0026gt; TODO4: public ArrayRingBuffer(int capacity) 在这里需要我们完成类的构造函数，根据要求具体需要\n创建一个泛型数组 将first last fillCount均初始化为0 显式将capacity声明一下 对于泛型数组的初始化，需要记住的是强制转换为我们需要的类型，\n1 2 3 4 5 6 7 public ArrayRingBuffer(int capacity) { this.rb = (T[]) new Object[capacity]; this.first = 0; this.last = 0; this.fillCount = 0; this.capacity = capacity; } TODO5: public void enqueue(T x) 在开始这道题之前，需要先了解一下本任务中对队列的使用方法，我们可以将它简单想为一个循环数组，存在两个指针，first与last，初始值均为0，最大值可以到达此buffer的capacity。enqueue为在队列末尾添加一个元素，而每当我们添加一个元素时，就相当于在数组last的位置上添加了这个值，而此时last需要自增，值得注意的是，第一次添加的值的index并不一定是0，可以是任意小于capacity的值，故这里就需要我们考虑指针已经到达capacity了，但前面还没有被填满的情况，这里很想我们在proj1做过的循环头节点，只需要使用取模的方式就可以判断，那如何判断是否已经全部存储完了呢？只需要头指针与尾指针相等的情况下，就说明此时已经全部填完了，\n1 2 3 4 5 6 7 8 9 public void enqueue(T x) { if (isFull()) { throw new RuntimeException(\u0026#34;Ring buffer overflow\u0026#34;); } else { rb[last] = x; fillCount++; last = (last + 1) % capacity; } } TODO6: public T dequeue() 此题的大致内容与上题没什么两样，唯一值得注意的是，在取出队列的值时，是取出最前面的值，这也告诉我们，此时需要维护的是头指针，每去除一个值，头指针就需要自减一次，同样，也会存在到达0了但是后面还有内容没有取出来的情况，故还是需要用到取模，\n1 2 3 4 5 6 7 8 9 10 11 public T dequeue() { if (isEmpty()) { throw new RuntimeException(\u0026#34;Ring buffer underflow\u0026#34;); } else { T result = rb[first]; rb[first] = null; fillCount--; first = (first + 1) % capacity; return result; } } TODO7: public T peek() 此题需要我们仅返回队列第一个的内容，但不删除，简单的数组操作，不赘述，\n1 2 3 4 5 6 7 public T peek() { if (isEmpty()) { throw new RuntimeException(\u0026#34;Ring buffer underflow\u0026#34;); } else { return rb[first]; } } Task 4: GuitarString 本任务以TODO注释作为顺序来解答\nTODO1: Make sure to make this class a part of the synthesizer package 简单的声明包，不赘述，\n1 package synthesizer; TODO2: public GuitarString(double frequency) 本题需要我们创建一个buffer，其capacity为一个特殊值，并将此buffer内的所有值初始化为0，简单的迭代，\n1 2 3 4 5 6 7 8 9 10 public GuitarString(double frequency) { // TODO: Create a buffer with capacity = SR / frequency. You\u0026#39;ll need to // cast the result of this divsion operation into an int. For better // accuracy, use the Math.round() function before casting. // Your buffer should be initially filled with zeros. this.buffer = new ArrayRingBuffer\u0026lt;\u0026gt;((int) Math.round(SR / frequency)); for (int i = 0; i \u0026lt; buffer.capacity(); i++) { buffer.enqueue(0.0); } } TODO3: public void pluck() 本题需要我们将buffer内的值替换为一个[-0.5 - 0.5]的随机数，其中随机数必须每次都不一样，使用Math.Random()即可，简单的迭代，\n1 2 3 4 5 6 7 public void pluck() { for (int i = 0; i \u0026lt; buffer.capacity(); i++) { double r = Math.random() - 0.5; buffer.dequeue(); buffer.enqueue(r); } } TODO4: public void tic() 本题需要我们以Karplus-Algorithm为参考，即将队列的前两个值求平均值并乘能量衰减因子，并将此值替换为队列的前一个值，故这里可以看出来，对于第一个值要取出并返回，第二个值只需要返回即可不需要取出，因此，\n1 2 3 4 5 public void tic() { double firstItem = buffer.dequeue(); double secondItem = buffer.peek(); buffer.enqueue((firstItem + secondItem) * 0.5 * DECAY); } TODO5: public double sample() 本题需要我们返回队列当中的第二个值，但不需要取出，\n1 2 3 public double sample() { return buffer.peek(); } Task 5: Iteration and Exceptions BoundedQueue 修改类声明即可，不赘述\n1 public interface BoundedQueue\u0026lt;T\u0026gt; extends Iterable\u0026lt;T\u0026gt; ArrayRingBuffer 此题需要我们对iterator()的方法进行重写，迭代器包含三个方法，构造函数、hasNext()和next()，根据Josh教授的提示可以知道，\nprivate RingBufferIterator()只需要在这里添加一个计数器，以便之后判断是否到达边界即可。\npublic boolean hasNext()判断之后还有没有元素了，只需要判断此时的计数器是否到达了buffer中已有的元素数量。\npublic T next()求下一个元素的值，简单的数组操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import java.util.Iterator; public Iterator\u0026lt;T\u0026gt; iterator() { return new RingBufferIterator(); } private class RingBufferIterator implements Iterator\u0026lt;T\u0026gt; { private int current; private RingBufferIterator() { this.current = 0; } @Override public boolean hasNext() { return current != fillCount(); } @Override public T next() { T item = rb[current]; current++; return item; } } Exceptions 上文已完成，不赘述。\n详细内容可以看我的GitHub仓库\n关于这里的API Checker，若把关键字改为private则无法编译，故放弃。\n写在后面 总的来说本HW并不难，大多数已经给出步骤，只需要简单翻译即可。\n","date":"2025-03-22T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-hw-1-packages-interfaces-generics-exceptions-iteration/","title":"CS61B SP18 HW 1 Packages, Interfaces, Generics, Exceptions, Iteration"},{"content":"写在前面 本项目取自UCB CS61B SP18的Project1B，整体来说难度不大，主要是考察我们在已给出API的情况下完成任务，这或许是未来工作时很常见的工作流。本文章仅为笔者做题时的想法，如果存在错误或您有更好的想法，欢迎与我联系。\n点这里向我发邮件~\n具体思路 Task 1: Deque Interface 本任务主要是要我们创建一个类，即1A中完成的链表，并通过继承、接口等向我们介绍了Java的特性。笔者为不引发歧义，在这里使用Josh教授的代码，而非自己实现的，如果你对自己的代码有信心，也欢迎直接复制。综上，整体步骤不难，跟着提示一步一步来即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public interface Deque\u0026lt;Item\u0026gt; { public void addFirst(Item item); public void addLast(Item item); public boolean isEmpty(); public int size(); public void printDeque(); public Item removeFirst(); public Item removeLast(); public Item get(int index); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import java.util.LinkedList; import java.util.NoSuchElementException; public class LinkedListDeque\u0026lt;Item\u0026gt; extends LinkedList\u0026lt;Item\u0026gt; implements Deque\u0026lt;Item\u0026gt; { @Override public void printDeque() { System.out.println(\u0026#34;dummy\u0026#34;); } public Item getRecursive(int i) { return get(i); } @Override public Item removeFirst() { try { return super.removeFirst(); } catch (NoSuchElementException e) { return null; } } @Override public Item removeLast() { try { return super.removeLast(); } catch (NoSuchElementException e) { return null; } } } Task 2: wordToDeque 本任务需要我们创建一个新类，其中包括一个新方法，即将一个字符串变成一系列字符，并用链表连接起来，并完成测试，简单的迭代。\n1 2 3 4 5 6 7 8 9 10 public class Palindrome { public Deque\u0026lt;Character\u0026gt; wordToDeque(String word) { Deque\u0026lt;Character\u0026gt; deque = new LinkedListDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; word.length(); i++) { char currentWord = word.charAt(i); deque.addLast(currentWord); } return deque; } } Task 3: isPalindrome Task 3A: isPalindrome Testing 本任务需要我们编写测试，即判断一个字符串是否为回文，运用assertTrue和assertFalse来判断，以下为我编写的测试，可能与你写的不一样，无伤大雅。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testIsPalindromeFalse() { assertFalse(palindrome.isPalindrome(\u0026#34;cat\u0026#34;)); assertFalse(palindrome.isPalindrome(\u0026#34;abc\u0026#34;)); assertFalse(palindrome.isPalindrome(\u0026#34;Aa\u0026#34;)); } @Test public void testIsPalindromeTrue() { assertTrue(palindrome.isPalindrome(\u0026#34;a\u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34;aba\u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34;aa\u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34; \u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34;redder\u0026#34;)); } Task 3B: isPalindrome 本任务就需要我们具体实现这个方法了，思路为，一个字符串的字符数可能为奇数或偶数，只需要第一个与最后一个做判断，然后不断向中间靠拢即可，同时根据题意，还存在一个base case，即字符数为0或1的时候均判断为回文数，不难写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 public boolean isPalindrome(String word) { int length = word.length(); if (length != 0 \u0026amp;\u0026amp; length != 1) { Deque\u0026lt;Character\u0026gt; deque = wordToDeque(word); for (int i = 0, j = deque.size() - 1; i \u0026lt; deque.size() / 2; i++, j--) { if (deque.get(i) != deque.get(j)) { return false; } } } return true; } Task 4: Generalized Palindrome and OffByOne 在这里，题目向我们介绍了不仅有第一个字符与最后一个字符相同称为回文数，还存在其他类型的回文数，比如相差1位也被称为回文数，根据题目的顺序来写，不难写出，\n1 2 3 4 5 6 7 public class OffByOne implements CharacterComparator { @Override public boolean equalChars(char x, char y) { int diff = Math.abs(x - y); return diff == 1; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import org.junit.Test; import static org.junit.Assert.*; public class TestOffByOne { // You must use this CharacterComparator and not instantiate // new ones, or the autograder might be upset. static CharacterComparator offByOne = new OffByOne(); // Your tests go here. @Test public void testEqualCharsTrue() { assertTrue(offByOne.equalChars(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)); assertTrue(offByOne.equalChars(\u0026#39;r\u0026#39;, \u0026#39;q\u0026#39;)); assertTrue(offByOne.equalChars(\u0026#39;\u0026amp;\u0026#39;, \u0026#39;%\u0026#39;)); } @Test public void testEqualCharsFalse() { assertFalse(offByOne.equalChars(\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;)); assertFalse(offByOne.equalChars(\u0026#39;z\u0026#39;, \u0026#39;a\u0026#39;)); assertFalse(offByOne.equalChars(\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;)); } } 1 2 3 4 5 6 7 8 9 10 11 12 public boolean isPalindrome(String word, CharacterComparator cc) { int length = word.length(); if (length != 0 \u0026amp;\u0026amp; length != 1) { Deque\u0026lt;Character\u0026gt; deque = wordToDeque(word); for (int i = 0, j = deque.size() - 1; i \u0026lt; deque.size() / 2; i++, j--) { if (!cc.equalChars(word.charAt(i), word.charAt(j))) { return false; } } } return true; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testIsPalindromeWithCCFalse() { CharacterComparator cc = new OffByOne(); assertFalse(palindrome.isPalindrome(\u0026#34;ac\u0026#34;, cc)); assertFalse(palindrome.isPalindrome(\u0026#34;ok\u0026#34;, cc)); } @Test public void testIsPalindromeWithCCTrue() { CharacterComparator cc = new OffByOne(); assertTrue(palindrome.isPalindrome(\u0026#34;ab\u0026#34;, cc)); assertTrue(palindrome.isPalindrome(\u0026#34;flake\u0026#34;, cc)); assertTrue(palindrome.isPalindrome(\u0026#34;%\u0026amp;\u0026#34;, cc)); assertTrue(palindrome.isPalindrome(\u0026#34; \u0026#34;, cc)); } Task 5: OffByN 最后就要求我们更为通用的实现回文数了，主要包括一个构造函数与一个方法，与OffByOne没什么两样，具体实现如下，\n1 2 3 4 5 6 7 8 9 10 11 12 public class OffByN implements CharacterComparator { private int items; public OffByN(int N) { this.items = N; } public boolean equalChars(char x, char y) { int diff = Math.abs(x - y); return diff == this.items; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import org.junit.Test; import static org.junit.Assert.*; public class TestOffByN { static CharacterComparator offBy5 = new OffByN(5); static CharacterComparator offBy1 = new OffByN(1); @Test public void testEqualCharsFiveTrue() { assertTrue(offBy5.equalChars(\u0026#39;a\u0026#39;, \u0026#39;f\u0026#39;)); assertTrue(offBy5.equalChars(\u0026#39;f\u0026#39;, \u0026#39;a\u0026#39;)); } @Test public void testEqualCharsFiveFalse() { assertFalse(offBy5.equalChars(\u0026#39;h\u0026#39;, \u0026#39;f\u0026#39;)); } } 总的代码实现可以看我的GitHub仓库\n写在后面 总的来说并不难，比上一个1A好多了:(\n","date":"2025-03-15T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-project1b-applying-and-testing-data-structures-version-1.0/","title":"CS61B Project1B Applying and Testing Data Structures version 1.0"},{"content":"[YuTaki] CS61B SP18 Project1A: Data Structure 写在前面 本项目取自CS61B SP18的Project1A，仅为个人做题时的思路及想法，如果有更好的想法，欢迎与我联系。\n点这里向我发邮件\n具体思路 LinkedListDeque public LinkedListDeque() 在最开始初始化链表时，大家就应该把思路理清楚。Josh教授在LinkedListDeque这一部分推荐我们使用两个方法来实现，第一个是two sentinel topology，第二个是circular sentinel topology，在这里笔者使用的方法是第二个也是Josh教授推荐我们使用的方法。\n首先大家先看看上半部分，是初始化链表很重要的一部分，我们可以看出来，在这个类中，存在两个实例变量size和sentinel，以及若干方法，同时还存在一个Nested ClassIntNode，这是十分显而易见的，如果不清楚为什么这么做，建议看一下Josh教授的SLList实现，由此我们就可以写出来一部分代码，即\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class LinkedListDeque\u0026lt;T\u0026gt; { private class IntNode { public IntNode prev; public T item; public IntNode next; public IntNode(IntNode p, T i, IntNode n) { this.prev = p; this.item = i; this.next = n; } } private IntNode sentinel; private int size; } 关键点来了，在做完这些后，就该开始初始化链表了。仔细观察一下，sentinel一共存在三个变量，prev item next，我的想法是，sentinel一直指向的是item，而我们需要做的是将这些箭头用编程语言翻译出来。首先看next的那个箭头，它指向的是prev而prev又指向了item，所以可以翻译为sentinel.next = sentinel，再看prev的箭头，即sentinel.prev = sentinel。由此我们就做完了。\n1 2 3 4 5 6 public LinkedListDeque() { sentinel = new IntNode(null, null, null); sentinel.next = sentinel; sentinel.prev = sentinel; size = 0; } 有同学可能会想，为什么不可以在new的时候就把正确的填上去，而是要加上null，毫无意义。一开始整个节点还没有被创建出来，指向一个不存在的东西或许会造成空指针异常。\npublic void addFirst(T item) 在考虑addFirst时，应该清楚一点，在这里应该使用更为通用的方法，即当前已经存在了一个IntNode，我们需要再另外添加一个，这不会像仅存在一个sentinel一样，具有特殊性。对于此题，画图是一个很好的方法，我在这里简易的画了一个，不喜勿喷。\n我们需要添加的是这个5，一步一步来看。首先要初始化一个IntNode，并且还是添加到第一位，那么一定是sentinel.next = new IntNode()，那么括号里具体应该填什么？我创建的参数第一个为新Node的prev，那现在来看，prev代表的就是sentinel本身；第二个参数为变量item，在此不赘述；第三个参数为next，那现在这个next指向的是原先的sentinel.next。至此，我们两个指向右边的箭头就已经全部翻译完毕。\n接下来看看指向左边的两个箭头。首先第一个箭头，即sentinel.next = sentinel.next.prev；第二个箭头，即sentinel.next.next.prev = sentinel.next。\n而最后一个sentinel.prev的箭头则与一开始没有不同，所以不用变化。\n综上可得，\n1 2 3 4 5 public void addFirst(T item) { sentinel.next = new IntNode(sentinel, item, sentinel.next); sentinel.next.next.prev = sentinel.next; size++; } public void addLast(T item) 本题与上题大差不差，唯一需要变得是sentinel.prev，应该由这个来引出。\n1 2 3 4 5 public void addLast(T item) { sentinel.prev = new IntNode(sentinel.prev, item, sentinel); sentinel.prev.prev.next = sentinel.prev; size++; } public boolean isEmpty() 这道题就很简单了，还记得我们上文提到的size变量吗，每当加一个变量时size++，反之size--，判断size是否为0即可。\n1 2 3 public boolean isEmpty() { return size == 0; } public int size() 与上题类似，不赘述。\n1 2 3 public int size() { return size; } public void printDeque() 打印所有IntNode的item，用空格分开，由size可知共有多少项，需要注意的是，还要判断一个base case，简单的迭代。\n1 2 3 4 5 6 7 8 9 10 public void printDeque() { IntNode currentNode = sentinel.next; if (size == 0) { return; } for (int i = 0; i \u0026lt; size; i++) { System.out.print(currentNode.item + \u0026#34; \u0026#34;); currentNode = currentNode.next; } } public T removeFirst() 首先一个base case，若size == 0 return null。再看看上面的图，对于第一个元素，控制他的一定是sentinel.next，所以要在这上面做文章，首先要把next从sentinel之后的第一个元素改变为第二个元素，即sentinel.next = sentinel.next.next.prev = sentinel，这代表的是第二个元素指向第一个元素变成第二个元素（现在的第一个元素）指向sentinel；其次，现在要把sentinel.next指向原先的第二个元素，即sentinel.next = sentinel.next，综上，\n1 2 3 4 5 6 7 8 9 10 11 public T removeFirst() { if (size == 0) { return null; } else { IntNode currentNode = sentinel.next; sentinel.next.next.prev = sentinel; sentinel.next = sentinel.next.next; size--; return currentNode.item; } } public T removeLast() 与上文相反，举一反三即可，\n1 2 3 4 5 6 7 8 9 10 11 public T removeLast() { if (size == 0) { return null; } else { IntNode currentNode = sentinel.prev; sentinel.prev.prev.next = sentinel; sentinel.prev = sentinel.prev.prev; size--; return currentNode.item; } } public T get(int index) 简单的迭代。\n1 2 3 4 5 6 7 8 9 10 11 public T get(int index) { if (index \u0026gt; size) { return null; } else { IntNode currentNode = sentinel.next; for (int i = 0; i \u0026lt; index; i++) { currentNode = currentNode.next; } return currentNode.item; } } public T getrecursive(int index) 这道题需要我们用递归实现get，只用一个get是没法实现递归的，没办法读取元素，需要添加另一个函数，不断递归到达目的地以读取元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private T getRecursive(int index, IntNode temp) { if (index == 0) { return temp.item; } else { return getRecursive(index - 1, temp.next); } } public T getRecursive(int index) { IntNode currentNode = sentinel.next; if (index \u0026gt;= size) { return null; } else { return getRecursive(index, currentNode); } } ArrayDeque 对于此类，我的想法是首先使用Josh教授特别推荐的circular sentinel，其次先把整体思路写出来，最后再做resize部分。\npublic ArrayDeque() 首先来观察一下这幅图，不难看出，题目首先要求我们将数组初始化为可以存放8个内容的数组；对于此类，还存在四个实例变量，分别是size nextFirst items 以及 nextLast，并且Josh教授还把nextFirst和nextLast分别存为了4和5，不过在这里未来的我回过头告诉我，这里应该把8添加一个变量名，由此可以得出，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class ArrayDeque\u0026lt;T\u0026gt; { private int size; private int nextFirst; private T[] items; private int nextLast; private static final int initCapacity = 8; private int capacity; public ArrayDeque() { this.size = 0; this.nextFirst = 4; this.items = (T[]) new Object[initCapacity]; this.nextLast = 5; } } public void T addLast(T item) 将这幅图与上一幅图相比较，可以看出addLast是如何工作的，原先nextLast是5，而现在所添加的元素，到了数组5的位置，nextLast自增，但是我们想一下特殊情况，如果nextLast到了最后也就是7的位置，这时候再有一个addLast该怎么办呢？slide给出的答案是，nextLast会到0的位置上，由此就可以看出，所添加的元素要放在当前nextLast的位置上，由此，不难写出代码，\n1 2 3 4 5 6 7 8 9 public void addLast(T item) { items[nextLast] = item; if (nextLast == initCapacity - 1) { nextLast = 0; } else { nextLast++; } size++; } public void T addFirst(T item) 与上题大体相似，没有什么不同，在此不做过多赘述。\n1 2 3 4 5 6 7 8 9 public void addLast(T item) { items[nextLast] = item; if (nextLast == initCapacity - 1) { nextLast = 0; } else { nextLast++; } size++; } public boolean isEmpty() 简单的判断。\n1 2 3 public boolean isEmpty() { return size == 0; } public int size() 与上文一样，没有什么不同。\n1 2 3 public int size() { return size; } public void printDeque() 此题需要我们打印整个连边，首先很容易想到有一个base case，当链表里面没有东西的时候，直接返回；其次我们需要明白的一点是，数组01234的顺序并不是我们链表的顺序，所以不能简单的迭代打印整个数组，观察教授给我们的提示，\n我们可以看到现在的链表顺序为右上角的Conceptual Deque，而我们数组的顺序跟这个是不一样的，链表的第一个应该是nextFirst + 1，但这里又会有问题，如果现在nextFirst在最后面该怎么办呢？所以这里又需要我们做一个判断，现在我们知道了初始点，那应该在什么时候结束呢？可以发现，nextFirst会不断自增，直到到达最开始的地方，所以在这里我们就可以用一个变量来表示，这个函数用了很多次，我们不妨把它抽象出来，由此我们上面的函数也可以引用这一层抽象，更新为，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 private int plus(int index) { if (index == capacity) { index = 0; } else { index++; } return index; } private int minus(int index) { if (index == 0) { index = capacity - 1; } else { index--; } return index; } public void addFirst(T item) { items[nextFirst] = item; nextFirst = minus(nextFirst); size++; } public void addLast(T item) { items[nextLast] = item; nextLast = plus(nextLast); size++; } public void printDeque() { if (size == 0) { return; } int index = nextFirst; index = plus(index); while (index != nextFirst) { System.out.print(items[index] + \u0026#34; \u0026#34;); index = plus(index); } } public T removeFirst() 首先一个很明显的base case，链表为空时，return null，根据上图可以看出来，第一个元素是位于nextFirst + 1的元素，首先，我们要把这个元素设为null，然后，还要把nextFirst再往后移动一位，所以不难写出，\n1 2 3 4 5 6 7 8 9 10 public T removeFirst() { if (size == 0) { return null; } int current = plus(nextFirst); nextFirst = current; items[nextFirst] = null; size--; return items[current]; } public T removeLast() 这道题与上一道题差别不大，举一反三即可，\n1 2 3 4 5 6 7 8 9 10 public T removeLast() { if (size == 0) { return null; } int current = minus(nextLast); nextLast = current; items[nextLast] = null; size--; return items[current]; } public T get(int index) 这道题确实没想明白，参考了别人的答案，还是想不通。\nresize 接下来，就应该想想可变数组的想法了。题目告诉我们，对于长度大于等于16的数组，应该一直保持使用系数为25%，即若当前有16个元素，那我们的数组长度应当为64，\n根据这幅图可以看出来，我们需要把前一半元素放在新数组的开头，把后一半元素放在新数组的结尾\nresize对于我来说有点困难了，跳过。\n写在后面 LinkedListDeque不难，看图就可以看个大概。ArrayDeque的resize部分有点困难了，未来再说吧。\n","date":"2025-03-12T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-project1a-data-structure/","title":"CS61B SP18 Project1A Data Structure"},{"content":"[YuTaki] Make Life More Regular——听歌篇 一、写在前面 让生活更有条理性。\n作为Make Life More Regular的第一篇内容，笔者选择了每天都会做的一件事——听歌。\n你是否还在烦恼自己的歌怎么在平台上突然没有版权了？\n你是否还在厌倦听歌时看着不同的人发着不同的“emo文字”？\n本文章仅为笔者自己平时的听歌流，主要方式为将网络音乐下载到本地进行收听，本文章会主要讲解以什么方式下载以及更优雅的设置听歌方式。\n本文章仅代表笔者个人观点，主观性很强，一千个读者有一千个哈姆雷特。\n若本文章出现了什么错误或您有更好的想法，欢迎与我联系。\n[点这里向我发邮箱~](mailto: yutaki23@163.com)\n二、运行设备与主要应用 操作系统：Android12 OriginOS Salt Palyer 极其优秀的安卓本地音乐播放器，其简洁但不失重要功能深受笔者喜爱。 bilidown 一款简洁易下载哔哩哔哩视频的软件。应作者要求，在此不贴上软件地址，有需要的请自行寻找。 MusicTag 可将本地音乐的歌曲名、作者、专辑、歌词等信息作为元数据导入到歌曲中。在Salt Player中可以读取出来。 三、主要优点与缺点 优点 长期存在。不用再担心自己的歌曲会被版权收掉，只要歌曲一直存在本地，只要硬盘不损坏，歌曲就不会有丢失的一天。 简单干净的页面。不用在听歌的时候看网友所谓的“丧语录”。 缺点 对新歌的感知弱。新歌发布后无法第一时间接收到消息，只能由他人推荐，或自己随缘找到。 四、操作步骤 **找到你喜欢的歌。**一般来说，大家喜欢听的歌都可以在互联网上找到，包括但不限于哔哩哔哩、抖音、YouTube等媒体播放网站。笔者在这里以哔哩哔哩和《麦恩莉》为例。将这首歌的网站复制下来，得到类似于这样的https://www.bilibili.com/video/BVxxxxxx/1一个网站。 下载歌曲。打开bilidown。将网站复制进去，即可得到类似于这样的界面。随后点击音频按钮即可开始下载，注意到，可以提前将音质调为192k，这样音质会更好。之后，会调出下载界面，此处笔者建议统一将文件名改为歌曲名-作者.m4a，这都是为了之后添加歌曲信息时更加方便。 **将元数据导入到歌曲中。**打开MusicTag，会看到这些内容，作为使用了很长时间的人来说，我给出的建议是： **改变工作目录。**将其改为你下载歌曲的文件夹。 自动匹配标签。全选你所下载的歌曲，让软件自动识别其标题、艺术家等内容。 检查。大致查看各元数据是否能对的上，如果不，单独找出来在左侧修改错误的内容，如果是封面错误，点击改变封面选择正确的封面，如果是歌词错误，点击改变歌词选择正确的歌词。笔者的经验是，如果一首歌的封面错误，那大概率歌词也有错，其他信息大概率都有错。最后不要忘记右键保存。 将歌曲传到手机上。笔者的建议为在手机上创建一个Music文件夹，用来专门存放下载的歌曲。打开Salt Player，点击左上角，左侧会出现扫描音乐选项，使用自定义文件夹，将其设置为下载歌曲的文件夹，点击开始扫描。\n**Congratulation!**此时，你就可以发现，你的歌曲已经到了Salt Player里面，并且标题、作者、专辑、封面等内容应有尽有。\n五、写在后面 大致的操作步骤就这些，有关这些应用的其他进阶操作，欢迎各位自己摸索。\n最后，感谢每一位创建这些软件的作者，希望大家尊重开源，享受开源。开源世界有你更精彩。\n六、相关问题 **问：**我只能使用各大网站下载的歌曲吗？\n答：当然不，如果你能找到Flac等更高级的格式当然是最好不过，但请不要在手机上直接下载听歌软件上的歌曲，大部分都有加密，过了VIP期限后就无法再听了。\n问：为什么后缀一定要改成m4a的格式，改成其他的不行吗？\n答：根据笔者尝试，使用mp3格式时会在将元数据导入歌曲中出现问题，其他格式还没有尝试过，有尝试过的朋友可以补充。\n问：为什么要在手机上创建一个新的文件夹？\n答：现在人的手机上大概率会有录音等其他非歌曲内容，Salt Player在识别的时候会将这些内容也识别为歌曲，而创建一个文件夹就可以让Salt Player只识别当前文件夹的内容。\n此网站非正确网站，在此仅为示例，替换成你所找到的歌曲的网站即可。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-03-12T00:00:00Z","permalink":"https://YuTaki23.github.io/p/make-life-more-regular-%E5%90%AC%E6%AD%8C%E7%AF%87/","title":"Make Life More Regular —— 听歌篇"},{"content":"写在前面 本项目取自 UCB CS61B SP18的Project0: NBody Simulation。作为CS61系列的第二门课，专注于数据结构与算法，本项目只是对Java有了个简单的认识。以下为笔者做题时的心得体会，如有错误或更好的想法，欢迎与我联系。\n点这里向我发邮件~\n具体实现 ###The Planet Class and Its Constructor\n这道题让我们了解了Planet这个类具体代表什么，存在哪些参数，还需要创建两个构造函数，两个拥有不同参数的构造函数。\n创建实例变量。在这个类里面按照题目要求一步一步写即可。 创建构造函数1。这个构造函数存在六个不同的参数，按照题目要求写好签名，在构造函数内部使用this即可完成。 创建构造函数2.这个构造函数存在一个参数，即一个已被实例化的Planet，需要将此Planet复制到新Planet中，使用this与p.点表达式即可完成。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Planet { public double xxPos; public double yyPos; public double xxVel; public double yyVel; public double mass; public String imgFileName; public Planet(double xP, double yP, double xV, double yV, double m, String img) { this.xxPos = xP; this.yyPos = yP; this.xxVel = xV; this.yyVel = yV; this.mass = m; this.imgFileName = img; } public Planet(Planet p) { this.xxPos = p.xxPos; this.yyPos = p.yyPos; this.xxVel = p.xxVel; this.yyVel = p.yyVel; this.mass = p.mass; this.imgFileName = p.imgFileName; } } Understanding the Physics 在这里题目向我们介绍了此项目用到的物理知识，都是简单的高中物理知识，我在这里简单说一下。\n万有引力公式。两个粒子之间存在相互吸引的力，大小为$F = \\dfrac{G \\cdot m_1 \\cdot m_2}{r^2}$，方向指向对方。 勾股定理。$r^2 = dx^2 + dy^2$。 在x轴上的力。$F_x = \\dfrac{F \\cdot dx}{r}$。 在y轴上的力。$F_y = \\dfrac{F \\cdot dy}{r}$。 合外力。即同一方向上的力的和。 加速度。$a_x = \\dfrac{F_x}{m}$ $a_y = \\dfrac{F_y}{m}$。 Writing the Planet Class calcDistance 此方法需要我们计算两行星之间的距离，运用勾股定理即可，值得注意的是，此题需要我们在一个Planet上使用点表达式来对另一个行星求解，也就是说，此题无法用static关键字。\n1 2 3 4 5 6 7 8 9 10 public double calcDistance(Planet p) { double x1 = this.xxPos; double y1 = this.yyPos; double x2 = p.xxPos; double y2 = p.yyPos; double xAbs = Math.abs(x1 - x2); double yAbs = Math.abs(y1 - y2); return Math.sqrt((xAbs * xAbs) + (yAbs * yAbs)); } clacForceExertedBy 此方法需要我们计算两行星之间的万有引力，运用上文提到的万有引力公式即可，值得注意的是，此题向我们介绍了一个新的语法static final也即常量，同时也介绍了科学计数法的写法。在这里我们可以将万有引力常数G用科学计数法设为常量。\n1 2 3 4 5 private static final double G = 6.67e-11; public double calcForceExertedBy(Planet p) { double radiusSquare = this.calcDistance(p) * this.calcDistance(p); return (G * this.mass * p.mass) / radiusSquare; } calcForceExertedByX and calcForceExertedByY 此方法需要我们计算两行星之间在x轴方向与在y轴方向上的力，用到的公式即为上文中的3 4两条，值得注意的是，在计算两行星之间的位移差时要注意哪个在前哪个在后。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public double calcForceExertedByX(Planet p) { double distanceX = p.xxPos - this.xxPos; double force = this.calcForceExertedBy(p); double radius = this.calcDistance(p); return (force * distanceX) / radius; } public double calcForceExertedByY(Planet p) { double distanceY = p.yyPos - this.yyPos; double force = this.calcForceExertedBy(p); double radius = this.calcDistance(p); return (force * distanceY) / radius; } calcNetForceExertedByX and calcNetForceExertedByY 此方法需要我们完成一系列行星对一个行星所施加的x轴与y轴方向的合分力（不知道也没有这个东西），值得注意的是，可以用到enhanced for来锻炼自己，以及continue用法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public double calcNetForceExertedByX(Planet[] planets) { double sumForce = 0; for (Planet p : planets) { if (this.equals(p)) { continue; } else { sumForce += this.calcForceExertedByX(p); } } return sumForce; } public double calcNetForceExertedByY(Planet[] planets) { double sumForce = 0; for (Planet p : planets) { if (this.equals(p)) { continue; } else { sumForce += this.calcForceExertedByY(p); } } return sumForce; } update 此方法需要我们计算经过一系列力之后，行星最终会到什么地方去，看着题目很长，实际上很简单，跟着题目给的步骤一步一步做即可，值得注意的是，此题不需要返回任何东西，只是在目前行星更新自己。\n1 2 3 4 5 6 7 8 9 10 public void update(double dt, double fX, double fY) { double accelerationX = fX / this.mass; double accelerationY = fY / this.mass; this.xxVel += dt * accelerationX; this.yyVel += dt * accelerationY; this.xxPos += dt * this.xxVel; this.yyPos += dt * this.yyVel; } Getting Started with the Simulator (NBody.java) ReadRadius 此题需要我们读取一个文件中的半径，根据题目可知，半径在一个文件中的第二位，以double形式存储。观察BasicInDemo.java不难发现，对于In这个类来说，是按顺序来查找文件中的每个变量，并且要以符合的形式来控制，值得注意的是，在这里要加上static关键字，综上易得。\n1 2 3 4 5 public static double readRadius(String filename) { In in = new In(filename); int firstItemInFile = in.readInt(); return in.readDouble(); } ReadPlanets 此题与上题类似，需要我们用In来不断读取内容，得到Planet的全部内容，并将其实例化为一个新的Planet，这里会用到Planet的构造函数1，可以得到，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static Planet[] readPlanets(String filename) { In in = new In(filename); int totalPlanets = in.readInt(); Planet[] planets = new Planet[totalPlanets]; double radius = in.readDouble(); for (int i = 0; i \u0026lt; totalPlanets; i++) { double xP = in.readDouble(); double yP = in.readDouble(); double xV = in.readDouble(); double yV = in.readDouble(); double m = in.readDouble(); String img = in.readString(); planets[i] = new Planet(xP, yP, xV, yV, m, img); } return planets; } Drawing the Initial Universe State (main) Collecting All Needed Input 跟着步骤一步一步来即可，很容易。\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) { String TString = args[0]; String dtString = args[1]; String filename = args[2]; double T = Double.parseDouble(TString); double dt = Double.parseDouble(dtString); Planet[] planets = readPlanets(filename); double radius = readRadius(filename); } Drawing the Background 观察StdDrawDemo.java即可知道如何创建scale与background，跟着Demo走即可。\n1 2 3 4 5 6 private static final String imgPath = \u0026#34;images/starfield.jpg\u0026#34;; StdDraw.setScale(-radius, radius); StdDraw.clear(); StdDraw.picture(0, 0, imgPath); StdDraw.show(); Drawing One Planet 使用StdDraw.picture()即可，题目要求在行星自己的位置上画自己，即xxPos与yyPos和imgFileName.\n1 2 3 public void draw() { StdDraw.picture(xxPos, yyPos, \u0026#34;images/\u0026#34; + imgFileName); } Drawing All of the Planets 简单的迭代\n1 2 3 for (Planet planet : planets) { planet.draw(); } Creating an Animation 步骤都给出来了，写到后面也累了，大家自己看看吧（逃）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 StdDraw.enableDoubleBuffering(); double time = 0; while (time \u0026lt; T) { double[] xForces = new double[planets.length]; double[] yForces = new double[planets.length]; for (int i = 0; i \u0026lt; planets.length; i++) { xForces[i] = planets[i].calcNetForceExertedByX(planets); yForces[i] = planets[i].calcNetForceExertedByY(planets); } for (int j = 0; j \u0026lt; planets.length; j++) { planets[j].update(dt, xForces[j], yForces[j]); } StdDraw.clear(); StdDraw.picture(0, 0, imgPath); for (Planet planet : planets) { planet.draw(); } StdDraw.show(); StdDraw.pause(10); time += dt; 写在后面 本项目已完成，用时大约四小时，当然这也不是我第一次做:( ，作为第二个复习课程的第一个项目，整体难度并不大，大部分代码框架与提示都已给出，跟着题目走即可。\n点这里查看GitHub代码\n","date":"2025-03-08T00:00:00Z","image":"https://YuTaki23.github.io/p/cs61b-sp18-project0-nbody-simulation/image1_hu_d8ded748ccf5e499.png","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-project0-nbody-simulation/","title":"CS61B SP18 Project0 Nbody Simulation"},{"content":"写在前面 本项目为UC Berekly CS61A SP24的 Project4: Scheme。以下为个人对此项目的见解，如有错误或更好的解决方案，欢迎与我联系。\n点这里向我发邮件~\n具体思路 Problem 1 首先通读一下题目，此题需要我们完成两个函数define和lookup，同时给了我们关于Frame的一些信息，Frame有两个instance attribute。\nbindings 这是一个字典，回顾一下字典的相关内容，字典，相当于其他语言的map，存在一个key和一个value，每个字典当中只能有一个唯一的key，但key中存放的数据可以是相同的。此题中，key就代表的是symbol，而value代表的就是其本意，相当于我们在python当中的等号赋值用法，例如，x = 3在这里key就是x，value就是3。 parent 每个frame都可以被嵌套在另一个frame里面，而他们最终的frame都是None。 define 非常显而易见了，上文中也提到过，在此不再赘述。\n1 2 3 def define(self, symbol, value): \u0026#34;\u0026#34;\u0026#34;Define Scheme SYMBOL to have VALUE.\u0026#34;\u0026#34;\u0026#34; self.bindings[symbol] = value lookup 此函数可以想成三个case，题目当中也给了我们很详细的描述。\n若symbol在当前frame里，直接返回value。 若symbol不在当前frame里，且其含有父frame，且父frame里含有此symbol，返回value。关于这个case，有几点需要说明 其含有父frame。问：如何界定此frame是否合法？答：只要不为None，都是合法的。 父frame里含有symbol。问：如何访问父frame？答：用点表达式访问parent即可。 若均不满足以上情况，即symbol不在当前frame里，且没有父frame，arise error。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def lookup(self, symbol): \u0026#34;\u0026#34;\u0026#34;Return the value bound to SYMBOL. Errors if SYMBOL is not found.\u0026#34;\u0026#34;\u0026#34; current_frame = self # case1 若symbol在当前frame if symbol in current_frame.bindings: return current_frame.bindings.get(symbol) # case2 symbol不在当前frame 但在parent frame else: current_frame = current_frame.parent while current_frame is not None: if symbol in current_frame.bindings: return current_frame.bindings.get(symbol) current_frame = current_frame.parent # case3 都不存在 引发error raise SchemeError(\u0026#39;unknown identifier: {0}\u0026#39;.format(symbol)) Problem 2 首先通读一下题目，此题要求我们实现一个scheme_apply函数中的一个case，即BuiltinProcedure。在完成一个表达式时，存在内置的一些操作如 + - * /等，在此，就需要我们实现这些操作。\nBuiltinProcedure含有两个instance attribute。\npy_func 找到对应的操作符号，用python的内置函数来实现表达式，不用我们自己实现（自己似乎也实现不了，有点不切实际）。 need_env 有些内置函数需要特定的环境。 此题可分为三个步骤来写，题目中也给的很清楚。\n将scheme list 转变为python list，与上题很类似。 判断need_env的是否，很简单。 使用*args表示法来调用py_func这里可能需要了解一下什么是 *args表示法。 1 2 3 4 5 6 7 8 9 10 11 12 13 try: # 将scheme list转变为 python list lst = [] while args is not nil: lst.append(args.first) args = args.rest # 判断 need_env if procedure.need_env is True: lst.append(env) # 调用 py_func return procedure.py_func(*lst) except TypeError as err: raise SchemeError(\u0026#39;incorrect number of arguments: {0}\u0026#39;.format(procedure)) Problem 3 此题需要让我们将scheme_eval补充完整，大致题目已给出，我们需要完成的是判断此表达式，并通过上文完成的scheme_apply函数来计算结果。题目还是给了我们大致思路。\n判断operator，使用递归。Recrusion，即自身调用自身，那一定是在scheme_eval函数里调用scheme_eval。对于此函数，我们需要三个参数，expresson environment以及一个默认参数，文中给了我们代码提示first = expr.first，由此即可以判断此处的expression = first，同时还要求我们evaluate to a procedure instance。scheme_apply的开头就给了我们提示 判断operands，依旧使用递归。与上文类似，题目已经给了我们rest = expr.next，同时题目要求我们收集到scheme列表里，下文有提示，使用Pair的map方法，观察map方法，这提供了一个形参fn，显然此处的fn就是scheme_eval，但scheme_eval存在两个形参，这就需要我们进行转换，使用lambda函数。 之后就是调用scheme_apply，很显然，在此不做过多赘述。 1 2 3 4 5 6 7 else: # evaluate operator procedure = scheme_eval(first, env) validate_procedure(procedure) # evaluate operand operands = rest.map(lambda x: scheme_eval(x, env)) return scheme_apply(procedure, operands, env) Problem 4 此题要求我们实现define，简单来说，就是将一个expressions赋值给一个symbol。我们在这里只需要实现第一个部分，即计算一个表达式作为expressions并复制给一个提供给我们的symbol，下方还有提示，需要我们用到Frame里的define。那我们想一想define函数需要我们提供什么参数呢？\nsymbol symbol总是存在于一个表达式的第一位，函数也给了我们一个提示，即signature = expressions.first，由此我们就可以看出我们的symbol就是这个。 expressions 对于一个表达式来说，我们需要赋值的不仅仅是表达式本身，还是它计算后的数值是什么，所以在这里我们还需要用到上文完成的scheme_eval函数。 最后，需要我们返回已绑定的symbol。 1 2 3 4 5 6 signature = expressions.first if scheme_symbolp(signature): # assigning a name to a value e.g. (define x (+ 1 2)) validate_form(expressions, 2, 2) # Checks that expressions is a list of length exactly 2 env.define(signature, scheme_eval(expressions.rest.first, env)) return signature Problem 5 此题向我们描述了quote的用法，在此不做过多赘述，详情可看题目要求。在此仅讲讲需要实现的功能。\n给出一段expressions，需要我们原封不动的返回，但对于Pair来说，不返回nil，由此可见，需要返回的是expressions.first。\n1 2 validate_form(expressions, 1, 1) return expressions.first Congratulation! 第一部分已完成\nProblem 6 此题我们需要完成Scheme中的一个特殊形式begin。\nbegin 用于按顺序组合多个表达式，并返回最后一个表达式的值。例如，\n1 2 3 4 (begin (display \u0026#34;Hello\u0026#34;) ; 执行第一个表达式（输出 \u0026#34;Hello\u0026#34;） (display \u0026#34;World\u0026#34;) ; 执行第二个表达式（输出 \u0026#34;World\u0026#34;） (+ 1 2)) ; 返回最后一个表达式的值 3 那由此我们可以观察到，它会将所有表达式都执行一遍，但只返回最后一个表达式的值，是不是有点像我们说的递归的概念，不断的完成一个动作，直到最后一个动作再返回。由此我们就可以写出代码。\n首先有一个 base case 若此表达式为空，返回None。 开始递归。首先我们想一想，想要evaluate一个表达式，应该怎么做？答：用上文完成的scheme_eval函数。 如何判断是否到达了递归终点？对于一个expressions来说，它就像一个链表，最后一项的rest总是nil，这就到达了递归终点，也就是我们说的base case。 对于recrusion case 来说，我们要不断的调用自身，直到到达base case。 1 2 3 4 5 6 7 8 if expressions is nil: return None exp = scheme_eval(expressions.first, env) if expressions.rest is nil: return exp else: return eval_all(expressions.rest, env) Problem 7 此题依旧需要我们完成Scheme中的一个特殊形式lambda。\nlambda 用于定义匿名函数，此题要求我们逐步计算表达式，并返回最后一个表达式的值。\n其中，LambdaProcedure这个类存在一个实例body，存放的是scheme list，而实例formals存放的是正确的Pair嵌套表达式。\n我们需要做的是创建并返回一个LambdaProcedure实例，那整体思路就很明朗的，再加上此函数还有给我们的提示，使用特定的语法知识，易得。\n1 2 body = expressions.rest return LambdaProcedure(formals, body, env) Problem 8 此题需要我们创建一个新的Frame，其中含有两个参数，formals vals，均为scheme list，需要我们将每一个formal对应到val，且formals于vals的数量都是相等的，一一对应，直到达到scheme list的终点即可。值得注意的是，不是简单的复制父Frame里的内容，笔者在这里第一次就想错了，总的来说，题目已经告诉我们具体做法，在此不做过多赘述。\n1 2 3 4 5 6 child_frame = Frame(self) while formals is not nil: child_frame.define(formals.first, vals.first) formals = formals.rest vals = vals.rest return child_frame Problem 9 此题需要我们完成scheme_apply里的一个LambdaProcedure case，题目已经给出提示，即\n创建一个新Frame，注意到，要想创建一个新的Frame，就应该想到用谁来创建，不能是Procedure本身，因为make_child_frame是在Frame类中实现的，所以应该找到一个Frame，即Procedrure.env 将形参绑定到参数值，想一想，对于一个Procedure来说，存在两个实例，即formals和body，而formals对应的就是make_child_frame中的formals，而body对应的就是eval_all中的expressions。 在当前Frame进行计算，也就是说此时的env应该变成我们创建的新Frame 综上易得，\n1 2 child_frame = procedure.env.make_child_frame(procedure.formals, args) return eval_all(procedure.body, child_frame) Problem 10 此题需要我们完成define的一种新类型，题目已经给了详尽的步骤，在这里讲几个笔者踩到的坑。\n想清楚symbol formals body分别代表什么，首先想明白，signature与expression之间的关系，signature代表的是expression的第一个内容，也就是函数名，而其中symbol也叫函数，也就是signature.first，之后再想想formals，就是除了define和函数名剩下的内容，而body则代表的是除了define之外的所有内容，想清楚这五个之间的关系，对于这道题十分关键。 题目告诉我们可以使用do_lambda_form，但笔者试了很多次也没有找到方法，若有人有更好的意见欢迎与我联系。 在找到正确的formals后还需要使用validate_formals()函数来判断其正确性。 综上可知，\n1 2 3 4 5 6 symbol = signature.first formals = signature.rest validate_formals(formals) body = expressions.rest env.define(symbol, LambdaProcedure(formals, body, env)) return symbol Problem 11 这道题看着题目很长很难，但其实是纸老虎，根据它的题意来即可。\n看看MuProcedure可以发现需要两个参数，formals和body，formals题目已经给出，指的是expressions的第一个内容，而body就是除了第一个内容的其他内容。 完成scheme_apply的mu case，这个内容跟上文的lambda case如出一辙，有区别的是，Frame的区别，因为mu是动态的，所以它的Frame一直在变，就不需要再用Procedure的Frame了。 综上可知，\n1 return MuProcedure(formals, expressions.rest) 1 2 child_frame = env.make_child_frame(procedure.formals, args) return eval_all(procedure.body, child_frame) Part 2 已完成！\nProblem 12 这道题需要我们完成两个函数do_and_form和do_or_form，这两个函数从形式上来说都很相似，所以放在一起做，读题目可知，expressions会给出不定量个内容，我们需要判断每个内容的正确性来判断应返回什么，值得注意的是，对于and和or来说，存在一个关键的地方短路，每当遇到一个合适的内容时，就会舍弃后面的所有内容，仅返回当前内容。\n因此，对于此题来说，递归是个很好的办法，具体步骤如下。\nbase case 1 若expression为空，则返回特定值。 base case 2 每当我们判断出来的当前内容的正确性，则直接返回。 base case 3 当所有内容都判断完毕后还没有找到正确性，则返回最后一个内容。 recrusion case 不断对下一个内容执行当前函数。 代码如下，\n1 2 3 4 5 6 7 8 9 10 11 12 def do_and_form(expressions, env): if expressions is nil: return True currency = scheme_eval(expressions.first, env) if is_scheme_true(currency): if expressions.rest is nil: return currency else: return do_and_form(expressions.rest, env) else: return currency 1 2 3 4 5 6 7 8 9 10 11 12 def do_or_form(expressions, env): if expressions is nil: return False currency = scheme_eval(expressions.first, env) if is_scheme_false(currency): if expressions.rest is nil: return currency else: return do_or_form(expressions.rest, env) else: return currency Problem 13 此题需要我们完成cond，题目也给了我们描述。返回第一个表达式为true的值，若都不是正确的，那么就返回else表达式也就是最后一个表达式的值，这也是一个递归步骤，因此可知步骤为，\nbase case 判断到最后一个表达式，若还没有判断出来，则返回此表达式的值。 recrusion case 从第一个表达式开始逐步判断。 1 2 3 4 if clause.rest is nil: return test else: return eval_all(clause.rest, env) Problem 14 这道题确实没看懂什么意思，在此也不误人子弟了。\n点这里看总的代码实现\n写在后面 后续的题目就不再做了，是关于Scheme的。\n作为UCB的CS61系列的第一门课，在当时还是初学者的我留下了很深的心理阴影，Scheme这个项目也一直停着没有做，这次重新捡回来，也算是给自己的一个交代。\n至此，CS61A结束。\nYuTaki\n2025年3月7日写于博学楼\n","date":"2025-03-07T00:00:00Z","image":"https://YuTaki23.github.io/p/cs61a-sp24-scheme/image1_hu_7934f1e6f9243d37.png","permalink":"https://YuTaki23.github.io/p/cs61a-sp24-scheme/","title":"CS61A SP24 Scheme"}]