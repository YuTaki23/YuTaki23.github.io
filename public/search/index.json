[{"content":"写在前面 本文取自 Stanford CS144 Winter2025 minnow Check0，笔者为计算机网络初学者，如有错误表述或不恰当的地方，请指正！\n欢迎与我联系\n1 Set up GNU/Linux on your computer 题目给了我们五个选项来作为本实验的环境，笔者在这里选择了第 3 条，使用虚拟机下载 Ubuntu 24.04 进行学习。\n值得注意的是，对于 Winter 2025 这个版本，似乎必须要是有 Ubuntu 24.04，但截至目前（2025.5.14）依然还有很多人在使用 Ubuntu 22.04 进行开发，在此，笔者只是提个醒，使用低版本的操作系统无法下载这些包，无法进行开发。\n2 Networking by hand 本题需要我们完成两项任务，检索网页和发送电子邮件（没有斯坦福账号，不做解释），这两项任务引出了一个概念\n可靠双向字节流：在自己的终端上输入一串字符，这串字符最终会以相同的顺序传递给服务器。\n2.1 Fetch a Web page 跟着题目要求一步一步在终端上输入即可，唯一值得注意的是，输入的速度要快一点，慢了会失败。\n3 Writing a network program using an OS stream Socket 接下来需要编写一些程序来实现可靠双向字节流这一操作。这种功能被称为流式套接字，就像是一个 IO 输入输出流一样，当两个流式套接字连接时，写入其中一个套接字的字节最终会以相同顺序从另一台计算机的套接字中读出。\n本实验只需要实现 webget，创建 TCP 流套接字，连接到 Web 服务器并获取页面，也就是我们在 2.1 节中所做的任务。\n3.1 Let’s get started—setting up the repository on your VM and On GitHub 从 GitHub 上 clone repo 即可，按自己的方法来，不赘述。\n3.2 Compiling the starter code 跟着教程一步步编译即可。遇到的问题是，笔者最开始使用 WSL2 的时候，编译无法通过，换成 VMware 才能通过。\n3.3 Modern C++: mostly safe but still fast and low-level 在本项目中，向我们规定了哪些语法应该使用，哪些不该使用。\n运用了许多现代 C++的语法。\n3.4 Reading the Minnow support code 题目要求我们看一下一些提到的公共接口\nsocket.hh\nSocket 继承于 FileDescriptor bind(address) 将 Socket 绑定到指定的网络地址，常用于服务器监听 bind_to_device(device_name) 将 Socket 绑定到指定网络接口设备 connect(address) 建立指定对端地址的 TCP 连接 shutdown(how) 关闭 local_address() 获取 Socket 绑定的本地地址信息 peer_address() 获取已连接 Socket 的对端地址信息 set_reuseaddr() 允许地址重用 throw_if_error() 检查 Socket 错误状态，用于非阻塞 Socket 的场景，发现错误时抛出异常 DatagramSocket 继承于 Socket recv(source_address, payload) 接受数据报 sendto(destination, payload) 发送数据报到指定位置 send(payload) 发送到已连接的地址，需要先 connect UDPSocket 继承于 DatagramSocket UDPSocket() 默认构造函数 TCPSocket 继承于 Socket TCPSocket() 默认构造函数 listen(int backlog = 16) 启动监听 accept() 接受新连接并返回新 TCPSocket PacketSocket 继承于 DatagramSocket PacketSocket(int type, int protocol) 默认构造函数 set_promiscuous() 设置混杂模式 LocalStreamSocket 继承于 Socket LocalStreamSocket(FileDescriptor\u0026amp;\u0026amp; fd) 从 fd 构造函数 LocalDatagramSocket 继承于 DatagramSocket LocalDatagramSocket() 默认构造未绑定的构造函数 file_descriptor.hh\nFDWrapper() 构造函数 ~FDWrapper() 析构函数 read() 从文件描述读取数据到缓冲区（单缓冲区（字符串） 多缓冲区（数组）） write() 尝试写入数据并返回写入的字节数（字符串视图或数组） close() 关闭底层文件描述符 duplicate() 显式复制文件描述符，增加引用计数 set_blocking() 设置文件描述为阻塞或非阻塞模式 size_t() 返回文件大小 fd_num() 获取底层文件描述符编号 eof() 检查是否到达文件末尾 closed() 检查描述符是否已关闭 read_count() / write_count() 获取读写操作次数统计 3.5 Writing webget 本题要求我们完成一个类似于上文 2.1 节提起的从互联网中获取网页的内容，我认为比较重要的点有以下几点\n这整个过程是一个双向可靠的，也就是说我主机端向服务端发送了什么内容，那么服务端就会以相同的顺序获取这些内容。 题目告诉我们要使用之前 Http 的格式，一定要看清楚哪里有空格，哪里没有空格 明白这两点，那么大致就会有个思路，接下来就靠自己努力， 一些容易踩坑的点，题目中也给我们标明了，注意即可，\n代码如下，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void get_URL( const string\u0026amp; host, const string\u0026amp; path ) { Address address = Address(host, \u0026#34;http\u0026#34;); TCPSocket socket; socket.connect(address); socket.write( \u0026#34;GET \u0026#34; + path + \u0026#34; HTTP/1.1\\r\\n\u0026#34; + \u0026#34;Host: \u0026#34; + host + \u0026#34;\\r\\n\u0026#34; + \u0026#34;Connection: close\\r\\n\\r\\n\u0026#34;); while (!socket.eof()) { string output; socket.read(output); cout \u0026lt;\u0026lt; output; } } 4 An in-memory reliable byte stream 注：本流程已笔者做题时的正常思路为主，可能在后面会有其他补充，请看到最后~\n本题需要完成一个可靠的字节流，其中我认为比较重要的点有以下\n字节首先被写入输入端，以相同顺序写出到输出端 字节流是有限的 4.1 push(string data) 将外部数据写入字节流的缓冲区，但不可以超过容量。\n首先来看看容量是什么，在 ByteStream 初始化时，会给定一个 capacity，这是这个字节流的容量，但容量只由这一个来决定吗？不是，我们推送数据的时候，会创建一个适当的数据结构来表示缓冲区，在最开始，什么都没有，缓冲区内什么也没有，当然可以以总容量的大小来推送，但下一次就不一定了，若当前缓冲区存在一些字节，那我们此时的容量就会变成 总容量-缓冲区大小。\n其次，用户在传递数据的时候，如果比一开始设置的容量就要大、亦或者是比我们 总容量-缓冲区大小 的容量还要大，应该怎么办？此时应该选择这两者之间最小的一个，也就是 min(数据大小,此时容量大小)。\n想到这，就会有一个大概的思路，首先要选择一个合适的数据结构，因为传递的是 string，我在这里也选择 string 作为缓冲区的数据结构。\n判断当前可以使用的容量 判断数据大小和容量哪个更小 添加到缓冲区 因此，我们可以写出代码 1 2 3 //byte_stream.hh protected: std::string buffer_; 1 2 3 4 5 6 7 // byte_stream.cc void Writer::push( string data ) { uint64_t available_bytes = capacity_ - buffer_.size(); uint64_t write_len = std::min(available_bytes, data.size()); buffer_.append(data.substr(0, write_len)); } 4.2 close() \u0026amp; is_closed() 标记流已经结束，不再写入。\n要完成此函数，可以添加一个布尔标记，判断此时是否已经结束\n1 2 3 // byte_stream.hh protected: bool is_closed_; 1 2 3 4 5 6 7 8 9 // byte_stream.cc void Writer::close() { is_closed_ = true; } bool Writer::is_closed() const { return is_closed_; } 4.3 available_capacity () 当前可推送的字节数\n很明显，这就是我们在 4.1 节中想过的当前可以使用的容量大小，\n1 2 3 4 uint64_t Writer::available_capacity() const { return capacity_ - buffer_.size(); } 4.4 bytes_pushed () 返回目前累计推送到字节流的总字节数\n我们可以维护一个字节数的变量，每推送了一定值的字节后，就往这个变量上加一定值。所以，我们需要在上文 4.1 节中的 push 函数加上一行，来表示我们已推送的总字节数。并且，还可以将 4.3 节抽象到此处。\n1 2 3 // byte_stream.hh protected: uint64_t bytes_pushed_; 1 2 3 4 5 6 7 8 9 10 11 12 // byte_stream.cc void Writer::push( string data ) { uint64_t available_bytes = available_capacity(); uint64_t write_len = std::min(available_bytes, data.size()); buffer_.append(data.substr(0, write_len)); bytes_pushed_ += write_len; } uint64_t Writer::bytes_pushed() const { return bytes_pushed_; } 4.5 peek() 本题需要查看缓冲区的可读取的数据，但不移除任何数据。\n可读取的数据就是还在缓冲区内存放的数据，也就是 size\n1 2 3 4 string_view Reader::peek() const { return {buffer_.data(), buffer_.size()}; } 4.6 pop(uint64_t len) 本题需要从缓冲区中移除指定长度的数据，这些数据表示为已经被读取过的。\n我们要先判断一下要移除的这些数据，与我当前缓冲区内的数据大小哪个大，如果移除的数据比我本身的都大，那就有错误了。其次，我们要移除的是已经被读取过的，所以最开始的一定是在第一位，因为先读取的会一步步排到最前面。\n1 2 3 4 5 void Reader::pop( uint64_t len ) { len = std::min(len, buffer_.size()); buffer_.erase(0, len); } 4.7 is_finished() 判断此时数据流是否已经结束，结束的标志有\n已经关闭 缓冲区内已无任何数据 1 2 3 4 bool Reader::is_finished() const { return is_closed_ \u0026amp;\u0026amp; buffer_.empty(); } 4.8 bytes_buffered() 给出当前缓冲区内的数据大小\n1 2 3 4 uint64_t Reader::bytes_buffered() const { return buffer_.size(); } 4.9 bytes_popped() 给出截至目前为止有多少数据被移除了。\n我们依然可以维护一个变量，每移除一定量的数据后就往这个变量上添加。所以，要在上文 pop() 函数再添加一些内容。\n1 2 protected: uint64_t bytes_popped_; 1 2 3 4 5 6 7 8 9 10 11 // byte_stream.cc void Reader::pop( uint64_t len ) { len = std::min(len, buffer_.size()); buffer_.erase(0, len); bytes_popped_ += len; } uint64_t Reader::bytes_popped() const { return bytes_popped_; } 4.10 构造函数 我们已经维护了如此多的变量，对于 C++来说，初始化一个对象也有很多讲究，我们在 protected 处给出的变量，因此回到最开始的内容，在构造函数时要按顺序来给出，否则会报错。\n1 2 3 4 5 6 7 8 protected: uint64_t capacity_; bool error_ {}; std::string buffer_; bool is_closed_; uint64_t bytes_pushed_; uint64_t bytes_popped_; }; 1 2 3 4 5 6 ByteStream::ByteStream( uint64_t capacity ) : capacity_( capacity ), buffer_(), is_closed_(false), bytes_pushed_(0), bytes_popped_(0) {} 写在后面 不愧是著名的 CS144，光是第一个 check 就让我如此难受，总耗费时长大概在 12 小时左右，对于网络编程的不了解吃了很大亏。\n","date":"2025-05-15T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs144-winter2025-check0/","title":"CS144 Winter2025 Check0"},{"content":"写在前面 本文取自Stanford CS106L Winter2025 Assignment7: Unique Pointer\n主要内容为运用模板、运算符重载、移动语义和智能指针。\n本任务让我们自己写一个unique_pointer来实现链表的操作，感觉把后半部分的课程都串起来了，对Modern C++有了个更深的了解。\n具体实现 Implementing unique_ptr 本任务需要我们完成自己的unique_ptr，首先回忆一下唯一指针的内容。\n唯一指针只能指向一个内容，无法让其他指针复制其内容，无法通过值传递，当变量超出范围时会调用delete，但在此题中无需担心delete。\nImplementing unique_ptr functionality 此处需要我们完成几个特定的SMF\nprivate 这里需要我们在私有处完成内容，对于一个指针来说，它一定会存在的内容是指向一个内容的指针\n1 2 private: T* ptr; unique_ptr(T* ptr) 此处完成一个构造函数，给出的参数为一个指针，让我们的唯一指针指向这个地方即可\n1 2 3 unique_ptr(T* ptr) { this-\u0026gt;ptr = ptr; } unique_ptr(std::nullptr_t) 此处完成一个指向NULL的构造函数，让唯一指针指向NULL即可\n1 2 3 unique_ptr(std::nullptr_t) { this-\u0026gt;ptr = NULL; } T\u0026amp; operator*() 此处需要重载*操作符，对于一个指针来说，*是解引用，返回的是指针指向的值，不是地址，所以不能使用\u0026amp;取地址符，简单的返回指针即可\n1 2 3 T\u0026amp; operator*() { return *this-\u0026gt;ptr; } const T\u0026amp; operator*() const 1 2 3 const T\u0026amp; operator*() const { return *this-\u0026gt;ptr; } const T* operator-\u0026gt;() const 此处需要返回唯一指针指向的内容\n1 2 3 T* operator-\u0026gt;() { return this-\u0026gt;ptr; } const T* operator-\u0026gt;() const 1 2 3 const T* operator-\u0026gt;() const { return this-\u0026gt;ptr; } operator bool() const 注释告诉我们若唯一指针为非NULL则返回true，反之相反\n1 2 3 operator bool() const { return this-\u0026gt;ptr != NULL; } Implementing RAII 此任务要求我们实现一些列SMF，以防止唯一指针不指向唯一的内容，同时保证不会进行复制等耗费内存的操作\n~unique_ptr() 析构函数，释放指针的内存，简单删除即可\n1 2 3 ~unique_ptr() { delete ptr; } unique_ptr(const unique_ptr\u0026amp; other) 因为这是唯一指针，所以不能被其他指针复制，在此应该删除\n1 unique_ptr(const unique_ptr\u0026amp; other) = delete; unique_ptr\u0026amp; operator=(const unique_ptr\u0026amp; other) 应删除，理由同上\n1 unique_ptr\u0026amp; operator=(const unique_ptr\u0026amp; other) = delete; unique_ptr(unique_ptr\u0026amp;\u0026amp; other) 此处需要我们将other的指针移动到本指针上，同时因为这是唯一指针，不能存在两个指向相同地方的指针，给other的指针应指向NULL\n1 2 3 4 unique_ptr(unique_ptr\u0026amp;\u0026amp; other) { this-\u0026gt;ptr = other.ptr; other.ptr = NULL; } unique_ptr\u0026amp; operator=(unique_ptr\u0026amp;\u0026amp; other) 对=操作符重载，也就是将this赋值给other\n1 2 3 4 5 6 7 8 unique_ptr\u0026amp; operator=(unique_ptr\u0026amp;\u0026amp; other) { if (this != \u0026amp;other) { delete this-\u0026gt;ptr; this-\u0026gt;ptr = other.ptr; other.ptr = NULL; } return *this; } Using unique_ptr 此部分需要我们使用刚才创建的唯一指针实现链表的操作，底层内容可以看一下README，在此不赘述\n整体实现的算法题目也已经告诉我们了，一步一步跟着来即可，\n值得注意的是，重新赋值时不能简单使用=来操作，而应该使用移动语义，\n取vector的内容时，不能简单使用[]来操作，而应该使用唯一指针的操作\n1 2 3 4 5 6 7 8 9 template \u0026lt;typename T\u0026gt; cs106l::unique_ptr\u0026lt;ListNode\u0026lt;T\u0026gt;\u0026gt; create_list(const std::vector\u0026lt;T\u0026gt;\u0026amp; values) { cs106l::unique_ptr\u0026lt;ListNode\u0026lt;T\u0026gt;\u0026gt; head = nullptr; for (int i = values.size() - 1; i \u0026gt;= 0; --i) { cs106l::unique_ptr\u0026lt;ListNode\u0026lt;T\u0026gt;\u0026gt; node = cs106l::make_unique\u0026lt;ListNode\u0026lt;T\u0026gt;\u0026gt; (values[i]); node-\u0026gt;next = std::move(head); head = std::move(node); } return head; } GitHub地址\n写在后面 CS106L到此结束，简单了解了C++的特性，为下一门课CS144做准备。\n这是笔者第一个把所有内容都写下来的一门课，虽一笔一划写下，但仍有许多不精之处，若您有更好的建议，请提出。\n谢谢！\nYuTaki 2025年4月19日，博学楼\n","date":"2025-04-19T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment7-unique-pointer/","title":"CS106L Winter2025 Assignment7 Unique Pointer"},{"content":"写在前面 本文取自Stanford CS106L Assignment6: Explore Courses\n本作业主要让我们使用std::optional这个模板来完善寻找Course这个方法，主要训练了我们对此模板的理解，总的来说，题目把大部分的提示都给我们了\n具体思路 Include \u0026lt;optional\u0026gt; 简单包含头文件即可\n1 #include \u0026lt;optional\u0026gt; Write the find_course function 此函数需要我们接受一个String类型的course_title，并返回courses中与其同名的course，整个函数逻辑很简单，简单的for循环遍历即可。\n但难点在于还需要更改函数类型，关于这个可以先往下看，对于整个文件来说我们都是在基于optional上操作的，在之后还需要运用此函数返回的对象来进行操作，而在后文提到，这个对象首先得有optional的接口，故可以发现应将其写成以optional为基础的类型\n题目还告诉我们，有可能没有相符的course，也就是没有遍历到合适的course，而在optional中，表示未发现的对象应使用null_opt\n1 2 3 4 5 6 7 8 9 std::optional\u0026lt;Course\u0026gt; find_course(std::string course_title) { for (const auto\u0026amp; course : courses) { if (course.title == course_title) { return course; } } return std::nullopt; } Modifying the main function 题目首先告诉我们要调用上文的函数，上文已经解释过，在此不赘述\n题目告诉我们要将下列行为以monadic操作符进行重写，且不使用任何条件函数\n1 2 3 4 5 6 if (course.has_value()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found course: \u0026#34; \u0026lt;\u0026lt; course-\u0026gt;title \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; course-\u0026gt;number_of_units \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; course-\u0026gt;quarter \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Course not found.\\n\u0026#34;; } 此函数要表达的意思很简单，若存在一个值打印一些内容，反之打印另一些内容\n下面给了我们三个函数，在此笔者简单解释一下\nand_then() 若当前optional有值，则调用括号内的函数返回新的optional，否则返回空\ntransform() 若当前optioanl有值，则调用括号内的函数并将结果包装成optional，否则返回空\nor_else() 若当前optional有值，则返回它，否则调用函数生成新的optional\n如果vscode一直报错说找不到函数，在vscode的设置文件把c++标准改成23即可\n再看一下题目给我们的示例，要在函数内容调用一个lambda函数，\n对于存在值的情况，使用transform()，不存在的情况使用or_else()\n1 2 3 4 std::string output = course .transform([](Course course) { return \u0026#34;Found course: \u0026#34; + course.title + \u0026#34;,\u0026#34; + course.number_of_units + \u0026#34;,\u0026#34; + course.quarter + \u0026#34;\\n\u0026#34;;}) .or_else([]() { return std::optional\u0026lt;std::string\u0026gt;(\u0026#34;Course not found.\\n\u0026#34;);}) .value(); GitHub地址\n","date":"2025-04-18T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment6-explore-courses/","title":"CS106L Winter2025 Assignment6 Explore Courses"},{"content":"写在前面 本文取自Stanford CS106L Winter2025 Assignment5: Treebook 本作业主要需要我们在其他人完成了一个类的情况下，将此类变得更加适用、更加好用，主要包括运算符重载、special member function等方面，总的来说不算难（比上次的好多了）\n具体思路 Viewing Profiles 目前，我们拥有一个User类，其中值得注意的是_friends这个field，它简单来说是一个vector，但更底层，是使用指针来实现的。 此题需要我们重载\u0026lt;\u0026lt;这个操作符，使得其打印时更符合我们人类的直觉 关于如何重载此操作符，如果没有思路，可以先看看这篇文章为自己的类重载 \u0026lt;\u0026lt; 运算符 User(name=Alice, friends=[Bob, Charlie])，可以看出，除了简单的必须存在的字符串以外，我们还需要打印自己的name，friends的name， 自己的name很简单，类中已经给出方法get_name() friends的name，就需要思考了，首先friends在private里，这意味着我们不能简单访问它们，而是使用friend function，其次还应明白如何访问一个指针元素，最后还要注意当我们到最后一个friend时，要改变打印的内容，因此可以写出代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const User\u0026amp; us) { os \u0026lt;\u0026lt; \u0026#34;User(name=\u0026#34; \u0026lt;\u0026lt; us.get_name() \u0026lt;\u0026lt; \u0026#34;, friends=[\u0026#34;; for (size_t i = 0; i \u0026lt; us.size(); ++i) { if (i == us.size() - 1) { os \u0026lt;\u0026lt; us._friends[i]; } else { os \u0026lt;\u0026lt; us._friends[i] \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; } } os \u0026lt;\u0026lt; \u0026#34;])\u0026#34;; return os; } Unfriendly Behaviour 此题需要我们实现Special Member Functions，具体为\nDestructor 一般来说析构函数是不需要自己显式声明的，但若遇见了与内存相关的内容，就需要我们显式声明了，在此处，_friends就使用了内存，在全部完成后，需要释放内存 1 ~User(); 1 2 3 User::~User() { delete[] _friends; } Copy Constructor 复制一个已存在的对象，将其声明为新的对象，值得注意的是，需要手动分配内存以保证_friends的正确性，在此处，笔者使用的是教授教的C++11的新方法， 1 User(const User\u0026amp; user); 1 2 3 4 5 6 7 8 9 User::User(const User\u0026amp; user): _name(user._name), _size(user._size), _capacity(user._capacity), _friends(new std::string[user._capacity]) { for (size_t i = 0; i \u0026lt; user._size; ++i) { _friends[i] = user._friends[i]; } } Copy Assignment 以上课时的内容为基准，举一反三既可 1 User\u0026amp; operator=(const User\u0026amp; user); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 User\u0026amp; User::operator=(const User\u0026amp; user) { if (this == \u0026amp;user) { return *this; } delete[] _friends; _name = user._name; _size = user._size; _capacity = user._capacity; _friends = new std::string[user._capacity]; for (size_t i = 0; i \u0026lt; user._size; i++) { _friends[i] = user._friends[i]; } return *this; } Move Constructor \u0026amp; Move Assignment 此处要用到的内容为移动语义的知识，为了防止被移动，我们要显示删除这两个SMF，简单声明即可 1 2 User(User\u0026amp;\u0026amp; user) = delete; User\u0026amp; operator=(User\u0026amp;\u0026amp; user) = delete; Always Be Friending 此处需要我们重载两个操作符，以使得其更符合此类的操作\noperator+= 将一个用户添加到另一个用户上以成为其朋友，值得注意的是，这是相互的，一个人对另一个人敞开心扉后，另一个人也应如此。 最后还应按照题目要求返回*this 1 User\u0026amp; operator+=(User\u0026amp; rhs); 1 2 3 4 5 User\u0026amp; User::operator+=(User\u0026amp; rhs) { this-\u0026gt;add_friend(rhs.get_name()); rhs.add_friend(this-\u0026gt;get_name()); return *this; } operator\u0026lt; 简单判断第一个字符的先后即可 1 bool operator\u0026lt;(const User\u0026amp; rhs) const; 1 2 3 bool User::operator\u0026lt;(const User\u0026amp; rhs) const { return this-\u0026gt;get_name()[0] \u0026lt; rhs.get_name()[0]; } GitHub地址\n","date":"2025-04-17T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment5-treebook/","title":"CS106L Winter2025 Assignment5 Treebook"},{"content":"写在前面 本文取自Stanford CS106L Winter2025 Assignment4: Ispell 本任务主要要求我们实现一个拼写检查程序，即若我们给出的单词有误会给出较为合理的建议。主要用到的知识有容器、Lambda函数等内容。\n具体思路 题目大意 将所有常见的英语单词字典添加到内存中，若在字典中找不到该单词则认为拼写错误 若可以通过添加、删除、替换、交换等操作且此操作只需要进行一次的，则将其添加到建议列表中 不能使用for/while循环 tokenize 题目大意 此方法最终会实现一个将String分割成一系列Token，对于一个Token来说其作为一个结构体，包括struct Token { std::string content; size_t src_offset; }; 假设现有一字符串history will absolve me，我们可以将其以空格为边界分成四个Token\n{ content: \u0026quot;history\u0026quot;, src_offset: 0 } { content: \u0026quot;will\u0026quot;, src_offset: 8 } { content: \u0026quot;absolve\u0026quot;, src_offset: 13 } { content: \u0026quot;me\u0026quot;, src_offset: 21 } 可以看出，content会以第一个字母为起点，空格为终点存储一个单词，sec_offset为此第一个字母在整个字符串中的索引，其中需要包括空格。 代码实现 Identify all iterators to space characters 此任务需要我们找出所有空白字符并将其作为迭代器保存到vector中，题目给了我们函数find_all(Iterator begin, Iterator end, UnaryPred pred)，它可以返回此迭代器中所有符合pred条件的所有迭代器并将其保存在vector中，那么我们就需要用参数source来作为迭代器，String类提供了作为迭代器的接口，begin end，条件题目也给了我们判断此字符是否为空格的函数isspace，可以写出代码，\n1 auto space = find_all(source.begin(), source.end(), isspace); Generate tokens between consecutive space characters 目前，我们已经拥有了所有空字符的迭代器，现在需要我们将两个空字符迭代器之间的内容保存为一个Token，Token的迭代器会自动处理两边的空白，只需要提供起始迭代器与终止迭代器即可，此时就可以找到一个Token，但其中不止存在一个Token，所以我们还需要遍历整个字符串，但题目要求不能使用for/while循环，所以使用另一个函数 std::transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOp binary_op) 此函数参数可以分为三个部分\nfirst1 last1 first2，对于此输入范围，函数要求给定两个相等的输入范围，一个从first1开始到last1结束，另一个从first2开始 d_first 将结果存储到d_first中，大小与上文输入范围相同 binary_op 应用于两个部分 对于binary_op应创建一个lambda函数，其中参数为两个迭代器，和字符串，以创建Token，其中source应按引用传递， 对于d_first应先创建一个集合以存储我们创建的Token，再使用std::inserter函数以保存创建的Token 对于输入范围，应选择两个连续的迭代器，以遍历所有迭代器 1 2 3 4 5 6 7 std::set\u0026lt;Token\u0026gt; tokens; std::transform(space.begin(), space.end() - 1, space.begin() + 1, std::inserter(tokens, tokens.end()), [\u0026amp;source] (auto it1, auto it2) { return Token { source, it1, it2}; } ); Get rid of empty tokens 此时我们所创建的Token可能有一些Token是含有空白字符的，我们要将其删掉， std::erase_if(std::set\u0026lt;Key, Compare, Alloc\u0026gt;\u0026amp; c, Pred pred) 对于c，传递我们上文给的集合tokens即可 对于pred，创建一个lambda函数，以判断token是否为空\n1 2 3 4 5 std::erase_if(tokens, [] (Token token) { return token.content.empty(); } ); spellcheck 题目大意 该方法接受tokenize所得到的token来进一步给出建议，并返回一个Mispelling，其中包括一个错误的Token，和一系列建议的单词 大致过程为\n跳过正确拼写的单词 查找距离正确单词仅“一步之遥”的单词 删除没有建议的错误拼写单词 代码实现 Skip words that are already correctly spelled. 若一个单词已经存在在了dictionary中了，我们就认为它是正确的，思路很简单，在此处需要学习的是std::ranges::views::filter，在此笔者使用题目给的较为简洁的方法，即使用namespace来简洁化\n1 2 namespace rv = std::ranges::views; auto view = source | rv::filter(/* A lambda function predicate */); 我们的任务只需要填写这个lambda函数，此函数参数为Token，lambda参数为dictionary，此处的dictionary应按引用传递，来判断此Token是否在dictionary中\n1 2 3 auto view = source | rv::filter([\u0026amp;dictionary] (Token token) { return !dictionary.contains(token.content); }); Find one-edit-away words in the dictionary using Damerau-Levenshtein 根据题目提示，此时我们应该与上题相结合\n1 2 3 4 namespace rv = std::ranges::views; auto view = source | rv::filter(/* A lambda function predicate */) | rv::transform(/* A lambda function taking a Token -\u0026gt; Mispelling */); 此lambda函数应接受一个Token，返回距离为一的所有单词，求距离是否为一，使用题目给的函数levenshtein来判断即可 最后需要返回一个Mispelling对象\n1 2 3 4 5 6 7 | rv::transform([dictionary] (Token token) -\u0026gt; Mispelling { auto view = dictionary | rv::filter([token] (std::string str) { return levenshtein(token.content, str) == 1; }); std::set\u0026lt;std::string\u0026gt; suggestions(view.begin(), view.end()); return Mispelling { token, suggestions }; }); Drop misspellings with no suggestions. 在此我们需要找到没有办法进行任何修改使其变为正常单词的单词了，故此处还需要使用filter来判断是否符合此情况，过滤完成后返回最新的Mispelling\n1 2 3 | rv::filter([] (Mispelling miss) {return !miss.suggestions.empty();}); return std::set\u0026lt;Mispelling\u0026gt; (view.begin(), view.end()); }; GitHub地址\n","date":"2025-04-16T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment4-ispell/","title":"CS106L Winter2025 Assignment4 Ispell"},{"content":"遇到的问题 最后的编译过不去，不知道为什么卡在 Installing CastXML就不动了 ：（\n具体思路 自由发挥创造一个类，没什么好解释的，创造性很强，我没有更好的想法，就用了上课用的StanfordID类来做 class.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;string\u0026gt; #include \u0026lt;sstream\u0026gt; class StanfordID { private: std::string name; std::string sunet; int idNumber; std::string getInitialName(std::string name); public: StanfordID(std::string name, std::string sunet, int idNumber); StanfordID(); const std::string getName(); const std::string getSunet(); const int getIdNumber(); void setName(std::string name); }; class.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026#34;class.h\u0026#34; #include \u0026lt;string\u0026gt; StanfordID::StanfordID(std::string name, std::string sunet, int idNumber) { this-\u0026gt;name = name; this-\u0026gt;sunet = sunet; if (this-\u0026gt;idNumber \u0026gt; 0) { this-\u0026gt;idNumber = idNumber; } } std::string StanfordID::getInitialName(std::string name) { std::stringstream ss; ss \u0026lt;\u0026lt; name; std::string first; std::string last; ss \u0026gt;\u0026gt; first \u0026gt;\u0026gt; last; std::string res; res += first[0]; res += last[0]; return res; } StanfordID::StanfordID() { this-\u0026gt;name = \u0026#34;YuTaki X\u0026#34;; this-\u0026gt;sunet = \u0026#34;172@60\u0026#34;; this-\u0026gt;idNumber = 190; } const std::string StanfordID::getName() { return this-\u0026gt;name; } const std::string StanfordID::getSunet() { return this-\u0026gt;sunet; } const int StanfordID::getIdNumber() { return this-\u0026gt;idNumber; } void StanfordID::setName(std::string name) { this-\u0026gt;name = name; } sandbox.cpp\n1 2 3 4 #include \u0026#34;class.h\u0026#34; void sandbox() { StanfordID id(\u0026#34;Yammy Xi\u0026#34;, \u0026#34;183@80\u0026#34;, 187); } ","date":"2025-04-11T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment3-make-a-class/","title":"CS106L Winter2025 Assignment3 Make a Class"},{"content":"写在前面 本作业取自Stanford CS106L Winter 2025 第2个Assignment。主要考察对读取文件内容、容器等内容的考察，总体难度不大，但是有几个坑，笔者会在下方标注坑处，如果你的测试过不去，大概率就是这里出了问题。\n具体思路 kYourName 将上方的名字改成自己的\n1 std::string kYourName = \u0026#34;YuTaki X\u0026#34;; get_applicants 本题需要从一个.txt文件中读取其中内容，并将其中内容放到一个set里，具体思路即为\n打开文件 读取每行的内容 将此内容放到set中 直到没有内容可读取 可以写出 1 2 3 4 5 6 7 8 9 10 11 12 13 std::set\u0026lt;std::string\u0026gt; get_applicants(std::string filename) { std::set\u0026lt;std::string\u0026gt; students; std::ifstream inputFile; inputFile.open(filename); if (inputFile.is_open()) { std::string line; while (std::getline(inputFile, line)) { students.insert(line); } } inputFile.close(); return students; } find_matches 本体需要让我们找出与name有相同initials名字的人，并将其指针加入到一个queue中\n坑点1 什么是initials？ 比如你的名字是Zhang San，那么initials就是ZS\n具体思路为\n写一个辅助函数，用于得到每个名字的initials 迭代查询set里的每个元素，若有与之相同的，则将其指针加入queue中 你需要知道的内容有 如何获取一个字符串中每个单词的第一个字母 坑点2 在用stringstream时，要在前面include \u0026lt;sstream\u0026gt;\n如何迭代set 如何表示一个指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;sstream\u0026gt; std::string helper(std::string name) { std::stringstream ss; ss \u0026lt;\u0026lt; name; std::string first; std::string last; ss \u0026gt;\u0026gt; first \u0026gt;\u0026gt; last; std::string res; res += first[0]; res += last[0]; return res; } std::queue\u0026lt;const std::string*\u0026gt; find_matches(std::string name, std::set\u0026lt;std::string\u0026gt;\u0026amp; students) { std::queue\u0026lt;const std::string*\u0026gt; res; for (const auto\u0026amp; student : students) { if (helper(name) == helper(student)) { res.push(\u0026amp;student); } } return res; } get_match 选择你自己喜欢的方法来从queue中再进一步得到一个特殊的名字（我的名字已经够特殊的了，就不再写了，其实是懒）\n1 2 3 4 5 6 7 std::string get_match(std::queue\u0026lt;const std::string*\u0026gt;\u0026amp; matches) { if (!matches.empty()) { return *matches.front(); } else { return \u0026#34;NO MATCHES FOUND.\u0026#34;; } } 写在后面 总体不难，都是些小问题容易恼火 GitHub地址\n","date":"2025-04-09T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment2-marriage-pact/","title":"CS106L Winter2025 Assignment2 Marriage Pact"},{"content":"1. Types and Structs 1.1 什么是C++？ 如何执行C++代码 C++是一个编译性语言，不同于Python的解释性语言，目前大部分C++程序所用的编译器为g++，作为编译性语言，C++拥有以下优缺点 允许生成更有效的机器语言，因为解释器只能看到代码的很小的一部分，但是编译器可以看到所有事物。 编译需要的时间很长。 如何检查C++代码 在执行C++代码时，如果遇到错误，大多数情况会遇到很多十分冗余的日志，这让人很烦躁，为什么？ Types C++是一个静态类型语言，每个变量都有自己的类型，一旦此变量被声明就无法再改变。虽然这不如Python方便，但也有许多好处，更有效、更好理解、更有效地错误检查。当然也会遇见强制转换的时候，(int) 5.3 = 5。C++支持重载操作，对于不同类型的值，只要声明两个函数包括两个不同的类型参数，C++会自己寻找该使用哪个函数。 综上，C++是一个编译性、静态类型的语言。 1.2 Structs 1.2.1 结构体基础知识 当我们想要在一个类型里面表示许多不同的值，此时就需要用到结构体，例如，\n1 2 3 4 5 6 // 构造结构体 struct StanfordID { string name; string sunet; int idNumber; } 在C++中，初始化一个结构体有许多方法\n初始化结构体 使用点表达式 1 2 3 4 StanfordID id; id.name = \u0026#34;Alice\u0026#34;; id.sunet = \u0026#34;jtrb\u0026#34;; id.idNumber = 6504417; List Initialization 使用大括号 1 2 StanfordID jrb = {\u0026#34;Jacob Roberts-Baca\u0026#34;, \u0026#34;jtrb\u0026#34;, 6504417}; StanfordID fi {\u0026#34;Fabio Ibanez\u0026#34;, \u0026#34;fibanez\u0026#34;, 6504418} //此处的“=”可以省略 当我们想要表示两个值作为一个结构体时，STL已经给了我们模板，即std::pair\n1 2 3 4 5 6 7 8 9 10 11 // 结构体 struct Order { std::string item; int quantity; } Order dozen = {\u0026#34;Eggs\u0026#34;, 12}; // std::pair std::pair\u0026lt;std::string, int\u0026gt; dozen {\u0026#34;Eggs\u0026#34;, 12}; std::string item = dozen.first; int quantity = dozen.second; 可以看出，pair用的是first和second来表示两个值的。\n1.2.2 什么是std std C++ Standard Libary\n内置的类型、函数\u0026hellip;\u0026hellip; 需要在文件前写#include才可以使用，本质上就是引用了其他包内的函数等 在使用std时，都会写上std::，但若在文件前写using namespace std就不用再写了 1.3 改善代码的一些方法 1.3.1 using 在遇到一些类型十分复杂的函数时，其往往会存在大量的、不好理解的类型，此时就可以使用using关键字，例如\n1 2 3 4 5 6 7 // 使用 using 前 std::pair\u0026lt;bool, std::pair\u0026lt;double, double\u0026gt;\u0026gt; solveQuadratic(double a, double b, double c); // 使用 using 后 using Zeros = std::pair\u0026lt;double, double\u0026gt;; using Solution = std::pair\u0026lt;bool, Zeros\u0026gt;; Solution solveQuadratic(double a, double b, double c); 1.3.2 auto 场景如上，有时我们自己也搞不清这个变量到底是什么类型，那么此时就可以使用auto关键字，让编译器自己判断这个变量到底是什么类型\n1 2 3 4 5 // 使用 auto 前 std::pair\u0026lt;bool, std::pair\u0026lt;double, double\u0026gt;\u0026gt; result = solveQuadratic(a, b, c); // 使用 auto 后 auto result = solveQuadratic(a, b, c); 这同样也满足静态类型的要求，不会将一个int类型的值赋给String\n2. Initialization \u0026amp; References 2.1 Initialization 在初始化一个值时，C++有许多种方法来实现\n2.1.1 Direct initialization 1 2 int numOne = 12.0; int numTwo(12.0); 在直接初始化中，C++不在乎你的值是否满足类型检查，它只会简单地将其看作你给他赋予的类型\n2.1.2 Uniform initialization(C++11) 对于统一初始化来说，C++在乎你的值满足类型检查，简单说，若你给的值是个浮点数，同时给的类型是int，那么此时编译器变不会编译\n1 2 3 4 int numOne{12}; float numTwo{12.0}; int numThree{12.0} //不会编译 优点\n安全性 不允许发生宅化转换，即类型的精度变小，这避免了很多问题 泛用性 几乎所有类型都可以用这个方法来初始化，例如vector map class 1 2 3 4 5 6 7 8 9 // map std::map\u0026lt;std::string, int\u0026gt; ages{ {\u0026#34;Alice\u0026#34;, 25}, {\u0026#34;Bob\u0026#34;, 30}, {\u0026#34;Charlie\u0026#34;, 35} } // vector std::vector\u0026lt;int\u0026gt; numbers{1, 2, 3, 4, 5}; 2.1.3 Structured Bingding(C++17) 在编译时，想要初始化一些具有固定的大小且此变量是作为一个数据结构存在时就使用结构化绑定 拥有从一个函数的返回值一次性访问多个值的能力 比如，我们现在创建一个函数getClassInfo，它是用tuple这个数据结构来实现的，返回值使用的是统一初始化 1 2 3 4 5 6 std::tuple\u0026lt;std::string, std::string, std::string\u0026gt; getClassInfo() { std::string className = \u0026#34;CS106L\u0026#34;; std::string buildingName = \u0026#34;Thornton 110\u0026#34;; std::string language = \u0026#34;C++\u0026#34;; return {className, buildingName, language}; } 那么现在我就可以把这个函数返回的三个值用结构化绑定的方法来返回了\n1 2 3 int main() { auto [className, buildingName, lanuage] = getClassInfo(); } 不仅如此，我还可以使用get来获取函数的返回值，值得注意的是，在这里需要使用尖括号来寻找第几个元素\n1 2 3 4 5 6 int main() { auto classInfo = getClassInfo(); std::string className = std::get\u0026lt;0\u0026gt;(classInfo); std::string buildingName = std::get\u0026lt;1\u0026gt;(classInfo); std::string language = std::get\u0026lt;2\u0026gt;(classInfo); } 可以在编译时对已知大小的对象上使用 2.2 References 2.2.1 References简单介绍 什么References？将一个已经存在的对象或函数的别名。 如何表示References？使用\u0026amp;。 例如 1 2 int num = 5; int\u0026amp; ref = num; num是一个整数类型变量，值为5；ref是一个整数引用类型变量，值为num，即num的别名。当我们更改ref的值时，也是在更改num的值。即ref是指向num的一个指针，由此我们就可以引出pass by reference\n2.2.2 Pass by reference 当我们在函数中声明参数为引用类型时，即代表此函数使用的是pass by reference，这也就意味着，我们不会在内存中再分配一块内存来复制此变量等执行一系列操作，只会在原内存上操作\n1 2 3 4 5 6 7 8 void squareN(int\u0026amp; n) { n = std::pow(n, 2); } int main() { int num = 2; squareN(num); } 在这里如果我们再去打印num的值，得到的结果就会是4，而不是2\n2.2.3 Pass by value 这意味着我们会在内存中重新分配一块内存，并将原参数复制一份过来，不会在原内存上进行操作，不会影响原内存。\n1 2 3 4 5 6 7 8 void squareN(int n) { n = std::pow(n, 2); } int main() { int num = 2; squareN(num); } 在这里再去打印num的值得到的结果就是2\n2.2.4 按值传递与按引用传递易错点 值得注意的是，当我们在遇见一些很复杂的类型时，会用到之前学到的auto，同时还用了Structred Binding但在进行按引用传递时，编译器不会帮我们寻找 \u0026amp; 我们需要自己加上 \u0026amp; 即\n1 2 3 4 5 6 void shift(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;nums) { for (auto\u0026amp; [num1, num2] : nums) { num1++; num2++; } } 但当我们用普通的点表达式时，就不需要这样，\n1 2 3 4 5 6 void shift(std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;nums) { for (size_t int i = 0; i \u0026lt; nums.size(); i++) { nums[i].first++; nums[i].second++; } } 2.3 L-values vs R-values 左值和右值是表达式的基本分类，用于描述其值类别，区别在于对象的身份、生命周期和可操纵性。 左值代表一个有持久状态的变量（或内存位置），通常可以取地址、有名称。可以出现在表达式的左边或右边。 右值代表一个临时变量或字面量，没有持久状态，不可以被取地址。出现在表达式的右边。\n1 2 int x = 10; // x为左值，10为右值 int y = x; // x为左值 对于int\u0026amp; num是左值还是右值？ 左值。在这里，num是按引用传递，对于右值来说只可以存放临时变量，不可以被取地址，所以这里的num只能是左值。\n2.4 Const 当一个对象以常数声明后，它就无法再被修改了。 比如，对于一个vector，若被声明为const std::vector\u0026lt;int\u0026gt; const_vec;，那么此时若对此vector使用push_back就会编译错误。 若将一个引用非常数类型的引用一个常数类型的vector则会导致编译错误\n1 2 3 const std::vector\u0026lt;int\u0026gt; const_vec{1, 2, 3}; std::vector\u0026lt;int\u0026gt;\u0026amp; bad_ref{const_vec}; // 编译错误 const std::vector\u0026lt;int\u0026gt; good_ref{const_vec}; //编译成功 2.5 Compiling C++ Programs C++是一个编译性语言 存在一款软件——编译器 目前流行的编译器有clang g++ g++ -std=c++20 main.cpp -o main 此命令的内容为 使用g++这个编译器在C++20的环境下编译main.cpp这个文件并将编译后的程序命名为main 最后使用./main来执行此程序。 3. Streams 3.1 Streams简单介绍 C++的一个普遍的Input/Output（IO）抽象，此抽象提供一系列接口，用于读取和写入数据。\n1 std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout是一个std::ostream的一个实例变量，用于打印内容\n1 2 double pi; std::cin \u0026gt;\u0026gt; pi; std::cin是一个std::istream的一个实例变量，用于读取内容 流允许以一种普遍的方式来解决数据问题\n3.2 stringstreams 3.2.1 stringstreams简单介绍 用于将字符串以流的方式表达 对于不同类型数据混合的情况很适用\n1 2 3 std::string initial_quote = \u0026#34;Bjarne Stroustrup C makes it easy to shoot yourself in the foot\u0026#34; std::stringstream ss; ss \u0026lt;\u0026lt; initial_quote; 将上文字符串以流的形式写入ss，并且最后存在\\n\n1 2 3 4 std::string first; std::string last; std::string language, extracted_quote; ss \u0026gt;\u0026gt; first \u0026gt;\u0026gt; last \u0026gt;\u0026gt; language; 对于stringstreams来说，以空格来分割一个字符串即，此时first = \u0026quot;Bjarne\u0026quot; last = Stoustrup language = C 但此时我们想把最后剩余的其他内容都写入extracted_quote用这种方式就不可取，由此引入getline()\n3.2.2 getline() getline()会读取一行的内容，即以\\n截止\n1 std::getline(ss, extracted_quote); 3.3 cout and cin 3.3.1 cout的背后原理 当我们想将一个内容输出到终端或控制台时，应当使用std::cout和\u0026lt;\u0026lt;操作符，但仅这样没法输出到控制台，我们还需要加上flush\n1 2 3 double tao = 6.28; std::cout \u0026lt;\u0026lt; tao; std::cout \u0026lt;\u0026lt; std::flush; 在调用endl会隐式调用flush\n1 2 3 double tao = 6.28; std::cout \u0026lt;\u0026lt; tao; std::cout \u0026lt;\u0026lt; std::endl; 当我们每次调用flush时，就会立马清空此处的内存，包括使用endl的时候，在做一个循环时，当我们不断打印一个内容再加上一个换行符，就会耗费许多内存，故flush操作是很昂贵的。 但是，C++作为一个聪明的语言，是会自己知道什么时候该flush的，每当此处内存满了之后，就会自动flush\n3.4 Output Streams 当我们想将一些内容写入文件中就需要用到std::ofstream\n1 2 3 4 5 6 7 8 9 10 11 int main() { std::ofstream ofs(\u0026#34;hello.txt\u0026#34;); // 创建一个流用于打开文件 if (ofs.is_open()) { ofs \u0026lt;\u0026lt; \u0026#34;Hello CS106L\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // 检查文件是否打开 ofs.close(); // 关闭文件 ofs \u0026lt;\u0026lt; \u0026#34;this will not get written\u0026#34;; //此内容不会写进 ofs.open(\u0026#34;hello.txt\u0026#34;); //打开文件 ofs \u0026lt;\u0026lt; \u0026#34;this will though! It\u0026#39;s open again\u0026#34;; // 此内容会写进文件 return 0; } 3.5 Input Streams 从一个文件读取内容就需要用到std::istream std::cin会在遇见空格后停止\ngetline()和std::cin()不能在一起使用 4. Containers 4.1 What is the STL? STL: Standard Template Library\n4.1.1 What are templates? 我们总会遇见同一种函数，十分相似，但它们的差别就在类型不一样，例如\n1 2 3 class IntVecor class DoubleVector class StringVector 如果我们有几百上千种类型呢？难道要一个一个写出来吗，当然不，由此引出模板\n1 2 3 4 5 6 7 8 template \u0026lt;typename T\u0026gt; class vector { }; vector\u0026lt;int\u0026gt; v1; vector\u0026lt;double\u0026gt; v2; vector\u0026lt;string\u0026gt; v3; 所有的STL容器都是模板\n4.1.2 Containers 如何保存一系列元素\n4.1.2.1 Sequence Containers 序列式容器用于保存一些列线性元素\nstd::vector 1 2 3 4 5 6 7 8 9 10 11 12 std::vector\u0026lt;int\u0026gt; v; // 创建一个空vector std::vector\u0026lt;int\u0026gt; v(n); // 创建一个大小为n的vector，其中所有元素均为0 std::vector\u0026lt;int\u0026gt; v(n, k); // 创建一个大小为n的vector，其中所有元素均为k v.push_back(k); // 将k添加到vector后面 v.clear(); // 清空vector v.empty(); // 检查vector是否为空 // 获取第i个元素 int k = v.at(i); int k = v[i]; // 将第i个元素替换为k v.at(i) = k; v[i] = k; Tips\n如果可以，使用range-based for（基本范围的for循环） 1 2 3 4 5 6 7 for (size_t i = 0; i \u0026lt; vec.size(); i++) { std::cout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // range-based for for (auto elem : vec) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 这适用于所有可迭代的容器，不止vector 2. 在使用range-based for时，将类型更改为const auto\u0026amp;，这有利于节省内存，原先会创建一系列元素的复制，现在只会在原元素上更改\n1 2 3 for (auto elem : vec) 变为 for (const auto\u0026amp; elem : vec) 对于[]操作符不会进行边界检查 1 2 3 // 假定2已经超出边界 vec[2] = 4; // 未定义的行为 vec.at(2) = 4; // 运行时间超时 假定现在又超过一百万个元素在一个vector中，想要在第一个地方添加一个元素，就需要将这一百万个元素全部向后移动一位，这很耗费时间，由此我们就引出了deque\nstd::deque deque是双端队列，允许操作第一个或最后一个元素 对于vector来说，用的是空间中的一组内存，而对于deque，用的书空间中一组内存的一组内存，将整个元素分开了 4.1.2.2 Associative Containers 关联式容器用于组织键值对元素\nstd::map 用一个key来匹配一个value，其中key是唯一的，value可以不唯一 1 2 3 4 5 6 7 8 9 10 11 12 std::map\u0026lt;char, int\u0026gt; m; // 创建一个空map // 将key为k，value为v的键值对添加到map中 m.insert({k, v}); m[k] = v; m.erase(k); // 移除key为k的键值对 // 检查k是否在map里 m.count(k) m.contains(k) // C++20 m.empty() // 检查map是否为空 // 将key为k的value重写 int i = m[k]; m[k] = i; 当map存储的是一个键值对时，其也可以被看作为pair\n1 2 std::map\u0026lt;K, V\u0026gt; std::pair\u0026lt;const K, V\u0026gt; 此处K为常量，即K是不可以被修改的，在map中key也是不可以被修改的，所以此处不能变 range-based for\n1 2 3 4 5 6 7 8 9 10 11 std::map\u0026lt;std::string, int\u0026gt; map; for (auto kv : map) { // 此处就是把map当作pair来看，用的是first和second std::string key = kv.first; int value = kv.second; } // 此处map就是map for (const auto\u0026amp; [key, value] : map) { } map的底层原理即为红黑树，这也就意味着key必须要有操作符\u0026lt;，比如std::map\u0026lt;std::ifstream, int\u0026gt; map在这里就是错误的，因为ifstream无法比较。\nstd::set set存储一组唯一的元素 1 2 3 4 5 6 7 std::set\u0026lt;char\u0026gt; s; // 创建一个空set s.insert(k); // 将k添加到set中 s.erase(k); // 移除set中的k // 检查k是否在set里 s.count(k); s.contains(k) // C++20 s.empty() // 检查set是否为空 set是没有value的map set的底层原理也是红黑树，这同样意味着需要存在操作符\u0026lt;\nstd::unordered_map 和 std::unordered_set 此容器与上文提到的没有什么差别，不同的是底层实现为哈希表，通过哈希函数，将其转变为无序的 为什么使用无序？更平均的负载因子，当负载因子过高时，允许rehash 通常来说，unordered_map要快于map 但unordered_map要用更多的内存 若key不存在操作符\u0026lt;，使用unordered_map 若必须要从中挑一个，unordered_map会更安全 5. Iterators 5.1 Iterator基础 在上文提到的range-based for中，这是如何实现的 容器与迭代器一起工作就构成了迭代 迭代器存在三个操作\n获取一个元素 向前移动一个元素 检查整个元素是否已经遍历完成 容器存在两个接口 container.begin()获取第一个元素迭代器 container.end()获取最后一个元素的后一个元素的迭代器，它永远不会指向最后一个元素，一定会指向最后一个元素的后一个元素，因为若此容器为空，c.begin() == c.end()就会为真 综上，当我们写下 1 2 3 for (auto elem : s) { std::cout \u0026lt;\u0026lt; elem; } 就是写下\n1 2 3 4 for (auto it = s.begin(); it != s.end(); ++it) { auto elem = *it; std::cout \u0026lt;\u0026lt; elem; } 补充：为什么使用++it而不是it++ ++it会避免生成不必要的复制\n5.2 Iterator Types 对于迭代器来说，不止有一个一个增加的迭代，还存在许多其他操作\n1 2 3 4 --it; // 向前一位 *it = elem; // 修改此处的值 it += n; // 向前n位 it1 \u0026lt; it2; // 判断it1是否在it2前面 若元素在结构体当中，可以用-\u0026gt;来访问元素\n1 2 3 4 5 6 7 8 struct Bibble { int zarf; }; std::vector\u0026lt;Bibble\u0026gt; v {...}; auto it = v.begin(); int m = (*it).zarf; int m = it-\u0026gt;zarf; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // IO迭代器 auto elem = *it // 访问元素 *it = elem; // 写入元素 // 向前迭代器 it1 == it2； ++it1 == ++it2； // 反向迭代器 auto it = m.end(); --it; auto\u0026amp; elem = *it; // 获取最后一个元素 //随机访问迭代器 auto it2 = it + 5; // 向前五个 auto it3 = it2 - 2; // 向后两个 5.3 Pointers and Memory 一个迭代器指向一个容器元素 一个指针指向任何对象\n5.3.1 Memory基础 每个变量都存放在内存中的某个地方 所有地方都可以被一个地址来表示 地址用字节寻址法，每个字节都从0开始 1 byte = 8 bits 一个对象的地址是用此对象最小地址来表示的 对于一个整数类型x来说，它在内存中占四个字节，假设为0x10 0x11 0x12 0x13，那么此时x的地址就是0x10 5.3.2 变量地址表示方法 指针\n1 2 3 4 5 6 int x = 106; int* px = \u0026amp;x; // int*为一个整数指针 \u0026amp;为取地址操作符 x // 106 *px // 106 px // 0x50527c 对于不同的对象，有不同的指针表示方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int x = 106; int* px = \u0026amp;x; // 结构体 StanfordID id {\u0026#34;jtrb\u0026#34;}; StanfordID* p = \u0026amp;id; auto name = p -\u0026gt; name; // vector std::vector\u0026lt;int\u0026gt; v; std::vector\u0026lt;int\u0026gt;* p = \u0026amp;v; // vector []表示法 std::vector\u0026lt;int\u0026gt; v {1, 2, 3, 4, 5}; int* arr = \u0026amp;v[0]; 对于vector来说，其在内存中是以一块内存表示的，故我们可以使用指针运算来表示\n1 2 3 4 5 6 std::vector\u0026lt;int\u0026gt; v {1, 2, 3, 4, 5}; int* arr = \u0026amp;v[0]; arr += 1; // index = 1 ++arr; // index = 2 arr += 2; // index = 4 arr == \u0026amp;v[4]; // 取index为4的值 6. Classes 6.1 类基础 为什么使用类？ C没有对象 不能在操作数据的时候封装数据与函数 无法使用面向对象编程范式 什么是面向对象 面向对象所有内容都是围绕对象来实现的 专注于设计与实现类 类是由用户定义的 容器都是STL定义的类 6.2 结构体与类的区别 结构体是受限制的类 对于结构体来说，其所定义的所有fields都是public的，这也就意味着它们可以被用户随意更改 对于类，其存在public private，用户只能访问public的对象\n6.3 类语法 6.3.1 头文件与源文件的区别 Header File(.h) Source File(.cpp) 目的 定义接口 实现函数 包括内容 函数原型、类声明、类型定义、宏、常数 函数具体实现内容，执行代码 访问 与源文件分享 被编译 举例 void someFunction(); void someFunction(){}; 6.3.2 设计类 构造函数 私有函数/变量 公共函数 Destructor（析构函数） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // .h file class StanfordID { private: std::string name; std::string sunet; int idNumber; public: StanfordID(std::string name, std::string sunet, int idNumber); // Constructor // method std::string getName(); std::string getSunet(); int getID(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // .cpp file #include \u0026#34;StanfordID.h\u0026#34; // 包含头文件 #include \u0026lt;string\u0026gt; // 使用namespace就像std::一样 StanfordID::StanfordID(std::string name, std::string sunet, int idNumber) { this -\u0026gt; name = name; // 使用this关键字来表示现在具体是哪个值 this -\u0026gt; sunet = sunet; // 可以检查是否有效 if (this -\u0026gt; idNumber \u0026gt; 0) { this -\u0026gt; idNumber = idNumber; } } // uniform initialization(C++11) StanfordID::StanfordID(std::string name, std::string sunet, int idNumber) : name{name}, sunet{sunet}, idNumber{idNumber}; // 实现方法 std::string StanfordID::getName() { return this-\u0026gt;name; } std::string StanfordID::getSunet() { return this-\u0026gt;sunet; } int StanfordID::getID() { return this-\u0026gt;idNumber; } // 绑定函数 void StanfordID::setName(std::string name) { this-\u0026gt;name = name; } void StanfordID::setSunet(std::string sunet) { this-\u0026gt;sunet = sunet; } void StanfordID::setID(int idNumber) { if (idNumber \u0026gt;= 0){ this-\u0026gt;idNumber = idNumber; } } // destructor StanfordID::~StanfordID() { //释放内存 } 对于析构函数来说，它是为了释放我们在空间中使用的内存，但当我们new一个新对象时，它会自动帮我们释放的，尽管如此，这依旧很重要\n6.4 Inheritance 多态性：不同的对象有可能会使用相同的接口 可扩展性：继承允许扩大类来创造子类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // .h file class Shape { public: virtual double area() const = 0; // 虚拟函数 }； class Circle : public Shape { // :继承 private: double _radius; public: Circle(double radius): _radius{radius} {}; // 构造函数 uniform initialization double area() const { return 3.14 * _radius * _radius; } // 重写 area()函数 } public protected private\n7. Template Classes 7.1 预处理器与宏定义 在创建我们自己的vector的时候，会遇到对不同的类型写不同的代码的情况，但它们之间的区别又很小，只有一个类型的差别，例如\n1 2 3 4 5 6 7 8 9 10 11 12 class IntVector { public: int\u0026amp; at(size_t index); void push_back(const int\u0026amp; elem); private: int* elems; size_t logical_size; size_t array_size; }; class DoubleVector class StringVector 对于这种情况，我们引出了预处理器与宏\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define GENERATE_VECTOR(MY_TYPE) class MY_TYPE##Vector { public: MY_TYPE\u0026amp; at(size_t index); void push_back(const MY_TYPE\u0026amp; elem); private: MY_TYPE* elems; size_t logical_size; size_t array_size; }; GENERATE_VECTOR(int) int Vector v1; v1.push_back(5); 预处理器允许其在编译之前运行 通过这种方式，允许我们创建不同类型的vector 但对于这种方式，也会存在其缺点\n类C语言的语法 很难做类型检查 有时会忘了做宏定义 因此，继续引出Templates 7.2 Templates 模板允许自动生成代码\n1 2 3 4 5 6 7 8 template \u0026lt;typename T\u0026gt; // 模板声明 T会自己替换类型 class Vector { public: T\u0026amp; at(size_t index); void push_back(const T\u0026amp; elem); private: T* elems; } 对于特定类型的模板，我们称其为Template Instantiation，以下均为模板实例化\n1 2 3 4 5 6 Vector\u0026lt;int\u0026gt; intVec; Vector\u0026lt;double\u0026gt; doubleVec; Vector\u0026lt;std::string\u0026gt; strVec; Vector\u0026lt;Vector\u0026lt;int\u0026gt;\u0026gt; vecVec; struct MyCustomType {}; Vector\u0026lt;MyCustomType\u0026gt; structVec; 编译器会自己替换类型的 对于typename来说，允许替换\n1 2 3 4 5 6 7 8 9 10 template \u0026lt;typename T\u0026gt; class Vector {}; template \u0026lt;size_t N\u0026gt; class SizeTemplate {}; template \u0026lt;bool B\u0026gt; class BoolTemplate {}; template \u0026lt;typename T, std::size_t N\u0026gt; 7.2.1 一些模板的怪癖 在.cpp文件中必须包含template\u0026lt; \u0026gt; .h必须在底部包含.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // .h template \u0026lt;typename T\u0026gt; class Vector { public: T\u0026amp; at(size_t i); } #include \u0026#34;Vector.cpp\u0026#34; // 怪癖2 必须包含 // .cpp template \u0026lt;typename T\u0026gt; // 怪癖1 显式写出来 T\u0026amp; Vetor\u0026lt;T\u0026gt;::at(size_t i) { } typename与class是一样的 1 2 template \u0026lt;typename K, typename V\u0026gt; struct pair; template \u0026lt;class K, class V\u0026gt; struct pair; 7.3 Const Correctness 当我们书写以下函数时，编译器会给出错误No such method size!\n1 2 3 4 5 6 void printVec(const Vector\u0026lt;int\u0026gt;\u0026amp; v) { for (size_t i = 0; i \u0026lt; v.size(); i++) { std::cout \u0026lt;\u0026lt; v.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } 但我们明明在之前就已经实现了size\n1 2 3 4 5 6 7 8 9 template\u0026lt;class T\u0026gt; class Vector { public: size_t size(); bool empty(); T\u0026amp; operator[] (size_t index); T\u0026amp; at(size_t index); void push_back(const T\u0026amp; elem); }; 问题在于\n对于v来说传递的是个常数，不希望修改v 编译器不确定size是否会修改v 因为成员函数是有可能会修改v的 修改方法为，在后面加上const标识符，以告诉编译器，我确保此方法不会修改对象 1 2 3 4 5 6 7 8 9 template\u0026lt;class T\u0026gt; class Vector { public: size_t size() const; bool empty() const; T\u0026amp; operator[] (size_t index); T\u0026amp; at(size_t index) const; void push_back(const T\u0026amp; elem); }; 对于.cpp文件也应该加上const标识符\n1 2 3 4 template \u0026lt;class T\u0026gt; size_t Vector\u0026lt;T\u0026gt;::size() const { return logical_size; } 7.3.1 Const interface 对象被标记为const后只能使用const interface const interface是作为对象中的一个常量函数 7.3.2 Const Cast 对于T\u0026amp; at(size_t index) const;来说存在两个错误\nconst可以修改 返回一个引用常量const T\u0026amp; at(size_t index) const; 非const不可以修改 重写函数，写两个版本的at()，一个版本用于接收const参数，另一个用于接收非const参数 1 2 3 4 5 6 template\u0026lt;class T\u0026gt; class Vector { public: const T\u0026amp; at(size_t index) const; T\u0026amp; at(size_t index); } 但如果我们有许多函数要对常量与非常量进行运算，那每个函数就要写两遍，这过于冗余了，因此我们引出casting\ncasting 将一个类型强制转换为另一个类型 const_cast 将非const强转为const const_cast\u0026lt;Vector\u0026lt;T\u0026gt;\u0026amp;\u0026gt;(*this).findElement(value); const_cast将非const强转为const Vector\u0026lt;T\u0026gt;\u0026amp;非const引用 *this解引用const Vector\u0026lt;T\u0026gt;* findElement非const版本的findElement() 什么时候使用const_cast？ 最好不要 8. Template Functions 8.1 Template Functions 8.1.1 三元运算符 1 return a \u0026lt; b ? a : b; 若 a \u0026lt; b 则返回 a 反之 b 当我们想将不同的类型进行上述比较，按之前的方法可能需要些若干个函数，分别表示不同的类型，但现在我们可以使用模板\n1 2 3 4 template \u0026lt;typename T\u0026gt; T min(T a, T b) { return a \u0026lt; b ? a : b; } 同样的，可以写出引用类型，防止复制一份额外的，占用内存\n1 2 3 4 template \u0026lt;typename T\u0026gt; T min(const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? a : b; } 8.1.2 调用模板函数 explicit instantiation（显式实例化） 1 2 min\u0026lt;int\u0026gt;(106, 107); min\u0026lt;double\u0026gt;(1.2, 3.4); implicit instantiation（隐式实例化） 1 2 min(106, 107); min(1.2, 3.4); 编译器会自己调用类型，有点像之前学到的auto关键字 若给出min(106, 3.14)则无法编译，解决方法为改变函数签名\n1 2 3 4 template \u0026lt;typename T, typename U\u0026gt; auto min(const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? a : b; } 8.2 Concepts 编译器发现错误只会在实例化之后，这也就是说，有些事物可以被实例化，但无法被比较，此时编译器会正常实例化，但无法比较，由此，如何才能在实例化之前发现错误（无法被比较）？\nIntroducing C++ concepts 创建Comparable concept\n1 2 3 4 template \u0026lt;typename T\u0026gt; concept Comparable = requires(const T a, const T b) { {a \u0026lt; b} -\u0026gt; std::convertible_to\u0026lt;bool\u0026gt;; }; concept: a named set of constraints requires: 提供两个参数 {a \u0026lt; b}(constraint): 任何在大括号内的东西都必须被无错误地编译 std::convertible_to\u0026lt;bool\u0026gt;(constraint): 结果必须为布尔值 此时，就可以避免无法被比较的错误了 1 2 3 4 template \u0026lt;typename T\u0026gt; requires Comparable\u0026lt;T\u0026gt; // 简短写法 template \u0026lt;Comparable T\u0026gt; 8.3 Variadic Templates 如果我们想在一个函数里面接受更多的参数，应该怎么做，简单的想法是重写许多个函数，让编译器自己寻找该用哪一个，这显然过于冗余 Templates + recursion\n1 2 3 4 5 6 7 8 9 10 // base case template \u0026lt;Comparable T\u0026gt; T min(const T\u0026amp; v) {return v;} // recrusive case template \u0026lt;Comparable T, Comparable... Args\u0026gt; T min(const T\u0026amp; v, const Args\u0026amp;... args) { auto m = min(args...); return v \u0026lt; m ? v : m; } Comparable... Args Variadic template匹配0或更多个类型 const Args\u0026amp; Parameter pack匹配0或更多个参数 min(args) 替换为实际参数 8.4 Template Metaprogramming TMP is Turing complete 如何让我们得到既可以在编译时运行又有可读性的代码呢？ constexpr/consteval(C++20) constexpr: 尝试在编译时运行此段代码 consteval: 必须在编译时运行此段代码\n1 2 3 4 5 6 7 8 constexpr size_t factorial(size_t n) { if (n == 0) return 1; return n * factorial(n - 1); } consteval size_t factorial(size_t n) { if (n == 0) return 1; return n * factorial(n - 1); } 9. Functions and Lambdas 9.1 Functions and Lambdas 9.1.1 传递函数 有时会想把一个布尔函数作为查找一个东西的条件，我们在此称其为predicates那么如何优雅的将此条件加入到函数中呢，简单想法为作为函数中的一个参数来实现，问题在于其类型是什么，以find_if()为例\n1 2 3 4 5 6 7 template \u0026lt;typename It, typename Pred\u0026gt; It find_if(It first, It last, Pred pred) { for (auto it = first; it != last; ++it) { if (pred(*it)) return it; } return last; } 在此我们对于predicates的类型作为typename，编译器会自己帮我们找其类型具体是什么的。在函数内也传递了此条件，运用了此条件 旁注，Pred的类型具体是什么？ 在C++中，这可以作为一个函数指针，用于指向一个函数\n1 2 Pred = bool(*)(int); Pred = bool(*)(char); 但有时候又会遇见在条件中不止一个参数的情况，比如bool isLessThan(int elem, int n)在这种情况，我们就无法在其他函数中使用此函数，因为要在其他函数使用此函数，只能传递一个参数，由此引出Lambda Functions\n9.1.2 Lambda函数 Lambda函数允许我们在使用一个参数的情况下也依然可以比较多个参数之间的值，举例来说，\n1 2 3 auto lessThanN = [n](int x) { return x \u0026lt; n; } 在这里我们实际上只传递了一个参数x lambda函数允许出现在其他函数的参数中\n9.1.3 Functor(仿函数) 一个扮演着函数的对象，由operator()定义的对象\n1 2 3 4 5 6 7 8 template \u0026lt;typename T\u0026gt; struct std::greater { bool operator()(const T\u0026amp; a, const T\u0026amp; b) const { return a \u0026gt; b; } }; std::greater\u0026lt;int\u0026gt; g; g(1, 2); 由于仿函数是一个对象，所以其存在state\n1 2 3 4 5 6 7 8 9 struct my_functor { bool operator()(int a) const { return a * value; } int value; }; my_functor f; f.value = 5; f(10); 9.1.4 仿函数与Lambda函数之间的关系 当我们写一个Lambda函数时，实际上就是在用仿函数来写，例如以下两函数表达的是同一个意思\n1 2 3 4 int n = 10; auto lessThanN = [n](int x) { return x \u0026lt; n; }; find_if(begin, end, lessThanN); 1 2 3 4 5 6 7 8 9 10 11 12 13 class __lambda_6_18 { public: bool operator()(int x) const { return x \u0026lt; n; } __lambda_6_18(int\u0026amp; _n) : n{_n} {} private: int n; }; int n = 10; auto lessThanN = __lambda_6_18{n}; find_if(begin, end, lessThanN); 9.2 Algorithms \u0026lt;algorithm\u0026gt;是一个模板函数的集合\n9.3 Ranges and Views 9.3.1 Ranges Ranges是一个STL的新版本 定义：range是任何拥有begin和end的东西 这意味着许多可以迭代的数据结构都存在ranges\n9.3.2 Views 一种组合算法的方法 定义：惰性的适配另一个range的range 若我们用现在的STL来写代码，可能会是这样的\n1 2 3 4 5 6 7 8 std::vector\u0026lt;char\u0026gt; v = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;}; // Filter -- Get only the vowels std::vector\u0026lt;char\u0026gt; f; std::copy_if(v.begin(), v.end(), std::back_inserter(f), isVowel); // Transform -- Convert to uppercase std::vector\u0026lt;char\u0026gt; t; std::transform(f.begin(), f.end(), std::back_inserter(t), toupper); // { \u0026#39;A\u0026#39;, \u0026#39;E\u0026#39; } 但使用veiws来写，就会简单很多\n1 2 3 4 std::vector\u0026lt;char\u0026gt; letters = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e’}; auto f = std::ranges::views::filter(letters, isVowel); auto t = std::ranges::views::transform(f, toupper); auto vowelUpper = std::ranges::to\u0026lt;std::vector\u0026lt;char\u0026gt;\u0026gt;(t); 同时还可以使用|链式操作\n1 2 3 4 5 std::vector\u0026lt;char\u0026gt; letters = {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;}; std::vector\u0026lt;char\u0026gt; upperVowel = letters | std::ranges::views::filter(isVowel) | std::ranges::views::transform(toupper) | std::ranges::to\u0026lt;std::vector\u0026lt;char\u0026gt;\u0026gt;(); 使用ranges/views的优缺点 优点\n不用担心迭代器 更好的错误消息提示 可读性更高、函数化更好的语法 缺点 太新了（C++20开始），很少人了解 缺乏编译器支持 与手工编码版本相比的性能缺失 10. Operator Overloading 10.1 Member overloading 当我们想要比较我们自己创建的类的时候，常常会因为此类无法被比较而失败，但C++允许我们自己重载操作符，以帮助我们比较两个类，就像我们之前学习的StanfordID类，就可以对其操作符进行重载，具体怎么做？\n就像我们在类中声明函数一样，我们可以以声明函数的方式声明操作符 当我们对我们创建的对象使用操作符时，这代表在执行自定义的函数或操作符 就像函数重载一样，当我们给了一样的名字，它就会重写操作符的行为，编译器自己会找到该用哪个的 因此，我们的StanfordID的小于操作符可以写成 1 2 3 bool StanfordID::operator\u0026lt; (const StanfordID\u0026amp; other) const { return idNumber \u0026lt; other.getIdNumber(); } 10.2 Non-member overloading 上文提到的是member overloading，不止这种方法，在C++中更被人们所喜欢和应用的是Non-member overloading，为什么？\n允许(left-hand-side)左边是非类类型(non-class type) 允许重载我们没有掌控的类的运算符，比如我们可以将StanfordID与其他类进行比较 1 2 3 4 // Non-member bool operator\u0026lt; (const StanfordID\u0026amp; lhs, const StanfordID\u0026amp; rhs); // member bool StanfordID::operator\u0026lt; (const StanfordID\u0026amp; rhs) const {...} 10.4 friend friend关键字允许non-member函数或non-member类访问其他类中private里的值 friend应该写在.h文件中显式写出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // .h file class StanfordID { private: std::string name; std::string sunet; int idNumber; public: // constructor for our StudentID StanfordID(std::string name, std::string sunet, int idNumber); ... friend bool operator \u0026lt;(const StanfordID\u0026amp; lhs, const StanfordID\u0026amp; rhs); } // .cpp file #include StanfordID.h bool operator\u0026lt; (const StanfordID\u0026amp; lhs, const StanfordID\u0026amp; rhs) { return lhs.idNumber \u0026lt; rhs.idNumber; } 运算符允许传递函数不存在的类型\noperator overloading解锁了我们定义对象新的功能和意义 运算符应该有意义，传递一些函数并不关乎类型本身 仅在需要的时候overload，比如不需要使用IO流的时候就不需要重写\u0026lt;\u0026lt;或\u0026gt;\u0026gt; 11. Move Semantics(移动语义) 假设现在我们存在一个Photo类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Photo { public: Photo(int width, int height); Photo(const Photo\u0026amp; other); Photo\u0026amp; operator=(const Photo\u0026amp; other); ~Photo(); private: int width; int height; int* data; }; // Constructor Photo::Photo(int width, int height) : width(width) , height(height) , data(new int[width * height]) {} // Copy Constructor Photo::Photo(const Photo\u0026amp; other) : width(other.width) , height(other.height) , data(new int[width * height]) { std::copy(other.data, other.data + width * height, data); } // Copy Assignment Photo \u0026amp;Photo::operator=(const Photo\u0026amp; other) { // Check for self assignment if (this == \u0026amp;other) return *this; delete[] data; // Clean up old pixels! // Copy over new pixels! width = other.width; height = other.height; data = new int[width * height]; std::copy(other.data, other.data + width * height, data); return *this; } // Destructor Photo::~Photo() { delete[] data; } 当此时已经存在一个Photo实例时，现在想要再得到一个相同的Photo时，第一时间可能会想到使用Copy复制一份，但可以有更好的方式不需要通过复制来实现——移动语义（std::move()）。使用这种方式可以直接指向原Photo而不用复制。但是，使用这种方式一定是安全的吗？如果我们未来还需要再使用这个对象，那此时原对象已经指向null了，就会出现空指针异常的情况。\n11.1 左值与右值 关于左值与右值，上文已经有提过，在此需要对其加深理解。\n左值的生命周期在范围结束 右值的生命周期在本行接受 左值是持续值 右值是暂时值 对于引用类型来说， 左值：Type\u0026amp; 右值：Type\u0026amp;\u0026amp; 重载\u0026amp; \u0026amp;\u0026amp;以区分左值引用与右值引用 11.2 移动语义 Move constructor Type::(Type\u0026amp;\u0026amp; other) Move assignment operator Type\u0026amp; Type::operator=(Type\u0026amp;\u0026amp; other) 一般来说，编译器会决定使用\u0026amp;还是\u0026amp;\u0026amp;，但这一定是最有效率的吗？事实上，若我们知道一个值就是临时的，不妨主动使用移动语义。 要想显式删除移动语义，可以使用 Move constructor Type::(Type\u0026amp;\u0026amp; other) = delete; Move assignment operator Type\u0026amp; Type::operator=(Type\u0026amp;\u0026amp; other) = delete; 11.3 SMFs 目前为止，我们已经学习了许多Special Member Functions\nType::Type(const Type\u0026amp; other); Type\u0026amp; Type::operator=(const Type\u0026amp; other); Type::Type(Type\u0026amp;\u0026amp; other); Type\u0026amp; Type::operator=(Type\u0026amp;\u0026amp; other); ~Type::Type(); 但我们在写每个类的时候都需要把他们都写出来吗？ 不需要 Rule of Zero 若类不需要管理内存（或其他外部资源），编译器会创造有效的SMFs的 Rule of Three 若类需要管理内存，必须定义copy assignment/constructor即Destructor Copy Assignment Copy Constructor，若不定义这些，编译器不会复制底层资源 Rule of Five 若定义了copy assignment/constructor即Destructor Copy Assignment Copy Constructor，则也应该定义move constructor/assignment，即Move Assignment Move Constructor 这不是必须的，但若不定义，则代码可能会在包含一些不必要的复制时变得缓慢 12. std::optional \u0026amp; type safety 12.1 Type safety 1 2 3 4 5 int div_3(int x) { return x / 3; } div_3(\u0026#34;hello\u0026#34;) 这就是一个类型错误，函数需要的是int类型的参数，但给的是个string，编译器会给出错误，永远不会运行。\n12.2 std::optional\u0026lt; T \u0026gt; std::optional是一个模板类要么包含一个类型为T的值，要么什么也不包含，对于不包含的情况会表示为nullopt nullopt是一个可以转换为任意可选类型的值的对象\n1 2 3 4 5 void main(){ std::optional\u0026lt;int\u0026gt; num1 = {}; //num1 does not have a value num1 = 1; //now it does! num1 = std::nullopt; //now it doesn\u0026#39;t anymore } std::optional含有以下接口\n.value(): returns the contained value or throws bad_optional_access error .value_or(valueType val) returns the contained value or default value, parameter val .has_value() returns true if contained value exists, false otherwise 优点 函数签名创建更多有意义的contracts 调用类函数时，会有更多保证和有效的行为 缺点 需要在任何地方使用.value() 有可能存在bad_optional_access optionals会有未定义的行为（错误检查） 有很多情况我们想要std::optional\u0026lt;T\u0026amp;\u0026gt;这个引用类型，但是C++并没有提供 12.3 总结 可以保证程序在一个严格的类型检查下进行 std::optional是一个工具可以用.has_value()来返回一个值或nothing 这个应用并不广泛并且慢，所以C++大多数数据结构并没有optional 不仅在类中使用，在应用程序代码中也可以使用，并且是很推荐的。 13. RAII, Smart Pointers, Building Projects 13.1 RAII(Resource Acquisition Is Initialization)资源获取即初始化 13.1.1 Exceptions 异常是一种处理错误的方法，用于抛出异常 thrown 在非严重错误时捕捉异常用于继续代码进行 13.1.2 RAII 什么是RAII？\n一个类中所有使用的资源应该被构造函数所获取 一个类中所有使用的资源应该被析构函数所释放 为什么使用RAII？ 通过遵守RAII政策，可以避免half-valid状态 无论怎样，析构函数总是会被调用在资源用完之后 资源/对象会立即运用当它们被创建 13.2 Smart Pointers 对于RAII for locks，我们会用lock_guard，这会创建一个对象用于在构造函数中获取所有资源，并在析构函数中释放这些资源 而对于RAII for memory，我们也做同样的事情，只不过在这里我们称之为smart pointers\nstd::unique_ptr 只属于这一个资源，不可以被复制 std::shared_ptr 可以复制，当底层内存超出范围时，就会被破坏 std::weak_ptr 一类旨在缓解循环依赖的指针 1 2 3 4 5 6 7 8 // 不要这么声明 Node* n = new Node; std::unique_ptr\u0026lt;T\u0026gt; uniquePtr = std::make_unique\u0026lt;T\u0026gt;(); std::shared_ptr\u0026lt;T\u0026gt; sharedPtr = std::make_shared\u0026lt;T\u0026gt;(); std::weak\u0026lt;T\u0026gt; wp = sharedPtr; 一定要使用std来make smart pointer\n如果不这么做，会分配两次内存，一次是为了声明一个指针，另一次是为了new一个对象 整个代码应该保持一个连续性，更易读 13.3 Building C++ Projects 13.3.1 编译流程 编写一个C++代码后，它要被翻译为机器代码以使编译器识别 g++ main.cpp -o main\n13.3.2 Make make是一个构建系统程序来帮助我们编译\n你可以规定编译器做什么 为了使用make需要有一个Makefile 1 2 3 4 5 6 7 8 9 10 11 12 13 # Compiler CXX = g++ # Compiler flags CXXFLAGS = -std=c++20 # Source files and target SRCS = $(wildcard *.cpp) TARGET = main # Default target all: $(CXX) $(CXXFLAGS) $(SRCS) -o $(TARGET) # Clean up clean: rm -f $(TARGET) 13.3.3 CMake CMake是一个构建系统生成器，可以用CMake来生成Makefiles，就像一个Makefiles的高一层抽象 对于一个CMakeList.txt文件来说，存在以下内容\n1 2 3 4 5 cmake_minimum_required(VERSION 3.10) project(cs106l_classes) set(CMAKE_CXX_STANDARD 20) file(GLOB SRC_FILES \u0026#34;*.cpp\u0026#34;) add_executable(main ${SRC_FILES}) set为设定编译器版本为C++20 GLOB告诉CMake搜索所有后缀为cpp的文件 add_executable该命令将程序的所有源文件添加到可执行文件中 如何使用CMake？ 拥有一个CMakeLists.txt 创建一个build文件夹 运行CMake 运行make 执行文件./main ","date":"2025-04-06T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-notes/","title":"CS106L Winter2025 NOTES"},{"content":"具体思路 本lab大致内容为让我们使用数组来实现一颗树，且树要有类似于BST的搜索功能，但这里的比较方法不是简单的比较，而是每个节点都存在一个优先级，值越小优先级越大。题目给了我们许多脚手架，我的建议是一直看下去知道size()方法，连同注释也要一起看，这样就会对整个内容有个大致的了解，这很重要。 以下做题顺序以lab建议我们的做题顺序为准。\nleft/right/parentIndex(int i) 这三个方法只需要用题目给我们的representing a tree with an array来做即可，具体为\n节点n的左节点的位置位于2n 节点n的右节点的位置位于2n+1 节点n的父节点的位置位于n/2 可写出代码 1 2 3 4 5 6 7 8 9 10 11 private static int leftIndex(int i) { return 2 * i; } private static int rightIndex(int i) { return 2 * i + 1; } private static int parentIndex(int i) { return i / 2; } swim(int index) 先看一下题目对于swim的定义\n将刚才添加的项与其父项交换 直到刚才添加的项比其父项大，否则一直交换值 这样一步一步向上游的感觉就称之为swim 问：这里的比较比的是什么？ 答：各个数组元素为一个节点，每个节点存在一个优先级mypriority 使用上文给我们的方法min即可比较两节点之间的优先级大小，可以写出代码， 1 2 3 4 5 6 7 8 9 private void swim(int index) { // Throws an exception if index is invalid. DON\u0026#39;T CHANGE THIS LINE. validateSinkSwimArg(index); while (min(index, parentIndex(index)) == index \u0026amp;\u0026amp; inBounds(parentIndex(index))) { swap(index, parentIndex(index)); index = parentIndex(index); } } sink(int index) 先看一下题目对sink的定义 将新节点逐渐sink下来，由于树的不变量，它必须要比其两个子树大才能保持原位，若比其两子树都小则要选择一个更小的，从更小的身上swap下来，直到比两子树大，故可以写出代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private void sink(int index) { // Throws an exception if index is invalid. DON\u0026#39;T CHANGE THIS LINE. validateSinkSwimArg(index); while (true) { int left = leftIndex(index); int right = rightIndex(index); int smallest = index; if (min(left, smallest) == left) { smallest = left; } if (min(right, smallest) == right ) { smallest = right; } if (smallest != index) { swap(index, smallest); index = smallest; } else { break; } } } insert(T item, double priority) 看一下题目对add an item的要求\n将要添加的节点放在树最底部的位置，即数组最后面的位置 swim此节点 对于此树，数组0的位置没有任何东西，故不能简单的用size来表示当前树有多少个节点，而是用size+1，故写出代码 1 2 3 4 5 6 7 8 9 10 11 public void insert(T item, double priority) { /* If the array is totally full, resize. */ if (size + 1 == contents.length) { resize(contents.length * 2); } Node currentNode = new Node(item, priority); size += 1; contents[size] = currentNode; swim(size); } peek() 根据注释要求，简单返回第一个节点的item即可，不过在此还是考虑一下边界情况\n1 2 3 4 5 if (size \u0026lt;= 0) { return null; } else { return contents[1].myItem; } removeMin() 看一下题目给的定义\n将根节点与最右边（最小）的节点交换 删除最右边的节点 sink新节点 但在这里还需要返回被删除的节点，故应该在最前面加上初始化，最后再return，简单写出代码 1 2 3 4 5 6 7 8 public T removeMin() { T res = peek(); swap(1, size); contents[size] = null; size--; sink(1); return res; } GitHub地址\n","date":"2025-04-06T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-lab-10-priority-queues/","title":"CS61B SP18 Lab 10 Priority Queues"},{"content":"HW3: Hashing 具体思路 Simple Oomage 首先观察一下这个类，存在三个实例变量，red、blue和green，只要这三个值在0-255之间并且是5的倍数，就称为有效。\nequals 普通的equals只是检查目标地址是否相同，若相同则返回true，反之false，但在这里不可行。同时还应注意的是为了保证比较的两个类是完全相同的两个类，而不是子类或其他，应使用getClass方法来判断，观察Date类的equals方法可模仿写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override public boolean equals(Object o) { if (o == this) { return true; } if (o == null) { return false; } if (o.getClass() != this.getClass()) { return false; } SimpleOomage that = (SimpleOomage) o; return (this.red == that.red) \u0026amp;\u0026amp; (this.green == that.green) \u0026amp;\u0026amp; (this.blue == that.blue); } A Simple hashCode 此题需要我们完成一个哈希函数，作为一个好的哈希函数，应该要做到能平均的放到每一个哈希表中，不会出现一组数据只放在一个哈希表内，对于题目给我们的数可知，这三个数均为0-255之间且为5的倍数的数字，那么一组数最多只有52个数字（0-51），因此我们可以从这两个地方入手，写出\n1 2 3 4 5 6 7 8 9 10 11 12 @Override public int hashCode() { if (!USE_PERFECT_HASH) { return red + green + blue; } else { // Write a perfect hash function for Simple Oomages. int rIndex = red / 5; int gIndex = green / 5; int bIndex = blue / 5; return rIndex * 52 * 52 + gIndex * 52 + bIndex; } } testHashCodePerfect 本体需要我们编写一个测试，来测试目前给的哈希函数是错误的，先观察一下当前的哈希函数，这只是简单的将三个数字相加，没有做任何区分，可以想到，若把数字交换一下，这同样也会给出一样的值，但从本质上来说，它们是不同的，可以写出\n1 2 3 4 5 @Test public void testHashCodePerfect() { SimpleOomage ooA = new SimpleOomage(5, 10, 20); SimpleOomage ooA2 = new SimpleOomage(10, 20, 5); assertNotEquals(ooA.hashCode(), ooA2.hashCode()); A Perfect hashCode 将USE_PERFECT_HASH改为true即可\n1 private static final boolean USE_PERFECT_HASH = true; ","date":"2025-04-05T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-hw-3-hashing/","title":"CS61B SP18 HW 3 Hashing"},{"content":"写在前面 本文取自Stanford CS106L的第一个作业，以下为笔者对本作业的思考以及对C++的一些思考。\nCS106L作为C++的课程名不虚传，其特性只有自己写题时才能感知出来，一个简单的操作居然会有许多不同的方法来实现，笔者十分震惊，在这之前笔者对于C++仅是只闻其名，不闻其人。\n关于此题，若你有有任何问题或更好的方法，欢迎与我联系。\n点这里向我发邮件\n具体思路 Part 0: Read the code and fill in the Course struct 本题一共有两个任务\n整体看一下代码 补充完整结构Course 首先观察一下整体代码，并说一下整个作业需要我们完成什么。本作业需要我们通过一个csv文件，来看看在一个特定的学期当中，有哪些课被学生选了并允许达到开课的要求，而有哪些课是没有被选的，在这里我们创建一个结构体Course其中包括三个参数，title课程名称、number_of_units此课程共有几个单元以及quarter学期，值得注意的是，国外学期用的是季节+年份来表示。\n在下面有一个函数parse_csv即将一个csv文件转变为一个Course数组来存放。\n还有write_courses_offered和write_courses_not_offered，分别代表将数组中的可以开课的课程存入一个csv文件和将数组中不可以开课的课程存入另一个csv文件当中。\n下一部分看看结构体Course，观察题目给我们的csv文件可以发现，title和quarter均为字符串的形式，故它们的类型均为String，对于number_of_units笔者一开始认为其应该为int类型，但之后会用到一个spilt函数，其类型属于String，即将一个字符串分成好几个不同的字符串，故这里的number_of_units也应该为String类型，\n1 2 3 4 5 struct Course { std::string title; std::string number_of_units; std::string quarter; }; 接下来看代码中的注释，告诉我们看一下main函数，并告知我们这三个函数需要更改一下签名，观察可得，从始至终用的都是同一个结构体数组，而不是一直复制一个不断更改，故可以知道这里的数组应该是引用类型，即指向的是地址，改变一次，下一次也接着改变，故对于parse_csv函数来说需要将签名改为引用类型，而对于write_courses_offered函数来说，它存在特殊要求，最后是需要将参数数组在其原基础上做更改，所以也需要改为引用类型，对于write_courses_not_offered则没有这种要求，故不需要更改，\n1 2 void write_courses_offered(std::vector\u0026lt;Course\u0026gt;\u0026amp; all_courses) void write_courses_not_offered(std::vector\u0026lt;Course\u0026gt; unlisted_courses) Part 1: parse_csv 本题需要我们完成parse_csv函数，此函数主要是读取一个csv文件的内容，并将其中的内容保存在一个Course数组中，简单思考一下，\n应该要使用IO流的方法来读取外部文件的内容，需要注意的是如何打开、关闭一个文件 每一行都对应了一个Course故要一行一行的读取内容，在这里应使用getline()函数 最上面一行的内容不属于Course应忽略，有多种方式可以忽略，如ignore函数，或仅读取却不做任何操作 一行内容存放了三个不同的值，应使用split函数（应include此文件），对于此函数，其返回的是一个字符串数组，故可以使用[]表达式来取值 关于如何对一个结构体数组添加元素，有许多方法可以做到，如push_back函数或emplace_back（这也是笔者对C++很震惊的一点，一个操作居然有如此多种方法可以实现） 故可以写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void parse_csv(std::string filename, std::vector\u0026lt;Course\u0026gt;\u0026amp; courses) { std::ifstream inputFile; inputFile.open(filename); if (inputFile.is_open()) { std::string line; std::getline(inputFile, line); std::vector\u0026lt;std::string\u0026gt; splitString; while (std::getline(inputFile, line)) { splitString = split(line, \u0026#39;,\u0026#39;); Course c; c.title = splitString[0]; c.number_of_units = splitString[1]; c.quarter = splitString[2]; courses.push_back({c}); } } inputFile.close(); } Part 2: write_courses_offered 本题需要将已经存在的一个Course数组进行筛选，选出quarter不为null的课程，写入一个新csv文件，并在最后将此存在的数组删除这些为null的课程，值得注意的点有，\n将数组中的内容写入文件中，应使用ofstream来做，记得打开文件也要关闭文件 对于新csv文件的第一行会有一个特殊的内容需要单独写入 需要记录下来哪些是需要删除的课程，并在最后使用题目给我们的delete_elem_from_vector函数来删除 故简单写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void write_courses_offered(std::vector\u0026lt;Course\u0026gt;\u0026amp; all_courses) { std::ofstream outfile; outfile.open(COURSES_OFFERED_PATH); std::vector\u0026lt;Course\u0026gt; course_need_to_delete; if (outfile.is_open()) { outfile \u0026lt;\u0026lt; \u0026#34;Title,Number of Units,Quarter\u0026#34; \u0026lt;\u0026lt; std::endl; for (Course c: all_courses) { if (c.quarter != \u0026#34;null\u0026#34;) { outfile \u0026lt;\u0026lt; c.title \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; c.number_of_units \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; c.quarter \u0026lt;\u0026lt; std::endl; course_need_to_delete.push_back({c}); } } } outfile.close(); for (auto\u0026amp; c : course_need_to_delete) { delete_elem_from_vector(all_courses, c); } } Part 3: write_courses_not_offered 此题需要将一个已经存在的Course数组进行筛选，选出quarter为null的课程，写入一个新csv文件，但不需要删除，故大致部分与上文无二，还少了最后一个部分，不赘述，\n1 2 3 4 5 6 7 8 9 10 11 12 void write_courses_not_offered(std::vector\u0026lt;Course\u0026gt; unlisted_courses) { /* (STUDENT TODO) Your code goes here... */ std::ofstream outfile; outfile.open(COURSES_NOT_OFFERED_PATH); if (outfile.is_open()) { outfile \u0026lt;\u0026lt; \u0026#34;Title,Number of Units,Quarter\u0026#34; \u0026lt;\u0026lt; std::endl; for (Course c : unlisted_courses) { outfile \u0026lt;\u0026lt; c.title \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; c.number_of_units \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; c.quarter \u0026lt;\u0026lt; std::endl; } } outfile.close(); } 常见问题 不要忘了将main函数的注释给删掉，才能进行autograde评分。笔者在这里起码缠了半个小时（要疯了） ","date":"2025-03-31T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs106l-winter2025-assignment1-simpleenroll/","title":"CS106L Winter2025 Assignment1 SimpleEnroll"},{"content":"写在前面 本lab取自UCB CS61B SP18 Lab9，具体内容为使用二叉搜索树和哈希表实现map。\n若本文存在错误或有更好的想法，欢迎与我联系。\n点这里向我发邮件\n具体思路 BSTMap 概念回顾 首先回忆一下什么是BST。对于一棵树来说，存在\n一系列节点 一系列用来连接这些节点的边（对于任意两个节点仅有一条边来连接） 对于一个存在根节点的树来说，我们称一个节点就是一棵树\n每个节点都存在一个父节点（除根节点以外） 一个没有子节点的节点称为叶子 对于一个二叉树，每个节点存在0、1或2个节点（子树）\n对于一个二叉搜索树，要将搜索的概念引入二叉树中，左边的节点总是要小于右边的，右边的节点总是要大于左边的，中间的节点总是在其中间存在。\nget 对于此方法，我们要递归的找到需要的值，基本思路为若目标值小于当前节点，则往左树寻找，若大于当前节点，则往右数寻找，若等于当前节点，则返回。\n值得注意的是，对于key的比较，应使用Java提供的compareTo方法，这可以让我们比较其他类型的值。简单写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private V getHelper(K key, Node p) { if (p == null) { return null; } int cmp = key.compareTo(p.key); if (cmp \u0026lt; 0) { return getHelper(key, p.left); } else if (cmp \u0026gt; 0) { return getHelper(key, p.right); } else { return p.value; } } public V get(K key) { return getHelper(key, root); } put 对于此方法，与上方法大差不差，总体思路还是比较目标值与当前值的大小，分三种情况讨论即可，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private Node putHelper(K key, V value, Node p) { // if found, do nothing if (p == null) { return new Node(key, value); } // if not found, create a new node, int cmp = key.compareTo(p.key); if (cmp \u0026lt; 0) { p.left = putHelper(key, value, p.left); } else if (cmp \u0026gt; 0) { p.right = putHelper(key, value, p.right); } else { p.value = value; } return p; } public void put(K key, V value) { root = putHelper(key, value, root); size++; } size 在put内添加一个变量，每put一个值，size就自增即可，\n1 2 3 public int size() { return size; } MyHashMap 对于本类，并没有用太多HashTable的底层实现，不过在此，笔者还是想写下一些自己的回顾，以便之后复习。\n对于一个哈希表来说，值得注意的是哈希函数与当前数组存放满之后链表的存放方法，对于哈希函数，每个不同的数据存在不同的哈希函数，但正如algs4所说，创造一个性能好的哈希函数是前沿计算机科学家需要做的事情，我能做的只有站在巨人的肩膀上使用它们。对于拉链法，即当当前数组存放满之后，要在数组之后引入一个指针指向一系列链表，十分巧妙，很好的将内存与时间平衡了起来。\nget 此方法与数组访问元素的方法很像，不同的是，此时的索引应使用哈希函数来变换一下，\n1 2 3 4 5 6 7 public V get(K key) { if (key == null) { return null; } else { return buckets[hash(key)].get(key); } } put 此方法与数组存放元素的方法也很想，不同的是，一个数组的内存总是有限的，若链表的长度过长，时间上也会有损伤，故需要扩大数组 ，很想之前实现过的ArrayDequeue，应实现一个resize方法，简单思路为创建一个新数组，将数组大小扩大，并将原数组的元素存放进去即可，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private MyHashMap(int cap) { buckets = new ArrayMap[cap]; this.clear(); } private void resize(int cap) { MyHashMap\u0026lt;K, V\u0026gt; resizeBucket = new MyHashMap\u0026lt;\u0026gt;(cap); for (int i = 0; i \u0026lt; buckets.length; i++) { for (K key : buckets[i].keySet()) { resizeBucket.put(key, buckets[i].get(key)); } } this.size = resizeBucket.size; this.buckets = resizeBucket.buckets; } public void put(K key, V value) { if (loadFactor() \u0026gt; MAX_LF) { resize(2 * buckets.length); } if (!containsKey(key)) { size++; } buckets[hash(key)].put(key, value); } size 与上文相同，不赘述，\n1 2 3 public int size() { return size; } 点这里看完整代码实现\n","date":"2025-03-26T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-lab9-tree-maps-vs.-hash-maps/","title":"CS61B SP18 Lab9 Tree Maps vs. Hash Maps"},{"content":"写在前面 本HW取自UCB CS61B SP18的HW2: Percolation。\n主要内容为在给定数据结构的情况下，实现一个现实生活中的应用，很好的锻炼了我们对已有API情况下编写代码的能力。\n本文为笔者参考了多方笔记所写，在此感谢所有付出的人，具体参考资料可看最后。\n虽已完成，却仍有许多不解，若你有更好的想法或我需要改进的地方，望不吝赐教。\n点这里向我发邮件~\n具体思路 背景介绍 本HW需要我们使用不相交集的API通过Monte Carlo模拟来估计渗流阈值。\n问：什么是渗流？\n答：简单来说，可以想象一个竖着拜访的箱子，箱子内部有许多小箱子，在最开始它们全都是被锁上的，在最上方有水会流下来，我们需要不断打开小箱子，直到通过重力的作用，有一个完整的路径可以让水从最顶部流到最底部。\nPercolation.java 此部分不会一开始就给出最终答案，而是会以笔者正常的思考一步一步完成最后的内容\n此类需要我们完成一个渗流模型程序，其中包括构造函数、打开一个箱子、整个系统是否渗流等操作。\npublic Percolation(int N) 根据题目描述，构造函数需要我们创建一个N * N的二维网格结构，且所有格子最开始都是锁上的。很容易想到这里需要让我们创建一个二维数组，但此二维数组的类型是什么呢？仔细想想，所有格子最开始是锁上的，是否可以将锁上与打开想象成false和true，因此我们就需要创建一个二维布尔数组。同时，题目给出要求构造函数所要求的时间为二次函数，满足。下方给出了一个极端情况，当N \u0026lt;= 0时应抛出异常，此时我们可以写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 public class Percolation { private boolean[][] grid; private int N; public Percolation(int N) { this.N = N; if (N \u0026lt;= 0) { throw new IllegalArgumentException(); } this.grid = new boolean[N][N]; } public void open(int row, int col) 此方法需要我们完成打开箱子的操作，简单想想，我们之前把箱子抽象为布尔，那打开一个箱子是不是就是将false变为true，且需要满足此时这个箱子不是被打开的，简单做一个if判断即可，可以写出，\n1 2 3 4 5 6 7 8 9 10 11 public void open(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } else { if (!grid[row][col]) { grid[row][col] = true; } else { return; } } } public boolean isOpen(int row, int col) 此方法需要我们完成一个特定的箱子此时是否被打开的操作，一个箱子作为一个布尔值，只需要判断当前布尔值是多少即可，同时题目给出我们要求，若给定参数不合法应抛出异常，故可以写出，\n1 2 3 4 5 6 public boolean isOpen(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } return grid[row][col]; } public boolean isFull(int row, int col) 此方法需要我们判断这个特定的箱子是否是“满”的，如何理解这个Full？根据Josh教授给出的提示，简单来说只要此时这个箱子与最上面一行的箱子中的任何其中一个相连，即视他为isFull，故我们只需要判断这个箱子是否与最上面的箱子之一相连即可，那么问题又来了，我该用什么来表示这个箱子与其他箱子相连呢？我们直到，这个特定的箱子不一定是第二行的，它可以是最后一行，可以是任何一行，所以我们还需要思考它怎么与其他任意一个箱子相连呢？因为我们知道对于两个不相邻的箱子来说，只要它们中间的箱子是打开的，那它们也算是相连的，这里就需要用到我们学习的不相交集的概念了。我们可以把整个二维数组想象成一个不相交集，每打开一个箱子，我们就会将其添加进去。思路明确，想想第一步应该做什么，首先应该创建一个不相交集，故我们可以在构造函数中添加，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Percolation { private boolean[][] grid; private int N; private WeightedQuickUnionUF wquuf; public Percolation(int N) { this.N = N; if (N \u0026lt;= 0) { throw new IllegalArgumentException(); } this.grid = new boolean[N][N]; this.wquuf = new WeightedQuickUnionUF(N * N); } } 有了不相交集，我们就应该判断一个箱子是否与另一个箱子相连，在这里应该是在open方法中添加，每当我们打开一个箱子后，就要在不相交集中添加一个元素，查看不相交集的API，可以发现union(int p, int q)方法是很符合我们所想要的内容的，但我们仔细观察一下，这里的参数需要的是两个整型，我们表示一个箱子用的是一个数组，很明显不符，因此我们就需要把每个箱子添加一个唯一的index，根据Josh教授的提示，我们可以看出，\n需要添加一个特定的方法xyTo1D将一个以xy表示的数组创建一个特定的index，这个方法很好写，仔细观察就可以看出来，\n1 2 3 private int xyTo1D(int row, int col) { return row * N + col; } 有了这个方法我们就可以把每个数组连接起来了，在这里，一个箱子是会与四周的任意一个箱子连接的，故会有四种可能，其中，每个边界如上边指挥与左下右相连，而不会与上方再次相连了，因为他们之间已经没有东西了，故可以写出，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public void open(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } else { if (!grid[row][col]) { grid[row][col] = true; openSiteSum++; } else { return; } } int index = xyTo1D(row, col); // 现开始考虑四周如果是打开的情况，与之相连 // 上边，原节点至少是第二行 if (row \u0026gt; 0 \u0026amp;\u0026amp; isOpen(row - 1, col)) { wquuf.union(xyTo1D(row - 1, col), index); } // 下边，原节点至多是倒数第二行 if (row \u0026lt; N - 1 \u0026amp;\u0026amp; isOpen(row + 1, col)) { wquuf.union(xyTo1D(row + 1, col), index); } // 左边，至少是第二列 if (col \u0026gt; 0 \u0026amp;\u0026amp; isOpen(row, col - 1)) { wquuf.union(xyTo1D(row, col - 1), index); } // 右边，至多是倒数第二列 if (col \u0026lt; N - 1 \u0026amp;\u0026amp; isOpen(row, col + 1)) { wquuf.union(xyTo1D(row, col + 1), index); } } 现在我们已经完成了箱子与箱子之间相连的部分了，该相信isFull该怎么完成了，根据上文可知，这个就是判断这个特定的箱子是否与最上方的任意一个箱子所连接，故我们可以写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 public boolean isFull(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } int index = xyTo1D(row, col); for (int i = 0; i \u0026lt; N; i++) { if (wquuf.connecter(index, xyTo1D(0, i))) { return true; } else { return false; } } } 但是我们可以发现，这需要我们判断上面每一个箱子，这属于线性时间，不符合题目所要求的常数时间，所以此方法不可取，还需寻找其他方法，根据Josh教授给出的提示，\n我们可以在上下两部分都给出一个虚拟箱子，并让上虚拟箱子与第一行的相连，让下虚拟仙子与最后一行相连，只要上虚拟箱子与特定箱子相连，即表示Full，故可以写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class Percolation { private boolean[][] grid; private int N; private WeightedQuickUnionUF wquuf; private int virtualTopSite; private int virtualBottomSite; public Percolation(int N) { this.N = N; if (N \u0026lt;= 0) { throw new IllegalArgumentException(); } this.grid = new boolean[N][N]; this.wquuf = new WeightedQuickUnionUF(N * N + 2); this.virtualTopSite = N * N; this.virtualBottomSite = N * N + 1; } public void open(int row, int col) { // 前省略 int index = xyTo1D(row, col); // 将上方的虚拟节点连接到第一行 if (row == 0) { wquuf.union(virtualTopSite, index); } // 将下方的虚拟节点连接到最后一行 if (row == N - 1) { wquuf.union(virtualBottomSite, index); } // 后省略 } public boolean isFull(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } int index = xyTo1D(row, col); return wquuf.connected(index, virtualTopSite); } } 在这里值得注意的是，我们需要事先给两虚拟箱子分配一个值，但不能是负值（笔者在这里就错过），不仅如此还要将不相交集多分配两个以便存放虚拟箱子。\npublic int numberOfOpenSites() 此方法需要我们给出目前有多少个打开的箱子，很容易实现，就像之前的size一样，只要在每次打开一个箱子后加一即可，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Percolation { // 前省略 private int openSiteSum; public Percolation(int N) { // 前省略 this.openSiteSum = 0; } public void open(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } else { if (!grid[row][col]) { grid[row][col] = true; openSiteSum++; } else { return; } } // 后省略 public int numberOfOpenSites() { return openSiteSum; } } public boolean percolates() 此方法需要我们判断此系统是否已经渗流，可以想到，一个系统渗流，就代表其最上方与最下方相连，再根据我们之前所创建的虚拟箱子，很容易写出，\n1 2 3 public boolean percolates() { return wquuf.connected(virtualTopSite, virtualBottomSite); } 但是在这里会出现一个问题，Josh教授给我们指出来了，\n当已存在一个渗流，另一个不满足渗流标准时，就会出现问题，故在这里我们就需要创建一个新的不相交集，此不相交集仅保存上虚拟箱子，而不保存下虚拟箱子，这样在判断isFull的时候就不会有问题了，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class Percolation { // 前省略 private WeightedQuickUnionUF wquufWithBackWash; //后省略 public Percolation(int N) { // 前省略 this.wquufWithBackWash = new WeightedQuickUnionUF(N * N + 1); } public void open(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } else { if (!grid[row][col]) { grid[row][col] = true; openSiteSum++; } else { return; } } int index = xyTo1D(row, col); // 将上方的虚拟节点连接到第一行 if (row == 0) { wquuf.union(virtualTopSite, index); wquufWithBackWash.union(virtualTopSite, index); } // 将下方的虚拟节点连接到最后一行 if (row == N - 1) { wquuf.union(virtualBottomSite, index); } // 现开始考虑四周如果是打开的情况，与之相连 // 上边，原节点至少是第二行 if (row \u0026gt; 0 \u0026amp;\u0026amp; isOpen(row - 1, col)) { wquuf.union(xyTo1D(row - 1, col), index); wquufWithBackWash.union(xyTo1D(row - 1, col), index); } // 下边，原节点至多是倒数第二行 if (row \u0026lt; N - 1 \u0026amp;\u0026amp; isOpen(row + 1, col)) { wquuf.union(xyTo1D(row + 1, col), index); wquufWithBackWash.union(xyTo1D(row + 1, col), index); } // 左边，至少是第二列 if (col \u0026gt; 0 \u0026amp;\u0026amp; isOpen(row, col - 1)) { wquuf.union(xyTo1D(row, col - 1), index); wquufWithBackWash.union(xyTo1D(row, col - 1), index); } // 右边，至多是倒数第二列 if (col \u0026lt; N - 1 \u0026amp;\u0026amp; isOpen(row, col + 1)) { wquuf.union(xyTo1D(row, col + 1), index); wquufWithBackWash.union(xyTo1D(row, col + 1), index); } } public boolean isFull(int row, int col) { if (row \u0026lt; 0 || row \u0026gt; N - 1 || col \u0026lt; 0 || col \u0026gt; N - 1) { throw new IndexOutOfBoundsException(); } int index = xyTo1D(row, col); return wquufWithBackWash.connected(index, virtualTopSite); } } public static void main(String[] args) 关于这个main方法，大家可以写一些自己的测试，但不要删掉也不要不写，否则autograde过不去。\nPercolationStats.java 在此类，就需要我们完成Mento Carol模拟了，具体步骤可以看题目描述，在此不赘述。\n本类一样不会直接给出答案，而是会一步步思考\npublic PercolationStats(int N, int T, PercolationFactory pf) 此构造函数需要我们在N * N的二维数组下完成T次Mento Carol模拟，故我们就需要在这里完成整个模拟过程，而不需要再创建一个其他方法或其他。\n首先看模拟第一步，初始化所有sites并将其设为关闭状态。这就是用我们上文完成的渗流模型即可，值得注意的是，这里参数并没有给我们上文完成的类，而是给了另一个类似于中转站的类，不过也没关系，简单new即可，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class PercolationStats { private int N; private int T; private Percolation p; public PercolationStats(int N, int T, PercolationFactory pf) { this.N = N; this.T = T; if (N \u0026lt;= 0 || T \u0026lt;= 0) { throw new IllegalArgumentException(); } this.threshold = new double[T]; for (int i = 0; i \u0026lt; T; i++) { // 初始化site，全为blocked this.p = pf.make(N); } } 第二步，重复操作，意味着需要循环，\n在所有关闭的site随机选择一个site，意味着需要使用random函数 打开这个site 当渗流完成时，将其比例添加至渗流阈值，意味着我们需要知道公式，以及创建一个新数组 详情可以看题目描述，简单写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class PercolationStats { private int N; private int T; private double[] threshold; private Percolation p; public PercolationStats(int N, int T, PercolationFactory pf) { this.N = N; this.T = T; if (N \u0026lt;= 0 || T \u0026lt;= 0) { throw new IllegalArgumentException(); } this.threshold = new double[T]; for (int i = 0; i \u0026lt; T; i++) { // 初始化site，全为blocked this.p = pf.make(N); while (!p.percolates()) { // 随机打开一个site int randomRow = StdRandom.uniform(N); int randomCol = StdRandom.uniform(N); p.open(randomRow, randomCol); } threshold[i] = (double) p.numberOfOpenSites() / (N * N); } } } public double mean() 此方法需要我们完成渗流阈值样本平均值，题目给出我们提示使用StdStats库即可，里面有求样本平均值的函数，\n1 2 3 public double mean() { return StdStats.mean(threshold); } public double stddev() 此方法与上题一样，求渗流阈值的样本标准差，\n1 2 3 public double stddev() { return StdStats.stddev(threshold); } public double confidenceLow() 此方法求置信区间的左边界，公式题目已写，简单翻译即可，\n1 2 3 public double confidenceLow() { return mean() - ((1.96 * stddev()) / Math.sqrt(T)); } public double confidenceHigh() 此题与上题别无二致，不赘述，\n1 2 3 public double confidenceHigh() { return mean() + ((1.96 * stddev()) / Math.sqrt(T)); } 至此，所有内容均已完成，可以用模拟来看看自己的程序是否对，也可以看看教授给出的模拟后的样子。\n详细内容可以看我的GitHub仓库\n写在后面 本HW一开始确实很难想到，看了Josh教授的提示才能写个七七八八，不过总体来说不难。\n参考资料 「CS61B」Note(1) HW2 Percolation\nCS61B 算法作业：Percolation（蒙特卡洛渗流模拟）的Java 实现\ncs61b实验记录（四）HW2，lab9\n","date":"2025-03-23T00:00:00Z","image":"https://YuTaki23.github.io/p/cs61b-sp18-hw2-percolation/image2_hu_d7fb689556947c4b.png","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-hw2-percolation/","title":"CS61B SP18 HW2 Percolation"},{"content":"写在前面 本Homework取自UCB CS61B SP18的HW1。\n本HW需要我们从十分底层开始一步一步抽象直到最后完成一个模拟音乐的程序，很好的锻炼了我们对于Java项目的组织能力与Java的特性如继承与多态等。\n本文章为笔者在完成了所有任务后返回来写的，并非一步一步的思考，故少了许多碎碎念，多了一分严谨。但是故弟子不必不如师，师不必贤与弟子。若本文章存在错误或更好的想法，欢迎与我联系。\n点这里向我发邮箱~\n具体步骤 Task1: BoundedQueue 本任务向我们介绍了接口的概念，并要求我们完成一个名为BoundedQueue的一个接口，对于接口，我们声明它使用interface关键字，接口不用实现具体方法，只需要给出具体有什么具体方法（除了default）即可。在这里还需要将此接口作为包的一部分存在，大部分内容在任务要求已经告诉我们了，故可得，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package synthesizer; public interface BoundedQueue\u0026lt;T\u0026gt; { /** * @return 返回buffer的size */ int capacity(); /** * @return 返回当前buffer内有多少个items */ int fillCount(); /** * @param x 将x添加到最后 */ void enqueue(T x); /** * @return 删除并返回第一个item */ T dequeue(); /** * @return 返回但不要删除第一个item */ T peek(); } 本任务还要求我们完成两个default方法，十分显然，不赘述，具体可看我在下面写的注释，\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * @return 若当前buffer为空则返回true，否则返回false */ default boolean isEmpty() { return this.fillCount() == 0; } /** * @return 若当前buffer全满返回true，否则返回false */ default boolean isFull() { return this.capacity() == this.fillCount(); } Task 2: AbstractBoundedQueue 本任务要求我们实现一个继承上一个类的抽象类，即加上abstract与implements关键字，同时对于上文实现的两个default方法，需要在这里显式声明一下，并调用super方法其他跟着任务需求即可完成，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package synthesizer; public abstract class AbstractBoundedQueue\u0026lt;T\u0026gt; implements BoundedQueue\u0026lt;T\u0026gt; { protected int fillCount; protected int capacity; @Override public int capacity() { return this.capacity; } @Override public int fillCount() { return this.fillCount; } @Override public boolean isEmpty() { return BoundedQueue.super.isEmpty(); } @Override public boolean isFull() { return BoundedQueue.super.isFull(); } @Override public abstract T peek(); @Override public abstract T dequeue(); @Override public abstract void enqueue(T x); } Task 3: ArrayRingBuffer 本任务以类中TODO注释为顺序解释\nTODO1: Make sure to make this class a part of the synthesizer package 简单的显式声明一下属于这个包即可，\n1 package synthesizer; TODO2: Make sure to make this class and all of its methods public 确保一下类与方法均为public，教授已经帮我们做过了。\nTODO3: Make sure to make this class extend AbstractBoundedQueue\u0026lt; t \u0026gt; 这里改一下，t应该变成大写T，\n1 public class ArrayRingBuffer\u0026lt;T\u0026gt; extends AbstractBoundedQueue\u0026lt;T\u0026gt; TODO4: public ArrayRingBuffer(int capacity) 在这里需要我们完成类的构造函数，根据要求具体需要\n创建一个泛型数组 将first last fillCount均初始化为0 显式将capacity声明一下 对于泛型数组的初始化，需要记住的是强制转换为我们需要的类型，\n1 2 3 4 5 6 7 public ArrayRingBuffer(int capacity) { this.rb = (T[]) new Object[capacity]; this.first = 0; this.last = 0; this.fillCount = 0; this.capacity = capacity; } TODO5: public void enqueue(T x) 在开始这道题之前，需要先了解一下本任务中对队列的使用方法，我们可以将它简单想为一个循环数组，存在两个指针，first与last，初始值均为0，最大值可以到达此buffer的capacity。enqueue为在队列末尾添加一个元素，而每当我们添加一个元素时，就相当于在数组last的位置上添加了这个值，而此时last需要自增，值得注意的是，第一次添加的值的index并不一定是0，可以是任意小于capacity的值，故这里就需要我们考虑指针已经到达capacity了，但前面还没有被填满的情况，这里很想我们在proj1做过的循环头节点，只需要使用取模的方式就可以判断，那如何判断是否已经全部存储完了呢？只需要头指针与尾指针相等的情况下，就说明此时已经全部填完了，\n1 2 3 4 5 6 7 8 9 public void enqueue(T x) { if (isFull()) { throw new RuntimeException(\u0026#34;Ring buffer overflow\u0026#34;); } else { rb[last] = x; fillCount++; last = (last + 1) % capacity; } } TODO6: public T dequeue() 此题的大致内容与上题没什么两样，唯一值得注意的是，在取出队列的值时，是取出最前面的值，这也告诉我们，此时需要维护的是头指针，每去除一个值，头指针就需要自减一次，同样，也会存在到达0了但是后面还有内容没有取出来的情况，故还是需要用到取模，\n1 2 3 4 5 6 7 8 9 10 11 public T dequeue() { if (isEmpty()) { throw new RuntimeException(\u0026#34;Ring buffer underflow\u0026#34;); } else { T result = rb[first]; rb[first] = null; fillCount--; first = (first + 1) % capacity; return result; } } TODO7: public T peek() 此题需要我们仅返回队列第一个的内容，但不删除，简单的数组操作，不赘述，\n1 2 3 4 5 6 7 public T peek() { if (isEmpty()) { throw new RuntimeException(\u0026#34;Ring buffer underflow\u0026#34;); } else { return rb[first]; } } Task 4: GuitarString 本任务以TODO注释作为顺序来解答\nTODO1: Make sure to make this class a part of the synthesizer package 简单的声明包，不赘述，\n1 package synthesizer; TODO2: public GuitarString(double frequency) 本题需要我们创建一个buffer，其capacity为一个特殊值，并将此buffer内的所有值初始化为0，简单的迭代，\n1 2 3 4 5 6 7 8 9 10 public GuitarString(double frequency) { // TODO: Create a buffer with capacity = SR / frequency. You\u0026#39;ll need to // cast the result of this divsion operation into an int. For better // accuracy, use the Math.round() function before casting. // Your buffer should be initially filled with zeros. this.buffer = new ArrayRingBuffer\u0026lt;\u0026gt;((int) Math.round(SR / frequency)); for (int i = 0; i \u0026lt; buffer.capacity(); i++) { buffer.enqueue(0.0); } } TODO3: public void pluck() 本题需要我们将buffer内的值替换为一个[-0.5 - 0.5]的随机数，其中随机数必须每次都不一样，使用Math.Random()即可，简单的迭代，\n1 2 3 4 5 6 7 public void pluck() { for (int i = 0; i \u0026lt; buffer.capacity(); i++) { double r = Math.random() - 0.5; buffer.dequeue(); buffer.enqueue(r); } } TODO4: public void tic() 本题需要我们以Karplus-Algorithm为参考，即将队列的前两个值求平均值并乘能量衰减因子，并将此值替换为队列的前一个值，故这里可以看出来，对于第一个值要取出并返回，第二个值只需要返回即可不需要取出，因此，\n1 2 3 4 5 public void tic() { double firstItem = buffer.dequeue(); double secondItem = buffer.peek(); buffer.enqueue((firstItem + secondItem) * 0.5 * DECAY); } TODO5: public double sample() 本题需要我们返回队列当中的第二个值，但不需要取出，\n1 2 3 public double sample() { return buffer.peek(); } Task 5: Iteration and Exceptions BoundedQueue 修改类声明即可，不赘述\n1 public interface BoundedQueue\u0026lt;T\u0026gt; extends Iterable\u0026lt;T\u0026gt; ArrayRingBuffer 此题需要我们对iterator()的方法进行重写，迭代器包含三个方法，构造函数、hasNext()和next()，根据Josh教授的提示可以知道，\nprivate RingBufferIterator()只需要在这里添加一个计数器，以便之后判断是否到达边界即可。\npublic boolean hasNext()判断之后还有没有元素了，只需要判断此时的计数器是否到达了buffer中已有的元素数量。\npublic T next()求下一个元素的值，简单的数组操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import java.util.Iterator; public Iterator\u0026lt;T\u0026gt; iterator() { return new RingBufferIterator(); } private class RingBufferIterator implements Iterator\u0026lt;T\u0026gt; { private int current; private RingBufferIterator() { this.current = 0; } @Override public boolean hasNext() { return current != fillCount(); } @Override public T next() { T item = rb[current]; current++; return item; } } Exceptions 上文已完成，不赘述。\n详细内容可以看我的GitHub仓库\n关于这里的API Checker，若把关键字改为private则无法编译，故放弃。\n写在后面 总的来说本HW并不难，大多数已经给出步骤，只需要简单翻译即可。\n","date":"2025-03-22T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-hw-1-packages-interfaces-generics-exceptions-iteration/","title":"CS61B SP18 HW 1 Packages, Interfaces, Generics, Exceptions, Iteration"},{"content":"写在前面 本项目取自UCB CS61B SP18的Project1B，整体来说难度不大，主要是考察我们在已给出API的情况下完成任务，这或许是未来工作时很常见的工作流。本文章仅为笔者做题时的想法，如果存在错误或您有更好的想法，欢迎与我联系。\n点这里向我发邮件~\n具体思路 Task 1: Deque Interface 本任务主要是要我们创建一个类，即1A中完成的链表，并通过继承、接口等向我们介绍了Java的特性。笔者为不引发歧义，在这里使用Josh教授的代码，而非自己实现的，如果你对自己的代码有信心，也欢迎直接复制。综上，整体步骤不难，跟着提示一步一步来即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public interface Deque\u0026lt;Item\u0026gt; { public void addFirst(Item item); public void addLast(Item item); public boolean isEmpty(); public int size(); public void printDeque(); public Item removeFirst(); public Item removeLast(); public Item get(int index); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import java.util.LinkedList; import java.util.NoSuchElementException; public class LinkedListDeque\u0026lt;Item\u0026gt; extends LinkedList\u0026lt;Item\u0026gt; implements Deque\u0026lt;Item\u0026gt; { @Override public void printDeque() { System.out.println(\u0026#34;dummy\u0026#34;); } public Item getRecursive(int i) { return get(i); } @Override public Item removeFirst() { try { return super.removeFirst(); } catch (NoSuchElementException e) { return null; } } @Override public Item removeLast() { try { return super.removeLast(); } catch (NoSuchElementException e) { return null; } } } Task 2: wordToDeque 本任务需要我们创建一个新类，其中包括一个新方法，即将一个字符串变成一系列字符，并用链表连接起来，并完成测试，简单的迭代。\n1 2 3 4 5 6 7 8 9 10 public class Palindrome { public Deque\u0026lt;Character\u0026gt; wordToDeque(String word) { Deque\u0026lt;Character\u0026gt; deque = new LinkedListDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; word.length(); i++) { char currentWord = word.charAt(i); deque.addLast(currentWord); } return deque; } } Task 3: isPalindrome Task 3A: isPalindrome Testing 本任务需要我们编写测试，即判断一个字符串是否为回文，运用assertTrue和assertFalse来判断，以下为我编写的测试，可能与你写的不一样，无伤大雅。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testIsPalindromeFalse() { assertFalse(palindrome.isPalindrome(\u0026#34;cat\u0026#34;)); assertFalse(palindrome.isPalindrome(\u0026#34;abc\u0026#34;)); assertFalse(palindrome.isPalindrome(\u0026#34;Aa\u0026#34;)); } @Test public void testIsPalindromeTrue() { assertTrue(palindrome.isPalindrome(\u0026#34;a\u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34;aba\u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34;aa\u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34; \u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34;redder\u0026#34;)); } Task 3B: isPalindrome 本任务就需要我们具体实现这个方法了，思路为，一个字符串的字符数可能为奇数或偶数，只需要第一个与最后一个做判断，然后不断向中间靠拢即可，同时根据题意，还存在一个base case，即字符数为0或1的时候均判断为回文数，不难写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 public boolean isPalindrome(String word) { int length = word.length(); if (length != 0 \u0026amp;\u0026amp; length != 1) { Deque\u0026lt;Character\u0026gt; deque = wordToDeque(word); for (int i = 0, j = deque.size() - 1; i \u0026lt; deque.size() / 2; i++, j--) { if (deque.get(i) != deque.get(j)) { return false; } } } return true; } Task 4: Generalized Palindrome and OffByOne 在这里，题目向我们介绍了不仅有第一个字符与最后一个字符相同称为回文数，还存在其他类型的回文数，比如相差1位也被称为回文数，根据题目的顺序来写，不难写出，\n1 2 3 4 5 6 7 public class OffByOne implements CharacterComparator { @Override public boolean equalChars(char x, char y) { int diff = Math.abs(x - y); return diff == 1; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import org.junit.Test; import static org.junit.Assert.*; public class TestOffByOne { // You must use this CharacterComparator and not instantiate // new ones, or the autograder might be upset. static CharacterComparator offByOne = new OffByOne(); // Your tests go here. @Test public void testEqualCharsTrue() { assertTrue(offByOne.equalChars(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)); assertTrue(offByOne.equalChars(\u0026#39;r\u0026#39;, \u0026#39;q\u0026#39;)); assertTrue(offByOne.equalChars(\u0026#39;\u0026amp;\u0026#39;, \u0026#39;%\u0026#39;)); } @Test public void testEqualCharsFalse() { assertFalse(offByOne.equalChars(\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;)); assertFalse(offByOne.equalChars(\u0026#39;z\u0026#39;, \u0026#39;a\u0026#39;)); assertFalse(offByOne.equalChars(\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;)); } } 1 2 3 4 5 6 7 8 9 10 11 12 public boolean isPalindrome(String word, CharacterComparator cc) { int length = word.length(); if (length != 0 \u0026amp;\u0026amp; length != 1) { Deque\u0026lt;Character\u0026gt; deque = wordToDeque(word); for (int i = 0, j = deque.size() - 1; i \u0026lt; deque.size() / 2; i++, j--) { if (!cc.equalChars(word.charAt(i), word.charAt(j))) { return false; } } } return true; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testIsPalindromeWithCCFalse() { CharacterComparator cc = new OffByOne(); assertFalse(palindrome.isPalindrome(\u0026#34;ac\u0026#34;, cc)); assertFalse(palindrome.isPalindrome(\u0026#34;ok\u0026#34;, cc)); } @Test public void testIsPalindromeWithCCTrue() { CharacterComparator cc = new OffByOne(); assertTrue(palindrome.isPalindrome(\u0026#34;ab\u0026#34;, cc)); assertTrue(palindrome.isPalindrome(\u0026#34;flake\u0026#34;, cc)); assertTrue(palindrome.isPalindrome(\u0026#34;%\u0026amp;\u0026#34;, cc)); assertTrue(palindrome.isPalindrome(\u0026#34; \u0026#34;, cc)); } Task 5: OffByN 最后就要求我们更为通用的实现回文数了，主要包括一个构造函数与一个方法，与OffByOne没什么两样，具体实现如下，\n1 2 3 4 5 6 7 8 9 10 11 12 public class OffByN implements CharacterComparator { private int items; public OffByN(int N) { this.items = N; } public boolean equalChars(char x, char y) { int diff = Math.abs(x - y); return diff == this.items; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import org.junit.Test; import static org.junit.Assert.*; public class TestOffByN { static CharacterComparator offBy5 = new OffByN(5); static CharacterComparator offBy1 = new OffByN(1); @Test public void testEqualCharsFiveTrue() { assertTrue(offBy5.equalChars(\u0026#39;a\u0026#39;, \u0026#39;f\u0026#39;)); assertTrue(offBy5.equalChars(\u0026#39;f\u0026#39;, \u0026#39;a\u0026#39;)); } @Test public void testEqualCharsFiveFalse() { assertFalse(offBy5.equalChars(\u0026#39;h\u0026#39;, \u0026#39;f\u0026#39;)); } } 总的代码实现可以看我的GitHub仓库\n写在后面 总的来说并不难，比上一个1A好多了:(\n","date":"2025-03-15T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-project1b-applying-and-testing-data-structures-version-1.0/","title":"CS61B Project1B Applying and Testing Data Structures version 1.0"},{"content":"[YuTaki] CS61B SP18 Project1A: Data Structure 写在前面 本项目取自CS61B SP18的Project1A，仅为个人做题时的思路及想法，如果有更好的想法，欢迎与我联系。\n点这里向我发邮件\n具体思路 LinkedListDeque public LinkedListDeque() 在最开始初始化链表时，大家就应该把思路理清楚。Josh教授在LinkedListDeque这一部分推荐我们使用两个方法来实现，第一个是two sentinel topology，第二个是circular sentinel topology，在这里笔者使用的方法是第二个也是Josh教授推荐我们使用的方法。\n首先大家先看看上半部分，是初始化链表很重要的一部分，我们可以看出来，在这个类中，存在两个实例变量size和sentinel，以及若干方法，同时还存在一个Nested ClassIntNode，这是十分显而易见的，如果不清楚为什么这么做，建议看一下Josh教授的SLList实现，由此我们就可以写出来一部分代码，即\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class LinkedListDeque\u0026lt;T\u0026gt; { private class IntNode { public IntNode prev; public T item; public IntNode next; public IntNode(IntNode p, T i, IntNode n) { this.prev = p; this.item = i; this.next = n; } } private IntNode sentinel; private int size; } 关键点来了，在做完这些后，就该开始初始化链表了。仔细观察一下，sentinel一共存在三个变量，prev item next，我的想法是，sentinel一直指向的是item，而我们需要做的是将这些箭头用编程语言翻译出来。首先看next的那个箭头，它指向的是prev而prev又指向了item，所以可以翻译为sentinel.next = sentinel，再看prev的箭头，即sentinel.prev = sentinel。由此我们就做完了。\n1 2 3 4 5 6 public LinkedListDeque() { sentinel = new IntNode(null, null, null); sentinel.next = sentinel; sentinel.prev = sentinel; size = 0; } 有同学可能会想，为什么不可以在new的时候就把正确的填上去，而是要加上null，毫无意义。一开始整个节点还没有被创建出来，指向一个不存在的东西或许会造成空指针异常。\npublic void addFirst(T item) 在考虑addFirst时，应该清楚一点，在这里应该使用更为通用的方法，即当前已经存在了一个IntNode，我们需要再另外添加一个，这不会像仅存在一个sentinel一样，具有特殊性。对于此题，画图是一个很好的方法，我在这里简易的画了一个，不喜勿喷。\n我们需要添加的是这个5，一步一步来看。首先要初始化一个IntNode，并且还是添加到第一位，那么一定是sentinel.next = new IntNode()，那么括号里具体应该填什么？我创建的参数第一个为新Node的prev，那现在来看，prev代表的就是sentinel本身；第二个参数为变量item，在此不赘述；第三个参数为next，那现在这个next指向的是原先的sentinel.next。至此，我们两个指向右边的箭头就已经全部翻译完毕。\n接下来看看指向左边的两个箭头。首先第一个箭头，即sentinel.next = sentinel.next.prev；第二个箭头，即sentinel.next.next.prev = sentinel.next。\n而最后一个sentinel.prev的箭头则与一开始没有不同，所以不用变化。\n综上可得，\n1 2 3 4 5 public void addFirst(T item) { sentinel.next = new IntNode(sentinel, item, sentinel.next); sentinel.next.next.prev = sentinel.next; size++; } public void addLast(T item) 本题与上题大差不差，唯一需要变得是sentinel.prev，应该由这个来引出。\n1 2 3 4 5 public void addLast(T item) { sentinel.prev = new IntNode(sentinel.prev, item, sentinel); sentinel.prev.prev.next = sentinel.prev; size++; } public boolean isEmpty() 这道题就很简单了，还记得我们上文提到的size变量吗，每当加一个变量时size++，反之size--，判断size是否为0即可。\n1 2 3 public boolean isEmpty() { return size == 0; } public int size() 与上题类似，不赘述。\n1 2 3 public int size() { return size; } public void printDeque() 打印所有IntNode的item，用空格分开，由size可知共有多少项，需要注意的是，还要判断一个base case，简单的迭代。\n1 2 3 4 5 6 7 8 9 10 public void printDeque() { IntNode currentNode = sentinel.next; if (size == 0) { return; } for (int i = 0; i \u0026lt; size; i++) { System.out.print(currentNode.item + \u0026#34; \u0026#34;); currentNode = currentNode.next; } } public T removeFirst() 首先一个base case，若size == 0 return null。再看看上面的图，对于第一个元素，控制他的一定是sentinel.next，所以要在这上面做文章，首先要把next从sentinel之后的第一个元素改变为第二个元素，即sentinel.next = sentinel.next.next.prev = sentinel，这代表的是第二个元素指向第一个元素变成第二个元素（现在的第一个元素）指向sentinel；其次，现在要把sentinel.next指向原先的第二个元素，即sentinel.next = sentinel.next，综上，\n1 2 3 4 5 6 7 8 9 10 11 public T removeFirst() { if (size == 0) { return null; } else { IntNode currentNode = sentinel.next; sentinel.next.next.prev = sentinel; sentinel.next = sentinel.next.next; size--; return currentNode.item; } } public T removeLast() 与上文相反，举一反三即可，\n1 2 3 4 5 6 7 8 9 10 11 public T removeLast() { if (size == 0) { return null; } else { IntNode currentNode = sentinel.prev; sentinel.prev.prev.next = sentinel; sentinel.prev = sentinel.prev.prev; size--; return currentNode.item; } } public T get(int index) 简单的迭代。\n1 2 3 4 5 6 7 8 9 10 11 public T get(int index) { if (index \u0026gt; size) { return null; } else { IntNode currentNode = sentinel.next; for (int i = 0; i \u0026lt; index; i++) { currentNode = currentNode.next; } return currentNode.item; } } public T getrecursive(int index) 这道题需要我们用递归实现get，只用一个get是没法实现递归的，没办法读取元素，需要添加另一个函数，不断递归到达目的地以读取元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private T getRecursive(int index, IntNode temp) { if (index == 0) { return temp.item; } else { return getRecursive(index - 1, temp.next); } } public T getRecursive(int index) { IntNode currentNode = sentinel.next; if (index \u0026gt;= size) { return null; } else { return getRecursive(index, currentNode); } } ArrayDeque 对于此类，我的想法是首先使用Josh教授特别推荐的circular sentinel，其次先把整体思路写出来，最后再做resize部分。\npublic ArrayDeque() 首先来观察一下这幅图，不难看出，题目首先要求我们将数组初始化为可以存放8个内容的数组；对于此类，还存在四个实例变量，分别是size nextFirst items 以及 nextLast，并且Josh教授还把nextFirst和nextLast分别存为了4和5，不过在这里未来的我回过头告诉我，这里应该把8添加一个变量名，由此可以得出，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class ArrayDeque\u0026lt;T\u0026gt; { private int size; private int nextFirst; private T[] items; private int nextLast; private static final int initCapacity = 8; private int capacity; public ArrayDeque() { this.size = 0; this.nextFirst = 4; this.items = (T[]) new Object[initCapacity]; this.nextLast = 5; } } public void T addLast(T item) 将这幅图与上一幅图相比较，可以看出addLast是如何工作的，原先nextLast是5，而现在所添加的元素，到了数组5的位置，nextLast自增，但是我们想一下特殊情况，如果nextLast到了最后也就是7的位置，这时候再有一个addLast该怎么办呢？slide给出的答案是，nextLast会到0的位置上，由此就可以看出，所添加的元素要放在当前nextLast的位置上，由此，不难写出代码，\n1 2 3 4 5 6 7 8 9 public void addLast(T item) { items[nextLast] = item; if (nextLast == initCapacity - 1) { nextLast = 0; } else { nextLast++; } size++; } public void T addFirst(T item) 与上题大体相似，没有什么不同，在此不做过多赘述。\n1 2 3 4 5 6 7 8 9 public void addLast(T item) { items[nextLast] = item; if (nextLast == initCapacity - 1) { nextLast = 0; } else { nextLast++; } size++; } public boolean isEmpty() 简单的判断。\n1 2 3 public boolean isEmpty() { return size == 0; } public int size() 与上文一样，没有什么不同。\n1 2 3 public int size() { return size; } public void printDeque() 此题需要我们打印整个连边，首先很容易想到有一个base case，当链表里面没有东西的时候，直接返回；其次我们需要明白的一点是，数组01234的顺序并不是我们链表的顺序，所以不能简单的迭代打印整个数组，观察教授给我们的提示，\n我们可以看到现在的链表顺序为右上角的Conceptual Deque，而我们数组的顺序跟这个是不一样的，链表的第一个应该是nextFirst + 1，但这里又会有问题，如果现在nextFirst在最后面该怎么办呢？所以这里又需要我们做一个判断，现在我们知道了初始点，那应该在什么时候结束呢？可以发现，nextFirst会不断自增，直到到达最开始的地方，所以在这里我们就可以用一个变量来表示，这个函数用了很多次，我们不妨把它抽象出来，由此我们上面的函数也可以引用这一层抽象，更新为，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 private int plus(int index) { if (index == capacity) { index = 0; } else { index++; } return index; } private int minus(int index) { if (index == 0) { index = capacity - 1; } else { index--; } return index; } public void addFirst(T item) { items[nextFirst] = item; nextFirst = minus(nextFirst); size++; } public void addLast(T item) { items[nextLast] = item; nextLast = plus(nextLast); size++; } public void printDeque() { if (size == 0) { return; } int index = nextFirst; index = plus(index); while (index != nextFirst) { System.out.print(items[index] + \u0026#34; \u0026#34;); index = plus(index); } } public T removeFirst() 首先一个很明显的base case，链表为空时，return null，根据上图可以看出来，第一个元素是位于nextFirst + 1的元素，首先，我们要把这个元素设为null，然后，还要把nextFirst再往后移动一位，所以不难写出，\n1 2 3 4 5 6 7 8 9 10 public T removeFirst() { if (size == 0) { return null; } int current = plus(nextFirst); nextFirst = current; items[nextFirst] = null; size--; return items[current]; } public T removeLast() 这道题与上一道题差别不大，举一反三即可，\n1 2 3 4 5 6 7 8 9 10 public T removeLast() { if (size == 0) { return null; } int current = minus(nextLast); nextLast = current; items[nextLast] = null; size--; return items[current]; } public T get(int index) 这道题确实没想明白，参考了别人的答案，还是想不通。\nresize 接下来，就应该想想可变数组的想法了。题目告诉我们，对于长度大于等于16的数组，应该一直保持使用系数为25%，即若当前有16个元素，那我们的数组长度应当为64，\n根据这幅图可以看出来，我们需要把前一半元素放在新数组的开头，把后一半元素放在新数组的结尾\nresize对于我来说有点困难了，跳过。\n写在后面 LinkedListDeque不难，看图就可以看个大概。ArrayDeque的resize部分有点困难了，未来再说吧。\n","date":"2025-03-12T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-project1a-data-structure/","title":"CS61B SP18 Project1A Data Structure"},{"content":"[YuTaki] Make Life More Regular——听歌篇 一、写在前面 让生活更有条理性。\n作为Make Life More Regular的第一篇内容，笔者选择了每天都会做的一件事——听歌。\n你是否还在烦恼自己的歌怎么在平台上突然没有版权了？\n你是否还在厌倦听歌时看着不同的人发着不同的“emo文字”？\n本文章仅为笔者自己平时的听歌流，主要方式为将网络音乐下载到本地进行收听，本文章会主要讲解以什么方式下载以及更优雅的设置听歌方式。\n本文章仅代表笔者个人观点，主观性很强，一千个读者有一千个哈姆雷特。\n若本文章出现了什么错误或您有更好的想法，欢迎与我联系。\n[点这里向我发邮箱~](mailto: yutaki23@163.com)\n二、运行设备与主要应用 操作系统：Android12 OriginOS Salt Palyer 极其优秀的安卓本地音乐播放器，其简洁但不失重要功能深受笔者喜爱。 bilidown 一款简洁易下载哔哩哔哩视频的软件。应作者要求，在此不贴上软件地址，有需要的请自行寻找。 MusicTag 可将本地音乐的歌曲名、作者、专辑、歌词等信息作为元数据导入到歌曲中。在Salt Player中可以读取出来。 三、主要优点与缺点 优点 长期存在。不用再担心自己的歌曲会被版权收掉，只要歌曲一直存在本地，只要硬盘不损坏，歌曲就不会有丢失的一天。 简单干净的页面。不用在听歌的时候看网友所谓的“丧语录”。 缺点 对新歌的感知弱。新歌发布后无法第一时间接收到消息，只能由他人推荐，或自己随缘找到。 四、操作步骤 **找到你喜欢的歌。**一般来说，大家喜欢听的歌都可以在互联网上找到，包括但不限于哔哩哔哩、抖音、YouTube等媒体播放网站。笔者在这里以哔哩哔哩和《麦恩莉》为例。将这首歌的网站复制下来，得到类似于这样的https://www.bilibili.com/video/BVxxxxxx/1一个网站。 下载歌曲。打开bilidown。将网站复制进去，即可得到类似于这样的界面。随后点击音频按钮即可开始下载，注意到，可以提前将音质调为192k，这样音质会更好。之后，会调出下载界面，此处笔者建议统一将文件名改为歌曲名-作者.m4a，这都是为了之后添加歌曲信息时更加方便。 **将元数据导入到歌曲中。**打开MusicTag，会看到这些内容，作为使用了很长时间的人来说，我给出的建议是： **改变工作目录。**将其改为你下载歌曲的文件夹。 自动匹配标签。全选你所下载的歌曲，让软件自动识别其标题、艺术家等内容。 检查。大致查看各元数据是否能对的上，如果不，单独找出来在左侧修改错误的内容，如果是封面错误，点击改变封面选择正确的封面，如果是歌词错误，点击改变歌词选择正确的歌词。笔者的经验是，如果一首歌的封面错误，那大概率歌词也有错，其他信息大概率都有错。最后不要忘记右键保存。 将歌曲传到手机上。笔者的建议为在手机上创建一个Music文件夹，用来专门存放下载的歌曲。打开Salt Player，点击左上角，左侧会出现扫描音乐选项，使用自定义文件夹，将其设置为下载歌曲的文件夹，点击开始扫描。\n**Congratulation!**此时，你就可以发现，你的歌曲已经到了Salt Player里面，并且标题、作者、专辑、封面等内容应有尽有。\n五、写在后面 大致的操作步骤就这些，有关这些应用的其他进阶操作，欢迎各位自己摸索。\n最后，感谢每一位创建这些软件的作者，希望大家尊重开源，享受开源。开源世界有你更精彩。\n六、相关问题 **问：**我只能使用各大网站下载的歌曲吗？\n答：当然不，如果你能找到Flac等更高级的格式当然是最好不过，但请不要在手机上直接下载听歌软件上的歌曲，大部分都有加密，过了VIP期限后就无法再听了。\n问：为什么后缀一定要改成m4a的格式，改成其他的不行吗？\n答：根据笔者尝试，使用mp3格式时会在将元数据导入歌曲中出现问题，其他格式还没有尝试过，有尝试过的朋友可以补充。\n问：为什么要在手机上创建一个新的文件夹？\n答：现在人的手机上大概率会有录音等其他非歌曲内容，Salt Player在识别的时候会将这些内容也识别为歌曲，而创建一个文件夹就可以让Salt Player只识别当前文件夹的内容。\n此网站非正确网站，在此仅为示例，替换成你所找到的歌曲的网站即可。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-03-12T00:00:00Z","permalink":"https://YuTaki23.github.io/p/make-life-more-regular-%E5%90%AC%E6%AD%8C%E7%AF%87/","title":"Make Life More Regular —— 听歌篇"},{"content":"写在前面 本项目取自 UCB CS61B SP18的Project0: NBody Simulation。作为CS61系列的第二门课，专注于数据结构与算法，本项目只是对Java有了个简单的认识。以下为笔者做题时的心得体会，如有错误或更好的想法，欢迎与我联系。\n点这里向我发邮件~\n具体实现 ###The Planet Class and Its Constructor\n这道题让我们了解了Planet这个类具体代表什么，存在哪些参数，还需要创建两个构造函数，两个拥有不同参数的构造函数。\n创建实例变量。在这个类里面按照题目要求一步一步写即可。 创建构造函数1。这个构造函数存在六个不同的参数，按照题目要求写好签名，在构造函数内部使用this即可完成。 创建构造函数2.这个构造函数存在一个参数，即一个已被实例化的Planet，需要将此Planet复制到新Planet中，使用this与p.点表达式即可完成。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Planet { public double xxPos; public double yyPos; public double xxVel; public double yyVel; public double mass; public String imgFileName; public Planet(double xP, double yP, double xV, double yV, double m, String img) { this.xxPos = xP; this.yyPos = yP; this.xxVel = xV; this.yyVel = yV; this.mass = m; this.imgFileName = img; } public Planet(Planet p) { this.xxPos = p.xxPos; this.yyPos = p.yyPos; this.xxVel = p.xxVel; this.yyVel = p.yyVel; this.mass = p.mass; this.imgFileName = p.imgFileName; } } Understanding the Physics 在这里题目向我们介绍了此项目用到的物理知识，都是简单的高中物理知识，我在这里简单说一下。\n万有引力公式。两个粒子之间存在相互吸引的力，大小为$F = \\dfrac{G \\cdot m_1 \\cdot m_2}{r^2}$，方向指向对方。 勾股定理。$r^2 = dx^2 + dy^2$。 在x轴上的力。$F_x = \\dfrac{F \\cdot dx}{r}$。 在y轴上的力。$F_y = \\dfrac{F \\cdot dy}{r}$。 合外力。即同一方向上的力的和。 加速度。$a_x = \\dfrac{F_x}{m}$ $a_y = \\dfrac{F_y}{m}$。 Writing the Planet Class calcDistance 此方法需要我们计算两行星之间的距离，运用勾股定理即可，值得注意的是，此题需要我们在一个Planet上使用点表达式来对另一个行星求解，也就是说，此题无法用static关键字。\n1 2 3 4 5 6 7 8 9 10 public double calcDistance(Planet p) { double x1 = this.xxPos; double y1 = this.yyPos; double x2 = p.xxPos; double y2 = p.yyPos; double xAbs = Math.abs(x1 - x2); double yAbs = Math.abs(y1 - y2); return Math.sqrt((xAbs * xAbs) + (yAbs * yAbs)); } clacForceExertedBy 此方法需要我们计算两行星之间的万有引力，运用上文提到的万有引力公式即可，值得注意的是，此题向我们介绍了一个新的语法static final也即常量，同时也介绍了科学计数法的写法。在这里我们可以将万有引力常数G用科学计数法设为常量。\n1 2 3 4 5 private static final double G = 6.67e-11; public double calcForceExertedBy(Planet p) { double radiusSquare = this.calcDistance(p) * this.calcDistance(p); return (G * this.mass * p.mass) / radiusSquare; } calcForceExertedByX and calcForceExertedByY 此方法需要我们计算两行星之间在x轴方向与在y轴方向上的力，用到的公式即为上文中的3 4两条，值得注意的是，在计算两行星之间的位移差时要注意哪个在前哪个在后。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public double calcForceExertedByX(Planet p) { double distanceX = p.xxPos - this.xxPos; double force = this.calcForceExertedBy(p); double radius = this.calcDistance(p); return (force * distanceX) / radius; } public double calcForceExertedByY(Planet p) { double distanceY = p.yyPos - this.yyPos; double force = this.calcForceExertedBy(p); double radius = this.calcDistance(p); return (force * distanceY) / radius; } calcNetForceExertedByX and calcNetForceExertedByY 此方法需要我们完成一系列行星对一个行星所施加的x轴与y轴方向的合分力（不知道也没有这个东西），值得注意的是，可以用到enhanced for来锻炼自己，以及continue用法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public double calcNetForceExertedByX(Planet[] planets) { double sumForce = 0; for (Planet p : planets) { if (this.equals(p)) { continue; } else { sumForce += this.calcForceExertedByX(p); } } return sumForce; } public double calcNetForceExertedByY(Planet[] planets) { double sumForce = 0; for (Planet p : planets) { if (this.equals(p)) { continue; } else { sumForce += this.calcForceExertedByY(p); } } return sumForce; } update 此方法需要我们计算经过一系列力之后，行星最终会到什么地方去，看着题目很长，实际上很简单，跟着题目给的步骤一步一步做即可，值得注意的是，此题不需要返回任何东西，只是在目前行星更新自己。\n1 2 3 4 5 6 7 8 9 10 public void update(double dt, double fX, double fY) { double accelerationX = fX / this.mass; double accelerationY = fY / this.mass; this.xxVel += dt * accelerationX; this.yyVel += dt * accelerationY; this.xxPos += dt * this.xxVel; this.yyPos += dt * this.yyVel; } Getting Started with the Simulator (NBody.java) ReadRadius 此题需要我们读取一个文件中的半径，根据题目可知，半径在一个文件中的第二位，以double形式存储。观察BasicInDemo.java不难发现，对于In这个类来说，是按顺序来查找文件中的每个变量，并且要以符合的形式来控制，值得注意的是，在这里要加上static关键字，综上易得。\n1 2 3 4 5 public static double readRadius(String filename) { In in = new In(filename); int firstItemInFile = in.readInt(); return in.readDouble(); } ReadPlanets 此题与上题类似，需要我们用In来不断读取内容，得到Planet的全部内容，并将其实例化为一个新的Planet，这里会用到Planet的构造函数1，可以得到，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static Planet[] readPlanets(String filename) { In in = new In(filename); int totalPlanets = in.readInt(); Planet[] planets = new Planet[totalPlanets]; double radius = in.readDouble(); for (int i = 0; i \u0026lt; totalPlanets; i++) { double xP = in.readDouble(); double yP = in.readDouble(); double xV = in.readDouble(); double yV = in.readDouble(); double m = in.readDouble(); String img = in.readString(); planets[i] = new Planet(xP, yP, xV, yV, m, img); } return planets; } Drawing the Initial Universe State (main) Collecting All Needed Input 跟着步骤一步一步来即可，很容易。\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) { String TString = args[0]; String dtString = args[1]; String filename = args[2]; double T = Double.parseDouble(TString); double dt = Double.parseDouble(dtString); Planet[] planets = readPlanets(filename); double radius = readRadius(filename); } Drawing the Background 观察StdDrawDemo.java即可知道如何创建scale与background，跟着Demo走即可。\n1 2 3 4 5 6 private static final String imgPath = \u0026#34;images/starfield.jpg\u0026#34;; StdDraw.setScale(-radius, radius); StdDraw.clear(); StdDraw.picture(0, 0, imgPath); StdDraw.show(); Drawing One Planet 使用StdDraw.picture()即可，题目要求在行星自己的位置上画自己，即xxPos与yyPos和imgFileName.\n1 2 3 public void draw() { StdDraw.picture(xxPos, yyPos, \u0026#34;images/\u0026#34; + imgFileName); } Drawing All of the Planets 简单的迭代\n1 2 3 for (Planet planet : planets) { planet.draw(); } Creating an Animation 步骤都给出来了，写到后面也累了，大家自己看看吧（逃）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 StdDraw.enableDoubleBuffering(); double time = 0; while (time \u0026lt; T) { double[] xForces = new double[planets.length]; double[] yForces = new double[planets.length]; for (int i = 0; i \u0026lt; planets.length; i++) { xForces[i] = planets[i].calcNetForceExertedByX(planets); yForces[i] = planets[i].calcNetForceExertedByY(planets); } for (int j = 0; j \u0026lt; planets.length; j++) { planets[j].update(dt, xForces[j], yForces[j]); } StdDraw.clear(); StdDraw.picture(0, 0, imgPath); for (Planet planet : planets) { planet.draw(); } StdDraw.show(); StdDraw.pause(10); time += dt; 写在后面 本项目已完成，用时大约四小时，当然这也不是我第一次做:( ，作为第二个复习课程的第一个项目，整体难度并不大，大部分代码框架与提示都已给出，跟着题目走即可。\n点这里查看GitHub代码\n","date":"2025-03-08T00:00:00Z","image":"https://YuTaki23.github.io/p/cs61b-sp18-project0-nbody-simulation/image1_hu_d8ded748ccf5e499.png","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-project0-nbody-simulation/","title":"CS61B SP18 Project0 Nbody Simulation"},{"content":"写在前面 本项目为UC Berekly CS61A SP24的 Project4: Scheme。以下为个人对此项目的见解，如有错误或更好的解决方案，欢迎与我联系。\n点这里向我发邮件~\n具体思路 Problem 1 首先通读一下题目，此题需要我们完成两个函数define和lookup，同时给了我们关于Frame的一些信息，Frame有两个instance attribute。\nbindings 这是一个字典，回顾一下字典的相关内容，字典，相当于其他语言的map，存在一个key和一个value，每个字典当中只能有一个唯一的key，但key中存放的数据可以是相同的。此题中，key就代表的是symbol，而value代表的就是其本意，相当于我们在python当中的等号赋值用法，例如，x = 3在这里key就是x，value就是3。 parent 每个frame都可以被嵌套在另一个frame里面，而他们最终的frame都是None。 define 非常显而易见了，上文中也提到过，在此不再赘述。\n1 2 3 def define(self, symbol, value): \u0026#34;\u0026#34;\u0026#34;Define Scheme SYMBOL to have VALUE.\u0026#34;\u0026#34;\u0026#34; self.bindings[symbol] = value lookup 此函数可以想成三个case，题目当中也给了我们很详细的描述。\n若symbol在当前frame里，直接返回value。 若symbol不在当前frame里，且其含有父frame，且父frame里含有此symbol，返回value。关于这个case，有几点需要说明 其含有父frame。问：如何界定此frame是否合法？答：只要不为None，都是合法的。 父frame里含有symbol。问：如何访问父frame？答：用点表达式访问parent即可。 若均不满足以上情况，即symbol不在当前frame里，且没有父frame，arise error。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def lookup(self, symbol): \u0026#34;\u0026#34;\u0026#34;Return the value bound to SYMBOL. Errors if SYMBOL is not found.\u0026#34;\u0026#34;\u0026#34; current_frame = self # case1 若symbol在当前frame if symbol in current_frame.bindings: return current_frame.bindings.get(symbol) # case2 symbol不在当前frame 但在parent frame else: current_frame = current_frame.parent while current_frame is not None: if symbol in current_frame.bindings: return current_frame.bindings.get(symbol) current_frame = current_frame.parent # case3 都不存在 引发error raise SchemeError(\u0026#39;unknown identifier: {0}\u0026#39;.format(symbol)) Problem 2 首先通读一下题目，此题要求我们实现一个scheme_apply函数中的一个case，即BuiltinProcedure。在完成一个表达式时，存在内置的一些操作如 + - * /等，在此，就需要我们实现这些操作。\nBuiltinProcedure含有两个instance attribute。\npy_func 找到对应的操作符号，用python的内置函数来实现表达式，不用我们自己实现（自己似乎也实现不了，有点不切实际）。 need_env 有些内置函数需要特定的环境。 此题可分为三个步骤来写，题目中也给的很清楚。\n将scheme list 转变为python list，与上题很类似。 判断need_env的是否，很简单。 使用*args表示法来调用py_func这里可能需要了解一下什么是 *args表示法。 1 2 3 4 5 6 7 8 9 10 11 12 13 try: # 将scheme list转变为 python list lst = [] while args is not nil: lst.append(args.first) args = args.rest # 判断 need_env if procedure.need_env is True: lst.append(env) # 调用 py_func return procedure.py_func(*lst) except TypeError as err: raise SchemeError(\u0026#39;incorrect number of arguments: {0}\u0026#39;.format(procedure)) Problem 3 此题需要让我们将scheme_eval补充完整，大致题目已给出，我们需要完成的是判断此表达式，并通过上文完成的scheme_apply函数来计算结果。题目还是给了我们大致思路。\n判断operator，使用递归。Recrusion，即自身调用自身，那一定是在scheme_eval函数里调用scheme_eval。对于此函数，我们需要三个参数，expresson environment以及一个默认参数，文中给了我们代码提示first = expr.first，由此即可以判断此处的expression = first，同时还要求我们evaluate to a procedure instance。scheme_apply的开头就给了我们提示 判断operands，依旧使用递归。与上文类似，题目已经给了我们rest = expr.next，同时题目要求我们收集到scheme列表里，下文有提示，使用Pair的map方法，观察map方法，这提供了一个形参fn，显然此处的fn就是scheme_eval，但scheme_eval存在两个形参，这就需要我们进行转换，使用lambda函数。 之后就是调用scheme_apply，很显然，在此不做过多赘述。 1 2 3 4 5 6 7 else: # evaluate operator procedure = scheme_eval(first, env) validate_procedure(procedure) # evaluate operand operands = rest.map(lambda x: scheme_eval(x, env)) return scheme_apply(procedure, operands, env) Problem 4 此题要求我们实现define，简单来说，就是将一个expressions赋值给一个symbol。我们在这里只需要实现第一个部分，即计算一个表达式作为expressions并复制给一个提供给我们的symbol，下方还有提示，需要我们用到Frame里的define。那我们想一想define函数需要我们提供什么参数呢？\nsymbol symbol总是存在于一个表达式的第一位，函数也给了我们一个提示，即signature = expressions.first，由此我们就可以看出我们的symbol就是这个。 expressions 对于一个表达式来说，我们需要赋值的不仅仅是表达式本身，还是它计算后的数值是什么，所以在这里我们还需要用到上文完成的scheme_eval函数。 最后，需要我们返回已绑定的symbol。 1 2 3 4 5 6 signature = expressions.first if scheme_symbolp(signature): # assigning a name to a value e.g. (define x (+ 1 2)) validate_form(expressions, 2, 2) # Checks that expressions is a list of length exactly 2 env.define(signature, scheme_eval(expressions.rest.first, env)) return signature Problem 5 此题向我们描述了quote的用法，在此不做过多赘述，详情可看题目要求。在此仅讲讲需要实现的功能。\n给出一段expressions，需要我们原封不动的返回，但对于Pair来说，不返回nil，由此可见，需要返回的是expressions.first。\n1 2 validate_form(expressions, 1, 1) return expressions.first Congratulation! 第一部分已完成\nProblem 6 此题我们需要完成Scheme中的一个特殊形式begin。\nbegin 用于按顺序组合多个表达式，并返回最后一个表达式的值。例如，\n1 2 3 4 (begin (display \u0026#34;Hello\u0026#34;) ; 执行第一个表达式（输出 \u0026#34;Hello\u0026#34;） (display \u0026#34;World\u0026#34;) ; 执行第二个表达式（输出 \u0026#34;World\u0026#34;） (+ 1 2)) ; 返回最后一个表达式的值 3 那由此我们可以观察到，它会将所有表达式都执行一遍，但只返回最后一个表达式的值，是不是有点像我们说的递归的概念，不断的完成一个动作，直到最后一个动作再返回。由此我们就可以写出代码。\n首先有一个 base case 若此表达式为空，返回None。 开始递归。首先我们想一想，想要evaluate一个表达式，应该怎么做？答：用上文完成的scheme_eval函数。 如何判断是否到达了递归终点？对于一个expressions来说，它就像一个链表，最后一项的rest总是nil，这就到达了递归终点，也就是我们说的base case。 对于recrusion case 来说，我们要不断的调用自身，直到到达base case。 1 2 3 4 5 6 7 8 if expressions is nil: return None exp = scheme_eval(expressions.first, env) if expressions.rest is nil: return exp else: return eval_all(expressions.rest, env) Problem 7 此题依旧需要我们完成Scheme中的一个特殊形式lambda。\nlambda 用于定义匿名函数，此题要求我们逐步计算表达式，并返回最后一个表达式的值。\n其中，LambdaProcedure这个类存在一个实例body，存放的是scheme list，而实例formals存放的是正确的Pair嵌套表达式。\n我们需要做的是创建并返回一个LambdaProcedure实例，那整体思路就很明朗的，再加上此函数还有给我们的提示，使用特定的语法知识，易得。\n1 2 body = expressions.rest return LambdaProcedure(formals, body, env) Problem 8 此题需要我们创建一个新的Frame，其中含有两个参数，formals vals，均为scheme list，需要我们将每一个formal对应到val，且formals于vals的数量都是相等的，一一对应，直到达到scheme list的终点即可。值得注意的是，不是简单的复制父Frame里的内容，笔者在这里第一次就想错了，总的来说，题目已经告诉我们具体做法，在此不做过多赘述。\n1 2 3 4 5 6 child_frame = Frame(self) while formals is not nil: child_frame.define(formals.first, vals.first) formals = formals.rest vals = vals.rest return child_frame Problem 9 此题需要我们完成scheme_apply里的一个LambdaProcedure case，题目已经给出提示，即\n创建一个新Frame，注意到，要想创建一个新的Frame，就应该想到用谁来创建，不能是Procedure本身，因为make_child_frame是在Frame类中实现的，所以应该找到一个Frame，即Procedrure.env 将形参绑定到参数值，想一想，对于一个Procedure来说，存在两个实例，即formals和body，而formals对应的就是make_child_frame中的formals，而body对应的就是eval_all中的expressions。 在当前Frame进行计算，也就是说此时的env应该变成我们创建的新Frame 综上易得，\n1 2 child_frame = procedure.env.make_child_frame(procedure.formals, args) return eval_all(procedure.body, child_frame) Problem 10 此题需要我们完成define的一种新类型，题目已经给了详尽的步骤，在这里讲几个笔者踩到的坑。\n想清楚symbol formals body分别代表什么，首先想明白，signature与expression之间的关系，signature代表的是expression的第一个内容，也就是函数名，而其中symbol也叫函数，也就是signature.first，之后再想想formals，就是除了define和函数名剩下的内容，而body则代表的是除了define之外的所有内容，想清楚这五个之间的关系，对于这道题十分关键。 题目告诉我们可以使用do_lambda_form，但笔者试了很多次也没有找到方法，若有人有更好的意见欢迎与我联系。 在找到正确的formals后还需要使用validate_formals()函数来判断其正确性。 综上可知，\n1 2 3 4 5 6 symbol = signature.first formals = signature.rest validate_formals(formals) body = expressions.rest env.define(symbol, LambdaProcedure(formals, body, env)) return symbol Problem 11 这道题看着题目很长很难，但其实是纸老虎，根据它的题意来即可。\n看看MuProcedure可以发现需要两个参数，formals和body，formals题目已经给出，指的是expressions的第一个内容，而body就是除了第一个内容的其他内容。 完成scheme_apply的mu case，这个内容跟上文的lambda case如出一辙，有区别的是，Frame的区别，因为mu是动态的，所以它的Frame一直在变，就不需要再用Procedure的Frame了。 综上可知，\n1 return MuProcedure(formals, expressions.rest) 1 2 child_frame = env.make_child_frame(procedure.formals, args) return eval_all(procedure.body, child_frame) Part 2 已完成！\nProblem 12 这道题需要我们完成两个函数do_and_form和do_or_form，这两个函数从形式上来说都很相似，所以放在一起做，读题目可知，expressions会给出不定量个内容，我们需要判断每个内容的正确性来判断应返回什么，值得注意的是，对于and和or来说，存在一个关键的地方短路，每当遇到一个合适的内容时，就会舍弃后面的所有内容，仅返回当前内容。\n因此，对于此题来说，递归是个很好的办法，具体步骤如下。\nbase case 1 若expression为空，则返回特定值。 base case 2 每当我们判断出来的当前内容的正确性，则直接返回。 base case 3 当所有内容都判断完毕后还没有找到正确性，则返回最后一个内容。 recrusion case 不断对下一个内容执行当前函数。 代码如下，\n1 2 3 4 5 6 7 8 9 10 11 12 def do_and_form(expressions, env): if expressions is nil: return True currency = scheme_eval(expressions.first, env) if is_scheme_true(currency): if expressions.rest is nil: return currency else: return do_and_form(expressions.rest, env) else: return currency 1 2 3 4 5 6 7 8 9 10 11 12 def do_or_form(expressions, env): if expressions is nil: return False currency = scheme_eval(expressions.first, env) if is_scheme_false(currency): if expressions.rest is nil: return currency else: return do_or_form(expressions.rest, env) else: return currency Problem 13 此题需要我们完成cond，题目也给了我们描述。返回第一个表达式为true的值，若都不是正确的，那么就返回else表达式也就是最后一个表达式的值，这也是一个递归步骤，因此可知步骤为，\nbase case 判断到最后一个表达式，若还没有判断出来，则返回此表达式的值。 recrusion case 从第一个表达式开始逐步判断。 1 2 3 4 if clause.rest is nil: return test else: return eval_all(clause.rest, env) Problem 14 这道题确实没看懂什么意思，在此也不误人子弟了。\n点这里看总的代码实现\n写在后面 后续的题目就不再做了，是关于Scheme的。\n作为UCB的CS61系列的第一门课，在当时还是初学者的我留下了很深的心理阴影，Scheme这个项目也一直停着没有做，这次重新捡回来，也算是给自己的一个交代。\n至此，CS61A结束。\nYuTaki\n2025年3月7日写于博学楼\n","date":"2025-03-07T00:00:00Z","image":"https://YuTaki23.github.io/p/cs61a-sp24-scheme/image1_hu_7934f1e6f9243d37.png","permalink":"https://YuTaki23.github.io/p/cs61a-sp24-scheme/","title":"CS61A SP24 Scheme"}]