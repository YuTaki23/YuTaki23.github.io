<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="CS106L的课程笔记">
<title>CS106L Winter2025 NOTES</title>

<link rel='canonical' href='https://YuTaki23.github.io/p/cs106l-winter2025-notes/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="CS106L Winter2025 NOTES">
<meta property='og:description' content="CS106L的课程笔记">
<meta property='og:url' content='https://YuTaki23.github.io/p/cs106l-winter2025-notes/'>
<meta property='og:site_name' content='YuTaki&#39;s Ideas'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='C&#43;&#43;' /><meta property='article:tag' content='学习笔记' /><meta property='article:published_time' content='2025-04-06T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2025-04-06T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="CS106L Winter2025 NOTES">
<meta name="twitter:description" content="CS106L的课程笔记">
    <link rel="shortcut icon" href="/logo.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_b4750235e08b003b.png" width="300"
                            height="264" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">&lt;/&gt;</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">YuTaki&#39;s Ideas</a></h1>
            <h2 class="site-description">代码与歌</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/YuTaki23'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg t="1742388666084" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6728" width="200" height="200"><path d="M850.346667 155.008a42.666667 42.666667 0 0 0-22.741334-23.509333c-8.704-3.754667-85.717333-33.322667-200.32 39.168H396.714667c-114.773333-72.618667-191.701333-42.922667-200.32-39.168a42.88 42.88 0 0 0-22.741334 23.466666c-26.197333 66.218667-18.048 136.448-7.850666 176.896C134.272 374.016 128 413.098667 128 469.333333c0 177.877333 127.104 227.882667 226.730667 246.272a189.568 189.568 0 0 0-13.013334 46.549334A44.373333 44.373333 0 0 0 341.333333 768v38.613333c-19.498667-4.138667-41.002667-11.946667-55.168-26.112C238.08 732.416 188.330667 682.666667 128 682.666667v85.333333c25.002667 0 65.365333 40.362667 97.834667 72.832 51.029333 51.029333 129.066667 55.253333 153.386666 55.253333 3.114667 0 5.376-0.085333 6.528-0.128A42.666667 42.666667 0 0 0 426.666667 853.333333v-82.090666c4.266667-24.746667 20.224-49.621333 27.946666-56.362667a42.666667 42.666667 0 0 0-23.125333-74.581333C293.333333 624.554667 213.333333 591.488 213.333333 469.333333c0-53.12 5.632-70.741333 31.573334-99.285333 11.008-12.117333 14.08-29.568 7.978666-44.8-4.821333-11.904-18.773333-65.450667-6.485333-117.546667 20.650667-1.578667 59.904 4.565333 113.706667 40.96C367.104 253.44 375.466667 256 384 256h256a42.666667 42.666667 0 0 0 23.936-7.338667c54.016-36.522667 92.970667-41.770667 113.664-41.130666 12.330667 52.224-1.578667 105.770667-6.4 117.674666a42.666667 42.666667 0 0 0 8.021333 44.928C805.077333 398.464 810.666667 416.085333 810.666667 469.333333c0 122.581333-79.957333 155.52-218.069334 170.922667a42.666667 42.666667 0 0 0-23.125333 74.709333c19.797333 17.066667 27.861333 32.469333 27.861333 53.034667v128h85.333334v-128c0-20.437333-3.925333-38.101333-9.770667-53.12C769.92 695.765333 896 643.712 896 469.333333c0-56.362667-6.272-95.530667-37.76-137.514666 10.197333-40.405333 18.261333-110.506667-7.893333-176.810667z" fill="#ffffff" p-id="6729"></path></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='mailto:yutaki23@163.com'
                        target="_blank"
                        title="邮箱"
                        rel="me"
                    >
                        
                        
                            <svg t="1742537424403" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2705" width="200" height="200"><path d="M838.954667 234.666667H170.666667c-3.626667 0-7.168 0.448-10.56 1.322666l323.690666 323.669334a21.333333 21.333333 0 0 0 30.165334 0L838.954667 234.666667z m46.144 14.186666l-260.693334 260.693334 262.933334 262.912c5.44-7.168 8.661333-16.106667 8.661333-25.792V277.333333c0-10.944-4.117333-20.906667-10.88-28.48zM843.861333 789.333333l-249.6-249.621333-50.133333 50.133333a64 64 0 0 1-90.517333 0l-50.112-50.133333L156.373333 786.88c4.48 1.578667 9.28 2.453333 14.314667 2.453333h673.194667zM128.661333 754.218667L373.333333 509.525333 129.578667 265.813333A42.709333 42.709333 0 0 0 128 277.333333v469.333334c0 2.56 0.213333 5.098667 0.661333 7.552zM170.666667 192h682.666666a85.333333 85.333333 0 0 1 85.333334 85.333333v469.333334a85.333333 85.333333 0 0 1-85.333334 85.333333H170.666667a85.333333 85.333333 0 0 1-85.333334-85.333333V277.333333a85.333333 85.333333 0 0 1 85.333334-85.333333z" fill="#ffffff" p-id="2706"></path></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://www.zhihu.com/people/yutaki-61'
                        target="_blank"
                        title="知乎"
                        rel="me"
                    >
                        
                        
                            <svg t="1742384826142" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2995" width="200" height="200"><path d="M544.949 561.422s0-71.387-34.779-75.050c-34.779-3.663-142.775 0-142.775 0v-219.654h161.078s-1.83-73.219-32.949-73.219h-261.755l43.93-117.148s-65.897 3.663-89.692 45.761-98.844 252.604-98.844 252.604 25.627 10.983 67.726-20.134c42.101-31.116 56.743-86.033 56.743-86.033l76.879-3.663 1.83 223.316s-133.621-1.83-161.078 0c-27.457 1.83-42.101 75.050-42.101 75.050h203.182s-18.307 124.47-69.557 214.164c-53.085 89.692-151.929 161.078-151.929 161.078s71.387 29.287 140.947-10.983c69.557-42.101 120.811-223.316 120.811-223.316l162.912 203.182s14.643-97.013-1.83-124.47c-18.307-27.457-113.49-137.283-113.49-137.283l-42.101 36.607 29.287-120.811h177.552zM587.050 188.010l-1.83 660.793h65.897l23.795 82.37 115.321-82.37h162.912v-660.793h-366.091zM879.92 775.584h-76.879l-97.013 75.050-21.965-75.050h-20.134v-512.527h215.991v512.527z" fill="#ffffff" p-id="2996"></path></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://space.bilibili.com/45550397'
                        target="_blank"
                        title="哔哩哔哩"
                        rel="me"
                    >
                        
                        
                            <svg t="1742384990540" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5704" width="200" height="200"><path d="M278.8864 148.1728c14.336-8.192 32.6144-9.3696 47.8208-2.6624 11.3664 4.6592 19.968 13.824 29.184 21.6064 38.144 32.9216 75.9808 66.304 114.2784 99.0208h80.4352c38.2976-32.768 76.0832-66.048 114.2272-98.9696 9.2672-7.7824 17.8688-16.896 29.2864-21.6576 14.7456-6.5024 32.4608-5.632 46.592 2.048 16.5888 8.5504 28.1088 26.2656 28.8256 44.9536 1.024 13.568-3.84 27.2896-12.3392 37.7856-7.5264 8.3456-16.5376 15.2064-24.8832 22.6816-5.3248 4.4032-10.1376 9.5232-16.0256 13.2096 23.6544 0 47.2576-0.256 70.912 0.1536 31.1296 0.8192 61.44 14.592 82.8928 37.1712 22.6304 22.2208 35.5328 53.5552 35.4816 85.1968 0.1024 108.4416 0 216.9344 0.0512 325.376-0.1024 16.384 0.8192 33.024-2.816 49.152-6.656 32.9728-28.8256 61.5936-56.9856 79.36a121.344 121.344 0 0 1-64.7168 17.7664H263.2704c-16.9984-0.1024-34.2528 0.8704-50.9952-2.8672-32.1024-6.4512-60.0064-27.648-77.824-54.6304a121.088 121.088 0 0 1-19.2512-66.9696v-321.536c0.1024-16.5376-0.9216-33.1776 2.4576-49.408 10.24-52.9408 58.9312-96.1024 112.9984-98.4576 24.6272-0.768 49.3056-0.2048 73.9328-0.3072-11.6224-8.3968-21.8112-18.5344-32.768-27.7504a55.04 55.04 0 0 1-20.5312-45.9264c0.7168-18.2272 11.6736-35.584 27.648-44.3392m-13.056 221.7984c-20.992 3.7376-38.912 20.3264-44.7488 40.7552a76.4928 76.4928 0 0 0-2.3552 21.7088c0.1024 89.0368-0.0512 178.0736 0.0512 267.1616-0.4096 24.2176 16.3328 47.1552 39.1168 54.8864 8.1408 2.9696 16.896 3.0208 25.3952 3.072 153.1904-0.1024 306.432 0.0512 459.6224-0.0512 22.4768 0.8704 44.0832-13.1072 53.5552-33.28 5.7856-11.5712 5.6832-24.7296 5.4784-37.376v-248.832c0-9.1136 0.3072-18.4832-2.304-27.2896a58.7776 58.7776 0 0 0-36.864-38.656c-9.7792-3.584-20.4288-3.0208-30.6688-3.072H292.5056c-8.8576 0-17.8176-0.3072-26.624 0.9728z" fill="#ffffff" p-id="5705"></path><path d="M358.7072 455.5264c14.6432-1.4848 29.8496 3.2768 41.0112 12.8 12.4416 10.24 19.5584 26.112 19.7632 42.1376 0.3584 19.4048 0.1024 38.8608 0.1024 58.2656 0 12.8-3.3792 25.8048-11.3152 35.9424a54.9888 54.9888 0 0 1-48.4864 21.76 54.9376 54.9376 0 0 1-44.032-28.2624c-6.8096-11.6736-7.3728-25.4976-7.168-38.6048 0.4096-18.8416-1.024-37.7856 0.8704-56.576a55.296 55.296 0 0 1 49.2544-47.4624z m292.4544 0a55.2448 55.2448 0 0 1 60.7232 53.0432c0.8192 18.2272 0.1024 36.4544 0.4096 54.6816 0.1024 12.8-1.4336 26.112-8.4992 37.12-10.24 17.0496-30.3104 27.5456-50.176 26.112a55.04 55.04 0 0 1-43.3664-24.9856c-7.936-11.776-9.472-26.2656-9.1136-40.0896 0.3584-18.7392-0.6656-37.4784 0.6144-56.1664 1.8432-25.6 23.9104-47.5136 49.408-49.664z" fill="#ffffff" p-id="5706"></path></svg>
                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="https://YuTaki23.github.io/" selected>中文</option>
                                
                                    <option value="https://YuTaki23.github.io/en/" >English</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#1-types-and-structs">1. Types and Structs</a>
      <ol>
        <li><a href="#11-什么是c">1.1 什么是C++？</a></li>
        <li><a href="#12-structs">1.2 Structs</a>
          <ol>
            <li><a href="#121-结构体基础知识">1.2.1 结构体基础知识</a></li>
            <li><a href="#122-什么是std">1.2.2 什么是<code>std</code></a></li>
          </ol>
        </li>
        <li><a href="#13-改善代码的一些方法">1.3 改善代码的一些方法</a>
          <ol>
            <li><a href="#131-using">1.3.1 <code>using</code></a></li>
            <li><a href="#132-auto">1.3.2 <code>auto</code></a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#2-initialization--references">2. Initialization &amp; References</a>
      <ol>
        <li><a href="#21-initialization">2.1 Initialization</a>
          <ol>
            <li><a href="#211-direct-initialization">2.1.1 Direct initialization</a></li>
            <li><a href="#212-uniform-initializationc11">2.1.2 Uniform initialization(C++11)</a></li>
            <li><a href="#213-structured-bingdingc17">2.1.3 Structured Bingding(C++17)</a></li>
          </ol>
        </li>
        <li><a href="#22-references">2.2 References</a>
          <ol>
            <li><a href="#221-references简单介绍">2.2.1 References简单介绍</a></li>
            <li><a href="#222-pass-by-reference">2.2.2 Pass by reference</a></li>
            <li><a href="#223-pass-by-value">2.2.3 Pass by value</a></li>
            <li><a href="#224-按值传递与按引用传递易错点">2.2.4 按值传递与按引用传递易错点</a></li>
          </ol>
        </li>
        <li><a href="#23-l-values-vs-r-values">2.3 L-values vs R-values</a></li>
        <li><a href="#24-const">2.4 Const</a></li>
        <li><a href="#25-compiling-c-programs">2.5 Compiling C++ Programs</a></li>
      </ol>
    </li>
    <li><a href="#3-streams">3. Streams</a>
      <ol>
        <li><a href="#31-streams简单介绍">3.1 Streams简单介绍</a></li>
        <li><a href="#32-stringstreams">3.2 stringstreams</a>
          <ol>
            <li><a href="#321-stringstreams简单介绍">3.2.1 stringstreams简单介绍</a></li>
            <li><a href="#322-getline">3.2.2 getline()</a></li>
          </ol>
        </li>
        <li><a href="#33-cout-and-cin">3.3 cout and cin</a>
          <ol>
            <li><a href="#331-cout的背后原理">3.3.1 cout的背后原理</a></li>
          </ol>
        </li>
        <li><a href="#34-output-streams">3.4 Output Streams</a></li>
        <li><a href="#35-input-streams">3.5 Input Streams</a></li>
      </ol>
    </li>
    <li><a href="#4-containers">4. Containers</a>
      <ol>
        <li><a href="#41-what-is-the-stl">4.1 What is the STL?</a>
          <ol>
            <li><a href="#411-what-are-templates">4.1.1 What are templates?</a></li>
            <li><a href="#412-containers">4.1.2 Containers</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#5-iterators">5. Iterators</a>
      <ol>
        <li><a href="#51-iterator基础">5.1 Iterator基础</a></li>
        <li><a href="#52-iterator-types">5.2 Iterator Types</a></li>
        <li><a href="#53-pointers-and-memory">5.3 Pointers and Memory</a>
          <ol>
            <li><a href="#531-memory基础">5.3.1 Memory基础</a></li>
            <li><a href="#532-变量地址表示方法">5.3.2 变量地址表示方法</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#6-classes">6. Classes</a>
      <ol>
        <li><a href="#61-类基础">6.1 类基础</a></li>
        <li><a href="#62-结构体与类的区别">6.2 结构体与类的区别</a></li>
        <li><a href="#63-类语法">6.3 类语法</a>
          <ol>
            <li><a href="#631-头文件与源文件的区别">6.3.1 头文件与源文件的区别</a></li>
            <li><a href="#632-设计类">6.3.2 设计类</a></li>
          </ol>
        </li>
        <li><a href="#64-inheritance">6.4 Inheritance</a></li>
      </ol>
    </li>
    <li><a href="#7-template-classes">7. Template Classes</a>
      <ol>
        <li><a href="#71-预处理器与宏定义">7.1 预处理器与宏定义</a></li>
        <li><a href="#72-templates">7.2 Templates</a>
          <ol>
            <li><a href="#721-一些模板的怪癖">7.2.1 一些模板的怪癖</a></li>
          </ol>
        </li>
        <li><a href="#73-const-correctness">7.3 Const Correctness</a>
          <ol>
            <li><a href="#731-const-interface">7.3.1 Const interface</a></li>
            <li><a href="#732-const-cast">7.3.2 Const Cast</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#8-template-functions">8. Template Functions</a>
      <ol>
        <li><a href="#81-template-functions">8.1 Template Functions</a>
          <ol>
            <li><a href="#811-三元运算符">8.1.1 三元运算符</a></li>
            <li><a href="#812-调用模板函数">8.1.2 调用模板函数</a></li>
          </ol>
        </li>
        <li><a href="#82-concepts">8.2 Concepts</a>
          <ol>
            <li><a href="#introducing-c-concepts">Introducing C++ concepts</a></li>
          </ol>
        </li>
        <li><a href="#83-variadic-templates">8.3 Variadic Templates</a></li>
        <li><a href="#84-template-metaprogramming">8.4 Template Metaprogramming</a></li>
      </ol>
    </li>
    <li><a href="#9-functions-and-lambdas">9. Functions and Lambdas</a>
      <ol>
        <li><a href="#91-functions-and-lambdas">9.1 Functions and Lambdas</a>
          <ol>
            <li><a href="#911-传递函数">9.1.1 传递函数</a></li>
            <li><a href="#912-lambda函数">9.1.2 Lambda函数</a></li>
            <li><a href="#913-functor仿函数">9.1.3 Functor(仿函数)</a></li>
            <li><a href="#914-仿函数与lambda函数之间的关系">9.1.4 仿函数与Lambda函数之间的关系</a></li>
          </ol>
        </li>
        <li><a href="#92-algorithms">9.2 Algorithms</a></li>
        <li><a href="#93-ranges-and-views">9.3 Ranges and Views</a>
          <ol>
            <li><a href="#931-ranges">9.3.1 Ranges</a></li>
            <li><a href="#932-views">9.3.2 Views</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#10-operator-overloading">10. Operator Overloading</a>
      <ol>
        <li><a href="#101-member-overloading">10.1 Member overloading</a></li>
        <li><a href="#102-non-member-overloading">10.2 Non-member overloading</a></li>
        <li><a href="#104-friend">10.4 <code>friend</code></a></li>
      </ol>
    </li>
    <li><a href="#11-move-semantics移动语义">11. Move Semantics(移动语义)</a>
      <ol>
        <li><a href="#111-左值与右值">11.1 左值与右值</a></li>
        <li><a href="#112-移动语义">11.2 移动语义</a></li>
        <li><a href="#113-smfs">11.3 SMFs</a></li>
      </ol>
    </li>
    <li><a href="#12-stdoptional--type-safety">12. std::optional &amp; type safety</a>
      <ol>
        <li><a href="#121-type-safety">12.1 Type safety</a></li>
        <li><a href="#122-stdoptional-t-">12.2 std::optional&lt; T &gt;</a></li>
        <li><a href="#123-总结">12.3 总结</a></li>
      </ol>
    </li>
    <li><a href="#13-raii-smart-pointers-building-projects">13. RAII, Smart Pointers, Building Projects</a>
      <ol>
        <li><a href="#131-raiiresource-acquisition-is-initialization资源获取即初始化">13.1 RAII(Resource Acquisition Is Initialization)资源获取即初始化</a>
          <ol>
            <li><a href="#1311-exceptions">13.1.1 Exceptions</a></li>
            <li><a href="#1312-raii">13.1.2 RAII</a></li>
          </ol>
        </li>
        <li><a href="#132-smart-pointers">13.2 Smart Pointers</a></li>
        <li><a href="#133-building-c-projects">13.3 Building C++ Projects</a>
          <ol>
            <li><a href="#1331-编译流程">13.3.1 编译流程</a></li>
            <li><a href="#1332-make">13.3.2 Make</a></li>
            <li><a href="#1333-cmake">13.3.3 CMake</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/cs106l/" >
                CS106L
            </a>
        
            <a href="/categories/%E7%AC%94%E8%AE%B0/" >
                笔记
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/cs106l-winter2025-notes/">CS106L Winter2025 NOTES</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            CS106L的课程笔记
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Apr 06, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 26 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="1-types-and-structs">1. Types and Structs
</h2><h3 id="11-什么是c">1.1 什么是C++？
</h3><ol>
<li>如何执行C++代码
C++是一个编译性语言，不同于Python的解释性语言，目前大部分C++程序所用的编译器为<strong>g++</strong>，作为编译性语言，C++拥有以下优缺点</li>
</ol>
<ul>
<li>允许生成更有效的机器语言，因为解释器只能看到代码的很小的一部分，但是编译器可以看到所有事物。</li>
<li>编译需要的时间很长。</li>
</ul>
<ol start="2">
<li>如何检查C++代码
在执行C++代码时，如果遇到错误，大多数情况会遇到很多十分冗余的日志，这让人很烦躁，为什么？</li>
</ol>
<ul>
<li><strong>Types</strong> C++是一个静态类型语言，每个变量都有自己的类型，一旦此变量被声明就无法再改变。虽然这不如Python方便，但也有许多好处，更有效、更好理解、更有效地错误检查。当然也会遇见<em>强制转换</em>的时候，<code>(int) 5.3 = 5</code>。C++支持<strong>重载</strong>操作，对于不同类型的值，只要声明两个函数包括两个不同的类型参数，C++会自己寻找该使用哪个函数。
综上，C++是一个<strong>编译性、静态类型</strong>的语言。</li>
</ul>
<h3 id="12-structs">1.2 Structs
</h3><h4 id="121-结构体基础知识">1.2.1 结构体基础知识
</h4><p>当我们想要在一个类型里面表示许多不同的值，此时就需要用到结构体，例如，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 构造结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">StanfordID</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">string</span> <span class="n">sunet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">idNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在C++中，初始化一个结构体有许多方法</p>
<ol>
<li><strong>初始化结构体</strong> 使用点表达式</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">StanfordID</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">id</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;Alice&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">id</span><span class="p">.</span><span class="n">sunet</span> <span class="o">=</span> <span class="s">&#34;jtrb&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">id</span><span class="p">.</span><span class="n">idNumber</span> <span class="o">=</span> <span class="mi">6504417</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li><strong>List Initialization</strong> 使用大括号</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">StanfordID</span> <span class="n">jrb</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;Jacob Roberts-Baca&#34;</span><span class="p">,</span> <span class="s">&#34;jtrb&#34;</span><span class="p">,</span> <span class="mi">6504417</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">StanfordID</span> <span class="n">fi</span> <span class="p">{</span><span class="s">&#34;Fabio Ibanez&#34;</span><span class="p">,</span> <span class="s">&#34;fibanez&#34;</span><span class="p">,</span> <span class="mi">6504418</span><span class="p">}</span> <span class="c1">//此处的“=”可以省略
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当我们想要表示<em>两个值</em>作为一个结构体时，<code>STL</code>已经给了我们模板，即<code>std::pair</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Order</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">quantity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">Order</span> <span class="n">dozen</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;Eggs&#34;</span><span class="p">,</span> <span class="mi">12</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// std::pair
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">dozen</span> <span class="p">{</span><span class="s">&#34;Eggs&#34;</span><span class="p">,</span> <span class="mi">12</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">item</span> <span class="o">=</span> <span class="n">dozen</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">quantity</span> <span class="o">=</span> <span class="n">dozen</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出，<code>pair</code>用的是<code>first</code>和<code>second</code>来表示两个值的。</p>
<h4 id="122-什么是std">1.2.2 什么是<code>std</code>
</h4><p><code>std</code> C++ Standard Libary</p>
<ul>
<li>内置的类型、函数&hellip;&hellip;</li>
<li>需要在文件前写<code>#include</code>才可以使用，本质上就是引用了其他包内的函数等</li>
<li>在使用<code>std</code>时，都会写上<code>std::</code>，但若在文件前写<code>using namespace std</code>就不用再写了</li>
</ul>
<h3 id="13-改善代码的一些方法">1.3 改善代码的一些方法
</h3><h4 id="131-using">1.3.1 <code>using</code>
</h4><p>在遇到一些类型十分复杂的函数时，其往往会存在大量的、不好理解的类型，此时就可以使用<code>using</code>关键字，例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 使用 using 前
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">solveQuadratic</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用 using 后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Zeros</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Solution</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">Zeros</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Solution</span> <span class="nf">solveQuadratic</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">c</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="132-auto">1.3.2 <code>auto</code>
</h4><p>场景如上，有时我们自己也搞不清这个变量到底是什么类型，那么此时就可以使用<code>auto</code>关键字，让编译器自己判断这个变量到底是什么类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 使用 auto 前
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">solveQuadratic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用 auto 后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">solveQuadratic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这同样也满足静态类型的要求，不会将一个int类型的值赋给String</p>
<h2 id="2-initialization--references">2. Initialization &amp; References
</h2><h3 id="21-initialization">2.1 Initialization
</h3><p>在初始化一个值时，C++有许多种方法来实现</p>
<h4 id="211-direct-initialization">2.1.1 Direct initialization
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">numOne</span> <span class="o">=</span> <span class="mf">12.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">numTwo</span><span class="p">(</span><span class="mf">12.0</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<strong>直接初始化</strong>中，C++不在乎你的值是否满足类型检查，它只会简单地将其看作你给他赋予的类型</p>
<h4 id="212-uniform-initializationc11">2.1.2 Uniform initialization(C++11)
</h4><p>对于统一初始化来说，C++在乎你的值满足类型检查，简单说，若你给的值是个浮点数，同时给的类型是<code>int</code>，那么此时编译器变不会编译</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">numOne</span><span class="p">{</span><span class="mi">12</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">numTwo</span><span class="p">{</span><span class="mf">12.0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">numThree</span><span class="p">{</span><span class="mf">12.0</span><span class="p">}</span> <span class="c1">//不会编译
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>优点</strong></p>
<ol>
<li>安全性 不允许发生<em>宅化转换</em>，即类型的精度变小，这避免了很多问题</li>
<li>泛用性 几乎所有类型都可以用这个方法来初始化，例如<code>vector</code> <code>map</code> <code>class</code></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ages</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;Alice&#34;</span><span class="p">,</span> <span class="mi">25</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;Bob&#34;</span><span class="p">,</span> <span class="mi">30</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;Charlie&#34;</span><span class="p">,</span> <span class="mi">35</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="213-structured-bingdingc17">2.1.3 Structured Bingding(C++17)
</h4><ul>
<li>在编译时，想要初始化一些具有固定的大小且此变量是作为一个数据结构存在时就使用<strong>结构化绑定</strong></li>
<li>拥有从一个函数的返回值一次性访问多个值的能力
比如，我们现在创建一个函数<code>getClassInfo</code>，它是用<code>tuple</code>这个数据结构来实现的，返回值使用的是<strong>统一初始化</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">getClassInfo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">className</span> <span class="o">=</span> <span class="s">&#34;CS106L&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">buildingName</span> <span class="o">=</span> <span class="s">&#34;Thornton 110&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">language</span> <span class="o">=</span> <span class="s">&#34;C++&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">{</span><span class="n">className</span><span class="p">,</span> <span class="n">buildingName</span><span class="p">,</span> <span class="n">language</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么现在我就可以把这个函数返回的三个值用结构化绑定的方法来返回了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="p">[</span><span class="n">className</span><span class="p">,</span> <span class="n">buildingName</span><span class="p">,</span> <span class="n">lanuage</span><span class="p">]</span> <span class="o">=</span> <span class="n">getClassInfo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不仅如此，我还可以使用<code>get</code>来获取函数的返回值，值得注意的是，在这里需要使用尖括号来寻找第几个元素</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="n">classInfo</span> <span class="o">=</span> <span class="n">getClassInfo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">className</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">classInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">buildingName</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">classInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">language</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">classInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>可以在编译时对已知大小的对象上使用</li>
</ul>
<h3 id="22-references">2.2 References
</h3><h4 id="221-references简单介绍">2.2.1 References简单介绍
</h4><ul>
<li>什么<strong>References</strong>？将一个已经存在的对象或函数的别名。</li>
<li>如何表示<strong>References</strong>？使用<code>&amp;</code>。
例如</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>num是一个整数类型变量，值为5；ref是一个整数引用类型变量，值为num，即num的别名。当我们更改ref的值时，也是在更改num的值。即ref是指向num的一个指针，由此我们就可以引出<em>pass by reference</em></p>
<h4 id="222-pass-by-reference">2.2.2 Pass by reference
</h4><p>当我们在函数中声明参数为引用类型时，即代表此函数使用的是<em>pass by reference</em>，这也就意味着，我们不会在内存中再分配一块内存来复制此变量等执行一系列操作，只会在原内存上操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">squareN</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">squareN</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里如果我们再去打印<code>num</code>的值，得到的结果就会是<strong>4</strong>，而不是<strong>2</strong></p>
<h4 id="223-pass-by-value">2.2.3 Pass by value
</h4><p>这意味着我们会在内存中重新分配一块内存，并将原参数复制一份过来，不会在原内存上进行操作，不会影响原内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">squareN</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">squareN</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里再去打印num的值得到的结果就是<strong>2</strong></p>
<h4 id="224-按值传递与按引用传递易错点">2.2.4 按值传递与按引用传递易错点
</h4><p>值得注意的是，当我们在遇见一些很复杂的类型时，会用到之前学到的<strong>auto</strong>，同时还用了<strong>Structred Binding</strong>但在进行按引用传递时，编译器不会帮我们寻找 <strong>&amp;</strong> 我们需要自己加上 <strong>&amp;</strong> 即</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shift</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">]</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">num1</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">num2</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但当我们用普通的<strong>点表达式</strong>时，就不需要这样，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shift</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="23-l-values-vs-r-values">2.3 L-values vs R-values
</h3><p>左值和右值是表达式的基本分类，用于描述其值类别，区别在于对象的身份、生命周期和可操纵性。
左值代表一个有持久状态的变量（或内存位置），通常可以取地址、有名称。可以出现在表达式的左边或右边。
右值代表一个临时变量或字面量，没有持久状态，不可以被取地址。出现在表达式的右边。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// x为左值，10为右值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// x为左值
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于<code>int&amp; num</code>是左值还是右值？
左值。在这里，num是按引用传递，对于右值来说只可以存放临时变量，不可以被取地址，所以这里的num只能是左值。</p>
<h3 id="24-const">2.4 Const
</h3><p>当一个对象以常数声明后，它就无法再被修改了。
比如，对于一个vector，若被声明为<code>const std::vector&lt;int&gt; const_vec;</code>，那么此时若对此vector使用<code>push_back</code>就会编译错误。
若将一个引用非常数类型的引用一个常数类型的vector则会导致编译错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">const_vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">bad_ref</span><span class="p">{</span><span class="n">const_vec</span><span class="p">};</span> <span class="c1">// 编译错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">good_ref</span><span class="p">{</span><span class="n">const_vec</span><span class="p">};</span> <span class="c1">//编译成功
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="25-compiling-c-programs">2.5 Compiling C++ Programs
</h3><ul>
<li>C++是一个编译性语言</li>
<li>存在一款软件——编译器</li>
<li>目前流行的编译器有<strong>clang</strong> <strong>g++</strong>
<code>g++ -std=c++20 main.cpp -o main</code>
此命令的内容为 使用g++这个编译器在C++20的环境下编译main.cpp这个文件并将编译后的程序命名为main
最后使用<code>./main</code>来执行此程序。</li>
</ul>
<h2 id="3-streams">3. Streams
</h2><h3 id="31-streams简单介绍">3.1 Streams简单介绍
</h3><p>C++的一个普遍的Input/Output（IO）抽象，此抽象提供一系列接口，用于读取和写入数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, World&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::cout</code>是一个<code>std::ostream</code>的一个实例变量，用于打印内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">pi</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">pi</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::cin</code>是一个<code>std::istream</code>的一个实例变量，用于读取内容
流允许以一种普遍的方式来解决数据问题</p>
<h3 id="32-stringstreams">3.2 stringstreams
</h3><h4 id="321-stringstreams简单介绍">3.2.1 stringstreams简单介绍
</h4><p>用于将字符串以流的方式表达
对于不同类型数据混合的情况很适用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">initial_quote</span> <span class="o">=</span> <span class="s">&#34;Bjarne Stroustrup C makes it easy to shoot yourself in the foot&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="n">initial_quote</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将上文字符串以流的形式写入<code>ss</code>，并且最后存在<code>\n</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">language</span><span class="p">,</span> <span class="n">extracted_quote</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="n">last</span> <span class="o">&gt;&gt;</span> <span class="n">language</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于stringstreams来说，以空格来分割一个字符串即，此时<code>first = &quot;Bjarne&quot;</code> <code>last = Stoustrup</code> <code>language = C</code>
但此时我们想把最后剩余的其他内容都写入<code>extracted_quote</code>用这种方式就不可取，由此引入<code>getline()</code></p>
<h4 id="322-getline">3.2.2 getline()
</h4><p><code>getline()</code>会读取一行的内容，即以<code>\n</code>截止</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">extracted_quote</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="33-cout-and-cin">3.3 cout and cin
</h3><h4 id="331-cout的背后原理">3.3.1 cout的背后原理
</h4><p>当我们想将一个内容输出到终端或控制台时，应当使用<code>std::cout</code>和<code>&lt;&lt;</code>操作符，但仅这样没法输出到控制台，我们还需要加上<code>flush</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">tao</span> <span class="o">=</span> <span class="mf">6.28</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tao</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在调用<code>endl</code>会隐式调用<code>flush</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">tao</span> <span class="o">=</span> <span class="mf">6.28</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tao</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当我们每次调用<code>flush</code>时，就会立马清空此处的内存，包括使用<code>endl</code>的时候，在做一个循环时，当我们不断打印一个内容再加上一个换行符，就会耗费许多内存，故<code>flush</code>操作是很昂贵的。
但是，C++作为一个聪明的语言，是会自己知道什么时候该<code>flush</code>的，每当此处内存满了之后，就会自动<code>flush</code></p>
<h3 id="34-output-streams">3.4 Output Streams
</h3><p>当我们想将一些内容写入文件中就需要用到<code>std::ofstream</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">ofs</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">);</span> <span class="c1">// 创建一个流用于打开文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">ofs</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello CS106L&#34;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="c1">// 检查文件是否打开
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">ofs</span><span class="p">.</span><span class="n">close</span><span class="p">();</span> <span class="c1">// 关闭文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">ofs</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;this will not get written&#34;</span><span class="p">;</span> <span class="c1">//此内容不会写进
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">ofs</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">);</span> <span class="c1">//打开文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">ofs</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;this will though! It&#39;s open again&#34;</span><span class="p">;</span> <span class="c1">// 此内容会写进文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="35-input-streams">3.5 Input Streams
</h3><p>从一个文件读取内容就需要用到<code>std::istream</code>
<code>std::cin</code>会在遇见空格后停止</p>
<ul>
<li><code>getline()</code>和<code>std::cin()</code>不能在一起使用</li>
</ul>
<h2 id="4-containers">4. Containers
</h2><h3 id="41-what-is-the-stl">4.1 What is the STL?
</h3><p><strong>STL: Standard Template Library</strong></p>
<h4 id="411-what-are-templates">4.1.1 What are templates?
</h4><p>我们总会遇见同一种函数，十分相似，但它们的差别就在类型不一样，例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">IntVecor</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DoubleVector</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StringVector</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们有几百上千种类型呢？难道要一个一个写出来吗，当然不，由此引出<strong>模板</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>所有的STL容器都是模板</strong></p>
<h4 id="412-containers">4.1.2 Containers
</h4><p>如何保存一系列元素</p>
<h5 id="4121-sequence-containers">4.1.2.1 Sequence Containers
</h5><p>序列式容器用于保存一些列线性元素</p>
<ul>
<li><strong>std::vector</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 创建一个空vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// 创建一个大小为n的vector，其中所有元素均为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c1">// 创建一个大小为n的vector，其中所有元素均为k
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">k</span><span class="p">);</span> <span class="c1">// 将k添加到vector后面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">// 清空vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="c1">// 检查vector是否为空
</span></span></span><span class="line"><span class="cl"><span class="c1">// 获取第i个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 将第i个元素替换为k
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Tips</p>
<ol>
<li>如果可以，使用<strong>range-based for</strong>（基本范围的for循环）</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// range-based for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这适用于所有可迭代的容器，不止vector
2. 在使用<strong>range-based for</strong>时，将类型更改为<strong>const auto&amp;</strong>，这有利于节省内存，原先会创建一系列元素的复制，现在只会在原元素上更改</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">vec</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="err">变为</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">vec</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>对于[]操作符不会进行边界检查</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 假定2已经超出边界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 未定义的行为
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vec</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 运行时间超时
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假定现在又超过一百万个元素在一个vector中，想要在第一个地方添加一个元素，就需要将这一百万个元素全部向后移动一位，这很耗费时间，由此我们就引出了<strong>deque</strong></p>
<ul>
<li><strong>std::deque</strong>
deque是双端队列，允许操作第一个或最后一个元素
对于vector来说，用的是空间中的一组内存，而对于deque，用的书空间中一组内存的一组内存，将整个元素分开了</li>
</ul>
<h5 id="4122-associative-containers">4.1.2.2 Associative Containers
</h5><p>关联式容器用于组织键值对元素</p>
<ul>
<li><strong>std::map</strong>
用一个key来匹配一个value，其中key是唯一的，value可以不唯一</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// 创建一个空map
</span></span></span><span class="line"><span class="cl"><span class="c1">// 将key为k，value为v的键值对添加到map中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">);</span> <span class="c1">// 移除key为k的键值对
</span></span></span><span class="line"><span class="cl"><span class="c1">// 检查k是否在map里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="c1">// C++20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="c1">// 检查map是否为空
</span></span></span><span class="line"><span class="cl"><span class="c1">// 将key为k的value重写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当map存储的是一个键值对时，其也可以被看作为pair</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此处K为常量，即K是不可以被修改的，在map中key也是不可以被修改的，所以此处不能变
<strong>range-based for</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">kv</span> <span class="p">:</span> <span class="n">map</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 此处就是把map当作pair来看，用的是first和second
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">key</span> <span class="o">=</span> <span class="n">kv</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">kv</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 此处map就是map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span> <span class="o">:</span> <span class="n">map</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>map的底层原理即为<strong>红黑树</strong>，这也就意味着key必须要有<strong>操作符&lt;</strong>，比如<code>std::map&lt;std::ifstream, int&gt; map</code>在这里就是错误的，因为ifstream无法比较。</p>
<ul>
<li><strong>std::set</strong>
set存储一组<strong>唯一</strong>的元素</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// 创建一个空set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">);</span> <span class="c1">// 将k添加到set中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">);</span> <span class="c1">// 移除set中的k
</span></span></span><span class="line"><span class="cl"><span class="c1">// 检查k是否在set里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="c1">// C++20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="c1">// 检查set是否为空
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>set是没有value的map
set的底层原理也是红黑树，这同样意味着需要存在<strong>操作符&lt;</strong></p>
<ul>
<li><strong>std::unordered_map</strong> 和 <strong>std::unordered_set</strong>
此容器与上文提到的没有什么差别，不同的是底层实现为<strong>哈希表</strong>，通过哈希函数，将其转变为无序的
为什么使用无序？更平均的负载因子，当负载因子过高时，允许rehash</li>
</ul>
<ol>
<li>通常来说，<code>unordered_map</code>要快于<code>map</code></li>
<li>但<code>unordered_map</code>要用更多的内存</li>
<li>若<code>key</code>不存在<strong>操作符&lt;</strong>，使用<code>unordered_map</code></li>
<li>若必须要从中挑一个，<code>unordered_map</code>会更安全</li>
</ol>
<h2 id="5-iterators">5. Iterators
</h2><h3 id="51-iterator基础">5.1 Iterator基础
</h3><p>在上文提到的range-based for中，这是如何实现的
容器与迭代器一起工作就构成了迭代
迭代器存在三个操作</p>
<ul>
<li>获取一个元素</li>
<li>向前移动一个元素</li>
<li>检查整个元素是否已经遍历完成
容器存在两个接口</li>
<li><code>container.begin()</code>获取<em>第一个元素</em>迭代器</li>
<li><code>container.end()</code>获取<em>最后一个元素的后一个元素</em>的迭代器，它永远不会指向最后一个元素，一定会指向最后一个元素的后一个元素，因为若此容器为空，<code>c.begin() == c.end()</code>就会为真
综上，当我们写下</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>就是写下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="n">elem</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>补充：为什么使用<code>++it</code>而不是<code>it++</code>
<code>++it</code>会避免生成不必要的复制</p>
<h3 id="52-iterator-types">5.2 Iterator Types
</h3><p>对于迭代器来说，不止有一个一个增加的迭代，还存在许多其他操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="o">--</span><span class="n">it</span><span class="p">;</span> <span class="c1">// 向前一位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span> <span class="c1">// 修改此处的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">it</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// 向前n位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">it1</span> <span class="o">&lt;</span> <span class="n">it2</span><span class="p">;</span> <span class="c1">// 判断it1是否在it2前面
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>若元素在结构体当中，可以用<code>-&gt;</code>来访问元素</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Bibble</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">zarf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bibble</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{...};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">).</span><span class="n">zarf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">zarf</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// IO迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">elem</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span> <span class="c1">// 访问元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span> <span class="c1">// 写入元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 向前迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">it1</span> <span class="o">==</span> <span class="n">it2</span><span class="err">；</span>
</span></span><span class="line"><span class="cl"><span class="o">++</span><span class="n">it1</span> <span class="o">==</span> <span class="o">++</span><span class="n">it2</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 反向迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="o">--</span><span class="n">it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span> <span class="c1">// 获取最后一个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//随机访问迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// 向前五个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">it3</span> <span class="o">=</span> <span class="n">it2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 向后两个
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="53-pointers-and-memory">5.3 Pointers and Memory
</h3><p>一个<strong>迭代器</strong>指向一个<strong>容器元素</strong>
一个<strong>指针</strong>指向任何<strong>对象</strong></p>
<h4 id="531-memory基础">5.3.1 Memory基础
</h4><ul>
<li>每个变量都存放在内存中的某个地方</li>
<li>所有地方都可以被一个地址来表示</li>
<li>地址用字节寻址法，每个字节都从0开始</li>
<li>1 byte = 8 bits</li>
<li>一个对象的地址是用此对象最小地址来表示的
对于一个整数类型x来说，它在内存中占四个字节，假设为0x10 0x11 0x12 0x13，那么此时x的地址就是0x10</li>
</ul>
<h4 id="532-变量地址表示方法">5.3.2 变量地址表示方法
</h4><p><strong>指针</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">106</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// int*为一个整数指针 &amp;为取地址操作符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="c1">// 106
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="n">px</span> <span class="c1">// 106
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">px</span> <span class="c1">// 0x50527c
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于不同的对象，有不同的指针表示方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">106</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">StanfordID</span> <span class="n">id</span> <span class="p">{</span><span class="s">&#34;jtrb&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">StanfordID</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">name</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// vector []表示法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于vector来说，其在内存中是以一块内存表示的，故我们可以使用<strong>指针运算</strong>来表示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">arr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// index = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">++</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// index = 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">arr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// index = 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">arr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// 取index为4的值
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="6-classes">6. Classes
</h2><h3 id="61-类基础">6.1 类基础
</h3><ol>
<li>为什么使用类？
<ul>
<li>C没有对象</li>
<li>不能在操作数据的时候封装数据与函数</li>
<li>无法使用面向对象编程范式</li>
</ul>
</li>
<li>什么是面向对象
<ul>
<li>面向对象所有内容都是围绕对象来实现的</li>
<li>专注于设计与实现类</li>
<li>类是由用户定义的
<strong>容器都是STL定义的类</strong></li>
</ul>
</li>
</ol>
<h3 id="62-结构体与类的区别">6.2 结构体与类的区别
</h3><p><strong>结构体是受限制的类</strong>
对于结构体来说，其所定义的所有<code>fields</code>都是<code>public</code>的，这也就意味着它们可以被用户随意更改
对于类，其存在<code>public</code> <code>private</code>，用户只能访问<code>public</code>的对象</p>
<h3 id="63-类语法">6.3 类语法
</h3><h4 id="631-头文件与源文件的区别">6.3.1 头文件与源文件的区别
</h4><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th></th>
          <th>Header File(.h)</th>
          <th>Source File(.cpp)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>目的</td>
          <td>定义接口</td>
          <td>实现函数</td>
      </tr>
      <tr>
          <td>包括内容</td>
          <td>函数原型、类声明、类型定义、宏、常数</td>
          <td>函数具体实现内容，执行代码</td>
      </tr>
      <tr>
          <td>访问</td>
          <td>与源文件分享</td>
          <td>被编译</td>
      </tr>
      <tr>
          <td>举例</td>
          <td><code>void someFunction();</code></td>
          <td><code>void someFunction(){};</code></td>
      </tr>
  </tbody>
</table></div>
<h4 id="632-设计类">6.3.2 设计类
</h4><ul>
<li>构造函数</li>
<li>私有函数/变量</li>
<li>公共函数</li>
<li>Destructor（析构函数）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// .h file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">StanfordID</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sunet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">idNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">StanfordID</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sunet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idNumber</span><span class="p">);</span> <span class="c1">// Constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// method
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getSunet</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nf">getID</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// .cpp file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;StanfordID.h&#34;</span><span class="cp"> </span><span class="c1">// 包含头文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用namespace就像std::一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">StanfordID</span><span class="o">::</span><span class="n">StanfordID</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sunet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idNumber</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">this</span> <span class="o">-&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span> <span class="c1">// 使用this关键字来表示现在具体是哪个值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">this</span> <span class="o">-&gt;</span> <span class="n">sunet</span> <span class="o">=</span> <span class="n">sunet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 可以检查是否有效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">-&gt;</span> <span class="n">idNumber</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span> <span class="o">-&gt;</span> <span class="n">idNumber</span> <span class="o">=</span> <span class="n">idNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// uniform initialization(C++11)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">StanfordID</span><span class="o">::</span><span class="n">StanfordID</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sunet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idNumber</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">{</span><span class="n">name</span><span class="p">},</span> <span class="n">sunet</span><span class="p">{</span><span class="n">sunet</span><span class="p">},</span> <span class="n">idNumber</span><span class="p">{</span><span class="n">idNumber</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 实现方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StanfordID</span><span class="o">::</span><span class="n">getName</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StanfordID</span><span class="o">::</span><span class="n">getSunet</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">sunet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">StanfordID</span><span class="o">::</span><span class="n">getID</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">idNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 绑定函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">StanfordID</span><span class="o">::</span><span class="n">setName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">StanfordID</span><span class="o">::</span><span class="n">setSunet</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sunet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">this</span><span class="o">-&gt;</span><span class="n">sunet</span> <span class="o">=</span> <span class="n">sunet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">StanfordID</span><span class="o">::</span><span class="n">setID</span><span class="p">(</span><span class="kt">int</span> <span class="n">idNumber</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">idNumber</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span><span class="o">-&gt;</span><span class="n">idNumber</span> <span class="o">=</span> <span class="n">idNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// destructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">StanfordID</span><span class="o">::~</span><span class="n">StanfordID</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于析构函数来说，它是为了释放我们在空间中使用的内存，但当我们<code>new</code>一个新对象时，它会自动帮我们释放的，尽管如此，这依旧很重要</p>
<h3 id="64-inheritance">6.4 Inheritance
</h3><ul>
<li>多态性：不同的对象有可能会使用相同的接口</li>
<li>可扩展性：继承允许扩大类来创造子类</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// .h file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">double</span> <span class="n">area</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 虚拟函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span> <span class="c1">// :继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">double</span> <span class="n">_radius</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">)</span><span class="o">:</span> <span class="n">_radius</span><span class="p">{</span><span class="n">radius</span><span class="p">}</span> <span class="p">{};</span> <span class="c1">// 构造函数 uniform initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">double</span> <span class="nf">area</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mf">3.14</span> <span class="o">*</span> <span class="n">_radius</span> <span class="o">*</span> <span class="n">_radius</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="c1">// 重写 area()函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>public</code> <code>protected</code> <code>private</code></p>
<h2 id="7-template-classes">7. Template Classes
</h2><h3 id="71-预处理器与宏定义">7.1 预处理器与宏定义
</h3><p>在创建我们自己的vector的时候，会遇到对不同的类型写不同的代码的情况，但它们之间的区别又很小，只有一个类型的差别，例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">IntVector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">size_t</span> <span class="n">logical_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">size_t</span> <span class="n">array_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DoubleVector</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StringVector</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于这种情况，我们引出了预处理器与宏</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define GENERATE_VECTOR(MY_TYPE)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="k">class</span> <span class="nc">MY_TYPE</span><span class="err">##</span><span class="n">Vector</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">		<span class="n">MY_TYPE</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">		<span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">MY_TYPE</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">	<span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">		<span class="n">MY_TYPE</span><span class="o">*</span> <span class="n">elems</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">		<span class="n">size_t</span> <span class="n">logical_size</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">		<span class="n">size_t</span> <span class="n">array_size</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">GENERATE_VECTOR</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Vector</span> <span class="n">v1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>预处理器允许其在编译之前运行
通过这种方式，允许我们创建不同类型的vector
但对于这种方式，也会存在其缺点</p>
<ul>
<li>类C语言的语法</li>
<li>很难做类型检查</li>
<li>有时会忘了做宏定义
因此，继续引出<strong>Templates</strong></li>
</ul>
<h3 id="72-templates">7.2 Templates
</h3><p>模板允许自动生成代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// 模板声明 T会自己替换类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">T</span><span class="o">*</span> <span class="n">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于特定类型的模板，我们称其为<strong>Template Instantiation</strong>，以下均为模板实例化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intVec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">doubleVec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strVec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Vector</span><span class="o">&lt;</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vecVec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">MyCustomType</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="n">Vector</span><span class="o">&lt;</span><span class="n">MyCustomType</span><span class="o">&gt;</span> <span class="n">structVec</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译器会自己替换类型的
对于<code>typename</code>来说，允许替换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Vector</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SizeTemplate</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">B</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BoolTemplate</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="721-一些模板的怪癖">7.2.1 一些模板的怪癖
</h4><ol>
<li>在<code>.cpp</code>文件中必须包含<code>template&lt; &gt;</code></li>
<li><code>.h</code>必须在底部包含<code>.cpp</code></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// .h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;Vector.cpp&#34;</span><span class="cp"> </span><span class="c1">// 怪癖2 必须包含
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// .cpp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// 怪癖1 显式写出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">T</span><span class="o">&amp;</span> <span class="n">Vetor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li><code>typename</code>与<code>class</code>是一样的</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">pair</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">V</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">pair</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="73-const-correctness">7.3 Const Correctness
</h3><p>当我们书写以下函数时，编译器会给出错误<code>No such method size!</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">printVec</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但我们明明在之前就已经实现了<code>size</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">size_t</span> <span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="nf">empty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>问题在于</p>
<ul>
<li>对于v来说传递的是个常数，不希望修改v</li>
<li>编译器不确定<code>size</code>是否会修改v</li>
<li>因为成员函数是有可能会修改v的
修改方法为，在后面加上<code>const</code>标识符，以告诉编译器，我确保此方法不会修改对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于<code>.cpp</code>文件也应该加上<code>const</code>标识符</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">size_t</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">logical_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="731-const-interface">7.3.1 Const interface
</h4><ul>
<li>对象被标记为const后只能使用const interface</li>
<li>const interface是作为对象中的一个常量函数</li>
</ul>
<h4 id="732-const-cast">7.3.2 Const Cast
</h4><p>对于<code>T&amp; at(size_t index) const;</code>来说存在两个错误</p>
<ol>
<li>const可以修改
<ul>
<li>返回一个引用常量<code>const T&amp; at(size_t index) const;</code></li>
</ul>
</li>
<li>非const不可以修改
<ul>
<li>重写函数，写两个版本的<code>at()</code>，一个版本用于接收const参数，另一个用于接收非const参数</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但如果我们有许多函数要对常量与非常量进行运算，那每个函数就要写两遍，这过于冗余了，因此我们引出<strong>casting</strong></p>
<ul>
<li>casting 将一个类型强制转换为另一个类型</li>
<li><code>const_cast</code> 将非const强转为const
<code>const_cast&lt;Vector&lt;T&gt;&amp;&gt;(*this).findElement(value);</code></li>
<li><code>const_cast</code>将非const强转为const</li>
<li><code>Vector&lt;T&gt;&amp;</code>非const引用</li>
<li><code>*this</code>解引用<code>const Vector&lt;T&gt;*</code></li>
<li><code>findElement</code>非const版本的<code>findElement()</code>
什么时候使用<strong>const_cast</strong>？
<strong>最好不要</strong></li>
</ul>
<h2 id="8-template-functions">8. Template Functions
</h2><h3 id="81-template-functions">8.1 Template Functions
</h3><h4 id="811-三元运算符">8.1.1 三元运算符
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>若 a &lt; b 则返回 a 反之 b
当我们想将不同的类型进行上述比较，按之前的方法可能需要些若干个函数，分别表示不同的类型，但现在我们可以使用模板</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样的，可以写出引用类型，防止复制一份额外的，占用内存</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="812-调用模板函数">8.1.2 调用模板函数
</h4><ul>
<li>explicit instantiation（显式实例化）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">min</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">106</span><span class="p">,</span> <span class="mi">107</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">min</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>implicit instantiation（隐式实例化）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">min</span><span class="p">(</span><span class="mi">106</span><span class="p">,</span> <span class="mi">107</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">min</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译器会自己调用类型，有点像之前学到的<code>auto</code>关键字
若给出<code>min(106, 3.14)</code>则无法编译，解决方法为改变函数签名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="82-concepts">8.2 Concepts
</h3><p>编译器发现错误只会在实例化之后，这也就是说，有些事物可以被实例化，但无法被比较，此时编译器会正常实例化，但无法比较，由此，如何才能在实例化之前发现错误（无法被比较）？</p>
<h4 id="introducing-c-concepts">Introducing C++ concepts
</h4><p>创建Comparable concept</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">concept</span> <span class="n">Comparable</span> <span class="o">=</span> <span class="k">requires</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>concept: a named set of constraints</li>
<li>requires: 提供两个参数</li>
<li><code>{a &lt; b}</code>(constraint): 任何在大括号内的东西都必须被无错误地编译</li>
<li><code>std::convertible_to&lt;bool&gt;</code>(constraint): 结果必须为布尔值
此时，就可以避免无法被比较的错误了</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">requires</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 简短写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">Comparable</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="83-variadic-templates">8.3 Variadic Templates
</h3><p>如果我们想在一个函数里面接受更多的参数，应该怎么做，简单的想法是重写许多个函数，让编译器自己寻找该用哪一个，这显然过于冗余
<strong>Templates + recursion</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// base case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">Comparable</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">v</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// recrusive case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">Comparable</span> <span class="n">T</span><span class="p">,</span> <span class="n">Comparable</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">?</span> <span class="nl">v</span> <span class="p">:</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>Comparable... Args</code> <strong>Variadic template</strong>匹配0或更多个类型</li>
<li><code>const Args&amp;</code> <strong>Parameter pack</strong>匹配0或更多个参数</li>
<li><code>min(args)</code> 替换为实际参数</li>
</ul>
<h3 id="84-template-metaprogramming">8.4 Template Metaprogramming
</h3><p><strong>TMP is Turing complete</strong>
如何让我们得到既可以在编译时运行又有可读性的代码呢？
<strong>constexpr/consteval</strong>(C++20)
constexpr: 尝试在编译时运行此段代码
consteval: 必须在编译时运行此段代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">size_t</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">consteval</span> <span class="n">size_t</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="9-functions-and-lambdas">9. Functions and Lambdas
</h2><h3 id="91-functions-and-lambdas">9.1 Functions and Lambdas
</h3><h4 id="911-传递函数">9.1.1 传递函数
</h4><p>有时会想把一个布尔函数作为查找一个东西的条件，我们在此称其为<strong>predicates</strong>那么如何优雅的将此条件加入到函数中呢，简单想法为作为函数中的一个参数来实现，问题在于其类型是什么，以<code>find_if()</code>为例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Pred</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">It</span> <span class="n">find_if</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">))</span> <span class="k">return</span> <span class="n">it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在此我们对于predicates的类型作为<strong>typename</strong>，编译器会自己帮我们找其类型具体是什么的。在函数内也传递了此条件，运用了此条件
旁注，Pred的类型具体是什么？
在C++中，这可以作为一个<strong>函数指针</strong>，用于指向一个函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Pred</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Pred</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">char</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但有时候又会遇见在条件中不止一个参数的情况，比如<code>bool isLessThan(int elem, int n)</code>在这种情况，我们就无法在其他函数中使用此函数，因为要在其他函数使用此函数，只能传递一个参数，由此引出<strong>Lambda Functions</strong></p>
<h4 id="912-lambda函数">9.1.2 Lambda函数
</h4><p>Lambda函数允许我们在使用一个参数的情况下也依然可以比较多个参数之间的值，举例来说，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">lessThanN</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里我们实际上只传递了一个参数x
lambda函数允许出现在其他函数的参数中</p>
<h4 id="913-functor仿函数">9.1.3 Functor(仿函数)
</h4><p>一个扮演着函数的对象，由<code>operator()</code>定义的对象</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">greater</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于仿函数是一个对象，所以其存在state</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_functor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">my_functor</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="914-仿函数与lambda函数之间的关系">9.1.4 仿函数与Lambda函数之间的关系
</h4><p>当我们写一个Lambda函数时，实际上就是在用仿函数来写，例如以下两函数表达的是同一个意思</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">lessThanN</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">find_if</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">lessThanN</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">__lambda_6_18</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__lambda_6_18</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">_n</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">{</span><span class="n">_n</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">lessThanN</span> <span class="o">=</span> <span class="n">__lambda_6_18</span><span class="p">{</span><span class="n">n</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">find_if</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">lessThanN</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="92-algorithms">9.2 Algorithms
</h3><p><code>&lt;algorithm&gt;</code>是一个模板函数的集合</p>
<h3 id="93-ranges-and-views">9.3 Ranges and Views
</h3><h4 id="931-ranges">9.3.1 Ranges
</h4><p>Ranges是一个STL的新版本
定义：range是任何拥有<code>begin</code>和<code>end</code>的东西
这意味着许多可以迭代的数据结构都存在ranges</p>
<h4 id="932-views">9.3.2 Views
</h4><p>一种组合算法的方法
定义：惰性的适配另一个range的range
若我们用现在的STL来写代码，可能会是这样的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="sc">&#39;d&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Filter -- Get only the vowels
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">copy_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">isVowel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Transform -- Convert to uppercase
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">f</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">toupper</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// { &#39;A&#39;, &#39;E&#39; }
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但使用veiws来写，就会简单很多</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">letters</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="sc">&#39;d&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">e</span><span class="err">’</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">filter</span><span class="p">(</span><span class="n">letters</span><span class="p">,</span> <span class="n">isVowel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">toupper</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">vowelUpper</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">to</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同时还可以使用<code>|</code>链式操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">letters</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">,</span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="sc">&#39;d&#39;</span><span class="p">,</span><span class="sc">&#39;e&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">upperVowel</span> <span class="o">=</span> <span class="n">letters</span>
</span></span><span class="line"><span class="cl"><span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">filter</span><span class="p">(</span><span class="n">isVowel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">toupper</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">to</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用ranges/views的优缺点
优点</p>
<ul>
<li>不用担心迭代器</li>
<li>更好的错误消息提示</li>
<li>可读性更高、函数化更好的语法
缺点</li>
<li>太新了（C++20开始），很少人了解</li>
<li>缺乏编译器支持</li>
<li>与手工编码版本相比的性能缺失</li>
</ul>
<h2 id="10-operator-overloading">10. Operator Overloading
</h2><h3 id="101-member-overloading">10.1 Member overloading
</h3><p>当我们想要比较我们自己创建的类的时候，常常会因为此类无法被比较而失败，但C++允许我们自己<strong>重载操作符</strong>，以帮助我们比较两个类，就像我们之前学习的<code>StanfordID</code>类，就可以对其操作符进行重载，具体怎么做？</p>
<ul>
<li>就像我们在类中声明函数一样，我们可以以声明函数的方式声明操作符</li>
<li>当我们对我们创建的对象使用操作符时，这代表在执行自定义的函数或操作符</li>
<li>就像函数重载一样，当我们给了一样的名字，它就会重写操作符的行为，编译器自己会找到该用哪个的
因此，我们的<code>StanfordID</code>的<code>小于操作符</code>可以写成</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">StanfordID</span><span class="o">::</span><span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">StanfordID</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">idNumber</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">getIdNumber</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="102-non-member-overloading">10.2 Non-member overloading
</h3><p>上文提到的是<strong>member overloading</strong>，不止这种方法，在C++中更被人们所喜欢和应用的是<strong>Non-member overloading</strong>，为什么？</p>
<ol>
<li>允许(left-hand-side)左边是非类类型(non-class type)</li>
<li>允许重载我们没有掌控的类的运算符，比如我们可以将<code>StanfordID</code>与其他类进行比较</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Non-member
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">StanfordID</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">StanfordID</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// member
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">StanfordID</span><span class="o">::</span><span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">StanfordID</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{...}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="104-friend">10.4 <code>friend</code>
</h3><p><code>friend</code>关键字允许non-member函数或non-member类访问其他类中private里的值
<code>friend</code>应该写在<code>.h</code>文件中显式写出来</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// .h file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">StanfordID</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sunet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">idNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="c1">// constructor for our StudentID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">StanfordID</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sunet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idNumber</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> 
</span></span><span class="line"><span class="cl"><span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">StanfordID</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">StanfordID</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// .cpp file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include StanfordID.h
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">StanfordID</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">StanfordID</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">idNumber</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">idNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>运算符允许传递函数不存在的类型</strong></p>
<ul>
<li>operator overloading解锁了我们定义对象新的功能和意义</li>
<li>运算符应该有意义，传递一些函数并不关乎类型本身</li>
<li>仅在需要的时候overload，比如不需要使用IO流的时候就不需要重写<code>&lt;&lt;</code>或<code>&gt;&gt;</code></li>
</ul>
<h2 id="11-move-semantics移动语义">11. Move Semantics(移动语义)
</h2><p>假设现在我们存在一个<code>Photo</code>类</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Photo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Photo</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Photo</span><span class="p">(</span><span class="k">const</span> <span class="n">Photo</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Photo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Photo</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">~</span><span class="n">Photo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Photo</span><span class="o">::</span><span class="n">Photo</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">:</span> <span class="n">width</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">,</span> <span class="n">height</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">,</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Copy Constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Photo</span><span class="o">::</span><span class="n">Photo</span><span class="p">(</span><span class="k">const</span> <span class="n">Photo</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">:</span> <span class="n">width</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">width</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">,</span> <span class="n">height</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">,</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Copy Assignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Photo</span> <span class="o">&amp;</span><span class="n">Photo</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Photo</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Check for self assignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// Clean up old pixels!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Copy over new pixels!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">width</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">height</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Destructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Photo</span><span class="o">::~</span><span class="n">Photo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当此时已经存在一个<code>Photo</code>实例时，现在想要再得到一个相同的<code>Photo</code>时，第一时间可能会想到使用Copy复制一份，但可以有更好的方式不需要通过复制来实现——移动语义（<code>std::move()</code>）。使用这种方式可以直接指向原<code>Photo</code>而不用复制。但是，使用这种方式一定是安全的吗？如果我们未来还需要再使用这个对象，那此时原对象已经指向null了，就会出现空指针异常的情况。</p>
<h3 id="111-左值与右值">11.1 左值与右值
</h3><p>关于左值与右值，上文已经有提过，在此需要对其加深理解。</p>
<ul>
<li>左值的生命周期在<strong>范围</strong>结束</li>
<li>右值的生命周期在<strong>本行</strong>接受</li>
<li>左值是<strong>持续值</strong></li>
<li>右值是<strong>暂时值</strong>
对于引用类型来说，</li>
<li>左值：<code>Type&amp;</code></li>
<li>右值：<code>Type&amp;&amp;</code>
<strong>重载<code>&amp;</code> <code>&amp;&amp;</code>以区分左值引用与右值引用</strong></li>
</ul>
<h3 id="112-移动语义">11.2 移动语义
</h3><ul>
<li>Move constructor
<ul>
<li><code>Type::(Type&amp;&amp; other)</code></li>
</ul>
</li>
<li>Move assignment operator
<ul>
<li><code>Type&amp; Type::operator=(Type&amp;&amp; other)</code>
一般来说，编译器会决定使用<code>&amp;</code>还是<code>&amp;&amp;</code>，但这一定是最有效率的吗？事实上，若我们知道一个值就是<strong>临时的</strong>，不妨主动使用移动语义。
要想显式删除移动语义，可以使用</li>
</ul>
</li>
<li>Move constructor
<ul>
<li><code>Type::(Type&amp;&amp; other) = delete;</code></li>
</ul>
</li>
<li>Move assignment operator
<ul>
<li><code>Type&amp; Type::operator=(Type&amp;&amp; other) = delete;</code></li>
</ul>
</li>
</ul>
<h3 id="113-smfs">11.3 SMFs
</h3><p>目前为止，我们已经学习了许多Special Member Functions</p>
<ul>
<li><code>Type::Type(const Type&amp; other);</code></li>
<li><code>Type&amp; Type::operator=(const Type&amp; other);</code></li>
<li><code>Type::Type(Type&amp;&amp; other);</code></li>
<li><code>Type&amp; Type::operator=(Type&amp;&amp; other);</code></li>
<li><code>~Type::Type();</code>
但我们在写每个类的时候都需要把他们都写出来吗？
不需要</li>
<li>Rule of Zero
若类不需要管理内存（或其他外部资源），编译器会创造有效的SMFs的</li>
<li>Rule of Three
若类需要管理内存，必须定义<code>copy assignment/constructor</code>即<code>Destructor</code> <code>Copy Assignment</code> <code>Copy Constructor</code>，若不定义这些，编译器不会复制底层资源</li>
<li>Rule of Five
若定义了<code>copy assignment/constructor</code>即<code>Destructor</code> <code>Copy Assignment</code> <code>Copy Constructor</code>，则也应该定义<code>move constructor/assignment</code>，即<code>Move Assignment</code> <code>Move Constructor</code>
这不是必须的，但若不定义，则代码可能会在包含一些不必要的复制时变得缓慢</li>
</ul>
<h2 id="12-stdoptional--type-safety">12. std::optional &amp; type safety
</h2><h3 id="121-type-safety">12.1 Type safety
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">div_3</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">div_3</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就是一个类型错误，函数需要的是<code>int</code>类型的参数，但给的是个<code>string</code>，编译器会给出错误，永远不会运行。</p>
<h3 id="122-stdoptional-t-">12.2 std::optional&lt; T &gt;
</h3><p><code>std::optional</code>是一个模板类要么包含一个类型为T的值，要么什么也不包含，对于不包含的情况会表示为<strong>nullopt</strong>
nullopt是一个可以转换为任意可选类型的值的对象</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">num1</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">//num1 does not have a value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">num1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//now it does!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">num1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span> <span class="c1">//now it doesn&#39;t anymore
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::optional</code>含有以下接口</p>
<ul>
<li><code>.value()</code>:
returns the contained value or throws <code>bad_optional_access</code> error</li>
<li><code>.value_or(valueType val)</code>
returns the contained value or default value, parameter <code>val</code></li>
<li><code>.has_value()</code>
returns true if contained value exists, false otherwise
优点</li>
<li>函数签名创建更多有意义的contracts</li>
<li>调用类函数时，会有更多保证和有效的行为
缺点</li>
<li>需要在任何地方使用<code>.value()</code></li>
<li>有可能存在<code>bad_optional_access</code></li>
<li>optionals会有未定义的行为（错误检查）</li>
<li>有很多情况我们想要<code>std::optional&lt;T&amp;&gt;</code>这个引用类型，但是C++并没有提供</li>
</ul>
<h3 id="123-总结">12.3 总结
</h3><ul>
<li>可以保证程序在一个严格的类型检查下进行</li>
<li><code>std::optional</code>是一个工具可以用<code>.has_value()</code>来返回一个值或nothing</li>
<li>这个应用并不广泛并且慢，所以C++大多数数据结构并没有<code>optional</code></li>
<li>不仅在类中使用，在应用程序代码中也可以使用，并且是很推荐的。</li>
</ul>
<h2 id="13-raii-smart-pointers-building-projects">13. RAII, Smart Pointers, Building Projects
</h2><h3 id="131-raiiresource-acquisition-is-initialization资源获取即初始化">13.1 RAII(Resource Acquisition Is Initialization)资源获取即初始化
</h3><h4 id="1311-exceptions">13.1.1 Exceptions
</h4><ul>
<li>异常是一种处理错误的方法，用于抛出异常</li>
<li><strong>thrown</strong></li>
<li>在非严重错误时捕捉异常用于继续代码进行</li>
</ul>
<h4 id="1312-raii">13.1.2 RAII
</h4><p>什么是RAII？</p>
<ul>
<li>一个类中所有使用的资源应该被构造函数所获取</li>
<li>一个类中所有使用的资源应该被析构函数所释放
为什么使用RAII？</li>
<li>通过遵守RAII政策，可以避免<strong>half-valid</strong>状态</li>
<li>无论怎样，析构函数总是会被调用在资源用完之后</li>
<li>资源/对象会立即运用当它们被创建</li>
</ul>
<h3 id="132-smart-pointers">13.2 Smart Pointers
</h3><p>对于RAII for locks，我们会用<code>lock_guard</code>，这会创建一个对象用于在构造函数中获取所有资源，并在析构函数中释放这些资源
而对于RAII for memory，我们也做同样的事情，只不过在这里我们称之为<strong>smart pointers</strong></p>
<ul>
<li><code>std::unique_ptr</code>
只属于这一个资源，不可以被复制</li>
<li><code>std::shared_ptr</code>
可以复制，当底层内存超出范围时，就会被破坏</li>
<li><code>std::weak_ptr</code>
一类旨在缓解循环依赖的指针</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 不要这么声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">uniquePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sharedPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">weak</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">wp</span> <span class="o">=</span> <span class="n">sharedPtr</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一定要使用<code>std</code>来make smart pointer</p>
<ul>
<li>如果不这么做，会分配两次内存，一次是为了声明一个指针，另一次是为了new一个对象</li>
<li>整个代码应该保持一个连续性，更易读</li>
</ul>
<h3 id="133-building-c-projects">13.3 Building C++ Projects
</h3><h4 id="1331-编译流程">13.3.1 编译流程
</h4><p>编写一个C++代码后，它要被翻译为机器代码以使编译器识别
<code>g++ main.cpp -o main</code></p>
<h4 id="1332-make">13.3.2 Make
</h4><p><strong>make</strong>是一个构建系统程序来帮助我们编译</p>
<ul>
<li>你可以规定编译器做什么</li>
<li>为了使用<strong>make</strong>需要有一个<strong>Makefile</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="c"># Compiler
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nv">CXX</span> <span class="o">=</span> g++
</span></span><span class="line"><span class="cl"><span class="c"># Compiler flags
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nv">CXXFLAGS</span> <span class="o">=</span> -std<span class="o">=</span>c++20
</span></span><span class="line"><span class="cl"><span class="c"># Source files and target
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nv">SRCS</span> <span class="o">=</span> <span class="k">$(</span>wildcard *.cpp<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nv">TARGET</span> <span class="o">=</span> main
</span></span><span class="line"><span class="cl"><span class="c"># Default target
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nf">all</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">$(</span>CXX<span class="k">)</span> <span class="k">$(</span>CXXFLAGS<span class="k">)</span> <span class="k">$(</span>SRCS<span class="k">)</span> -o <span class="k">$(</span>TARGET<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="c"># Clean up
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nf">clean</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	rm -f <span class="k">$(</span>TARGET<span class="k">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1333-cmake">13.3.3 CMake
</h4><p><strong>CMake</strong>是一个构建系统生成器，可以用CMake来生成Makefiles，就像一个Makefiles的高一层抽象
对于一个<code>CMakeList.txt</code>文件来说，存在以下内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">cmake_minimum_required(VERSION 3.10)
</span></span><span class="line"><span class="cl">project(cs106l_classes)
</span></span><span class="line"><span class="cl">set(CMAKE_CXX_STANDARD 20)
</span></span><span class="line"><span class="cl">file(GLOB SRC_FILES &#34;*.cpp&#34;)
</span></span><span class="line"><span class="cl">add_executable(main ${SRC_FILES})
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>set</code>为设定编译器版本为C++20</li>
<li><code>GLOB</code>告诉CMake搜索所有后缀为<code>cpp</code>的文件</li>
<li><code>add_executable</code>该命令将程序的所有源文件添加到可执行文件中
如何使用CMake？</li>
</ul>
<ol>
<li>拥有一个<code>CMakeLists.txt</code></li>
<li>创建一个<code>build</code>文件夹</li>
<li>运行CMake</li>
<li>运行make</li>
<li>执行文件<code>./main</code></li>
</ol>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
        
            <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
	const mainArticleElement = document.querySelector(".main-article");
        renderMathInElement(mainArticleElement, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>

    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/p/cs106l-winter2025-assignment7-unique-pointer/">
        
        

        <div class="article-details">
            <h2 class="article-title">CS106L Winter2025 Assignment7 Unique Pointer</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/cs106l-winter2025-assignment6-explore-courses/">
        
        

        <div class="article-details">
            <h2 class="article-title">CS106L Winter2025 Assignment6 Explore Courses</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/cs106l-winter2025-assignment5-treebook/">
        
        

        <div class="article-details">
            <h2 class="article-title">CS106L Winter2025 Assignment5 Treebook</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/cs106l-winter2025-assignment4-ispell/">
        
        

        <div class="article-details">
            <h2 class="article-title">CS106L Winter2025 Assignment4 Ispell</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/cs106l-winter2025-assignment3-make-a-class/">
        
        

        <div class="article-details">
            <h2 class="article-title">CS106L Winter2025 Assignment3 Make a Class</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <script
    src="https://giscus.app/client.js"
    data-repo="YuTaki23/YuTaki23.github.io"
    data-repo-id="R_kgDOOLOVVw"
    data-category="Announcements"
    data-category-id="DIC_kwDOOLOVV84CpOPn"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="light"
    data-lang="en"
    data-loading=""
    crossorigin="anonymous"
    async
></script>
<script>
    function setGiscusTheme(theme) {
        let giscus = document.querySelector("iframe.giscus-frame");
        if (giscus) {
            giscus.contentWindow.postMessage(
                {
                    giscus: {
                        setConfig: {
                            theme: theme,
                        },
                    },
                },
                "https://giscus.app"
            );
        }
    }

    (function () {
        addEventListener("message", (e) => {
            if (event.origin !== "https://giscus.app") return;
            handler();
        });
        window.addEventListener("onColorSchemeChange", handler);

        function handler() {
            if (document.documentElement.dataset.scheme === "light") {
                setGiscusTheme('light');
            } else {
                setGiscusTheme('dark_dimmed');
            }
        }
    })();
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 YuTaki. All rights reserved.
    </section>
    
    <section class="powerby">
        
            不会摄影的药师不是好程序员 <br/>
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
