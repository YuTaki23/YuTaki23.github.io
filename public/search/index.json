[{"content":"CS61B SP18 HW 1: Packages, Interfaces, Generics, Exceptions, Iteration 写在前面 本Homework取自UCB CS61B SP18的HW1。\n本HW需要我们从十分底层开始一步一步抽象直到最后完成一个模拟音乐的程序，很好的锻炼了我们对于Java项目的组织能力与Java的特性如继承与多态等。\n本文章为笔者在完成了所有任务后返回来写的，并非一步一步的思考，故少了许多碎碎念，多了一分严谨。但**是故弟子不必不如师，师不必贤与弟子。**若本文章存在错误或更好的想法，欢迎与我联系。\n点这里向我发邮箱~\n具体步骤 Task1: BoundedQueue 本任务向我们介绍了接口的概念，并要求我们完成一个名为BoundedQueue的一个接口，对于接口，我们声明它使用interface关键字，接口不用实现具体方法，只需要给出具体有什么具体方法（除了default）即可。在这里还需要将此接口作为包的一部分存在，大部分内容在任务要求已经告诉我们了，故可得，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package synthesizer; public interface BoundedQueue\u0026lt;T\u0026gt; { /** * @return 返回buffer的size */ int capacity(); /** * @return 返回当前buffer内有多少个items */ int fillCount(); /** * @param x 将x添加到最后 */ void enqueue(T x); /** * @return 删除并返回第一个item */ T dequeue(); /** * @return 返回但不要删除第一个item */ T peek(); } 本任务还要求我们完成两个default方法，十分显然，不赘述，具体可看我在下面写的注释，\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * @return 若当前buffer为空则返回true，否则返回false */ default boolean isEmpty() { return this.fillCount() == 0; } /** * @return 若当前buffer全满返回true，否则返回false */ default boolean isFull() { return this.capacity() == this.fillCount(); } Task 2: AbstractBoundedQueue 本任务要求我们实现一个继承上一个类的抽象类，即加上abstract与implements关键字，同时对于上文实现的两个default方法，需要在这里显式声明一下，并调用super方法其他跟着任务需求即可完成，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package synthesizer; public abstract class AbstractBoundedQueue\u0026lt;T\u0026gt; implements BoundedQueue\u0026lt;T\u0026gt; { protected int fillCount; protected int capacity; @Override public int capacity() { return this.capacity; } @Override public int fillCount() { return this.fillCount; } @Override public boolean isEmpty() { return BoundedQueue.super.isEmpty(); } @Override public boolean isFull() { return BoundedQueue.super.isFull(); } @Override public abstract T peek(); @Override public abstract T dequeue(); @Override public abstract void enqueue(T x); } Task 3: ArrayRingBuffer 本任务以类中TODO注释为顺序解释\nTODO1: Make sure to make this class a part of the synthesizer package 简单的显式声明一下属于这个包即可，\n1 package synthesizer; TODO2: Make sure to make this class and all of its methods public 确保一下类与方法均为public，教授已经帮我们做过了。\nTODO3: Make sure to make this class extend AbstractBoundedQueue\u0026lt; t \u0026gt; 这里改一下，t应该变成大写T，\n1 public class ArrayRingBuffer\u0026lt;T\u0026gt; extends AbstractBoundedQueue\u0026lt;T\u0026gt; TODO4: public ArrayRingBuffer(int capacity) 在这里需要我们完成类的构造函数，根据要求具体需要\n创建一个泛型数组 将first last fillCount均初始化为0 显式将capacity声明一下 对于泛型数组的初始化，需要记住的是强制转换为我们需要的类型，\n1 2 3 4 5 6 7 public ArrayRingBuffer(int capacity) { this.rb = (T[]) new Object[capacity]; this.first = 0; this.last = 0; this.fillCount = 0; this.capacity = capacity; } TODO5: public void enqueue(T x) 在开始这道题之前，需要先了解一下本任务中对队列的使用方法，我们可以将它简单想为一个循环数组，存在两个指针，first与last，初始值均为0，最大值可以到达此buffer的capacity。enqueue为在队列末尾添加一个元素，而每当我们添加一个元素时，就相当于在数组last的位置上添加了这个值，而此时last需要自增，值得注意的是，第一次添加的值的index并不一定是0，可以是任意小于capacity的值，故这里就需要我们考虑指针已经到达capacity了，但前面还没有被填满的情况，这里很想我们在proj1做过的循环头节点，只需要使用取模的方式就可以判断，那如何判断是否已经全部存储完了呢？只需要头指针与尾指针相等的情况下，就说明此时已经全部填完了，\n1 2 3 4 5 6 7 8 9 public void enqueue(T x) { if (isFull()) { throw new RuntimeException(\u0026#34;Ring buffer overflow\u0026#34;); } else { rb[last] = x; fillCount++; last = (last + 1) % capacity; } } TODO6: public T dequeue() 此题的大致内容与上题没什么两样，唯一值得注意的是，在取出队列的值时，是取出最前面的值，这也告诉我们，此时需要维护的是头指针，每去除一个值，头指针就需要自减一次，同样，也会存在到达0了但是后面还有内容没有取出来的情况，故还是需要用到取模，\n1 2 3 4 5 6 7 8 9 10 11 public T dequeue() { if (isEmpty()) { throw new RuntimeException(\u0026#34;Ring buffer underflow\u0026#34;); } else { T result = rb[first]; rb[first] = null; fillCount--; first = (first + 1) % capacity; return result; } } TODO7: public T peek() 此题需要我们仅返回队列第一个的内容，但不删除，简单的数组操作，不赘述，\n1 2 3 4 5 6 7 public T peek() { if (isEmpty()) { throw new RuntimeException(\u0026#34;Ring buffer underflow\u0026#34;); } else { return rb[first]; } } Task 4: GuitarString 本任务以TODO注释作为顺序来解答\nTODO1: Make sure to make this class a part of the synthesizer package 简单的声明包，不赘述，\n1 package synthesizer; TODO2: public GuitarString(double frequency) 本题需要我们创建一个buffer，其capacity为一个特殊值，并将此buffer内的所有值初始化为0，简单的迭代，\n1 2 3 4 5 6 7 8 9 10 public GuitarString(double frequency) { // TODO: Create a buffer with capacity = SR / frequency. You\u0026#39;ll need to // cast the result of this divsion operation into an int. For better // accuracy, use the Math.round() function before casting. // Your buffer should be initially filled with zeros. this.buffer = new ArrayRingBuffer\u0026lt;\u0026gt;((int) Math.round(SR / frequency)); for (int i = 0; i \u0026lt; buffer.capacity(); i++) { buffer.enqueue(0.0); } } TODO3: public void pluck() 本题需要我们将buffer内的值替换为一个[-0.5 - 0.5]的随机数，其中随机数必须每次都不一样，使用Math.Random()即可，简单的迭代，\n1 2 3 4 5 6 7 public void pluck() { for (int i = 0; i \u0026lt; buffer.capacity(); i++) { double r = Math.random() - 0.5; buffer.dequeue(); buffer.enqueue(r); } } TODO4: public void tic() 本题需要我们以Karplus-Algorithm为参考，即将队列的前两个值求平均值并乘能量衰减因子，并将此值替换为队列的前一个值，故这里可以看出来，对于第一个值要取出并返回，第二个值只需要返回即可不需要取出，因此，\n1 2 3 4 5 public void tic() { double firstItem = buffer.dequeue(); double secondItem = buffer.peek(); buffer.enqueue((firstItem + secondItem) * 0.5 * DECAY); } TODO5: public double sample() 本题需要我们返回队列当中的第二个值，但不需要取出，\n1 2 3 public double sample() { return buffer.peek(); } Task 5: Iteration and Exceptions BoundedQueue 修改类声明即可，不赘述\n1 public interface BoundedQueue\u0026lt;T\u0026gt; extends Iterable\u0026lt;T\u0026gt; ArrayRingBuffer 此题需要我们对iterator()的方法进行重写，迭代器包含三个方法，构造函数、hasNext()和next()，根据Josh教授的提示可以知道，\nprivate RingBufferIterator()只需要在这里添加一个计数器，以便之后判断是否到达边界即可。\npublic boolean hasNext()判断之后还有没有元素了，只需要判断此时的计数器是否到达了buffer中已有的元素数量。\npublic T next()求下一个元素的值，简单的数组操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import java.util.Iterator; public Iterator\u0026lt;T\u0026gt; iterator() { return new RingBufferIterator(); } private class RingBufferIterator implements Iterator\u0026lt;T\u0026gt; { private int current; private RingBufferIterator() { this.current = 0; } @Override public boolean hasNext() { return current != fillCount(); } @Override public T next() { T item = rb[current]; current++; return item; } } Exceptions 上文已完成，不赘述。\n详细内容可以看我的GitHub仓库\n关于这里的API Checker，若把关键字改为private则无法编译，故放弃。\n写在后面 总的来说本HW并不难，大多数已经给出步骤，只需要简单翻译即可。\n","date":"2025-03-22T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-hw-1-packages-interfaces-generics-exceptions-iteration/","title":"CS61B SP18 HW 1 Packages, Interfaces, Generics, Exceptions, Iteration"},{"content":"写在前面 本项目取自UCB CS61B SP18的Project1B，整体来说难度不大，主要是考察我们在已给出API的情况下完成任务，这或许是未来工作时很常见的工作流。本文章仅为笔者做题时的想法，如果存在错误或您有更好的想法，欢迎与我联系。\n点这里向我发邮件~\n具体思路 Task 1: Deque Interface 本任务主要是要我们创建一个类，即1A中完成的链表，并通过继承、接口等向我们介绍了Java的特性。笔者为不引发歧义，在这里使用Josh教授的代码，而非自己实现的，如果你对自己的代码有信心，也欢迎直接复制。综上，整体步骤不难，跟着提示一步一步来即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public interface Deque\u0026lt;Item\u0026gt; { public void addFirst(Item item); public void addLast(Item item); public boolean isEmpty(); public int size(); public void printDeque(); public Item removeFirst(); public Item removeLast(); public Item get(int index); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import java.util.LinkedList; import java.util.NoSuchElementException; public class LinkedListDeque\u0026lt;Item\u0026gt; extends LinkedList\u0026lt;Item\u0026gt; implements Deque\u0026lt;Item\u0026gt; { @Override public void printDeque() { System.out.println(\u0026#34;dummy\u0026#34;); } public Item getRecursive(int i) { return get(i); } @Override public Item removeFirst() { try { return super.removeFirst(); } catch (NoSuchElementException e) { return null; } } @Override public Item removeLast() { try { return super.removeLast(); } catch (NoSuchElementException e) { return null; } } } Task 2: wordToDeque 本任务需要我们创建一个新类，其中包括一个新方法，即将一个字符串变成一系列字符，并用链表连接起来，并完成测试，简单的迭代。\n1 2 3 4 5 6 7 8 9 10 public class Palindrome { public Deque\u0026lt;Character\u0026gt; wordToDeque(String word) { Deque\u0026lt;Character\u0026gt; deque = new LinkedListDeque\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; word.length(); i++) { char currentWord = word.charAt(i); deque.addLast(currentWord); } return deque; } } Task 3: isPalindrome Task 3A: isPalindrome Testing 本任务需要我们编写测试，即判断一个字符串是否为回文，运用assertTrue和assertFalse来判断，以下为我编写的测试，可能与你写的不一样，无伤大雅。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testIsPalindromeFalse() { assertFalse(palindrome.isPalindrome(\u0026#34;cat\u0026#34;)); assertFalse(palindrome.isPalindrome(\u0026#34;abc\u0026#34;)); assertFalse(palindrome.isPalindrome(\u0026#34;Aa\u0026#34;)); } @Test public void testIsPalindromeTrue() { assertTrue(palindrome.isPalindrome(\u0026#34;a\u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34;aba\u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34;aa\u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34; \u0026#34;)); assertTrue(palindrome.isPalindrome(\u0026#34;redder\u0026#34;)); } Task 3B: isPalindrome 本任务就需要我们具体实现这个方法了，思路为，一个字符串的字符数可能为奇数或偶数，只需要第一个与最后一个做判断，然后不断向中间靠拢即可，同时根据题意，还存在一个base case，即字符数为0或1的时候均判断为回文数，不难写出代码，\n1 2 3 4 5 6 7 8 9 10 11 12 public boolean isPalindrome(String word) { int length = word.length(); if (length != 0 \u0026amp;\u0026amp; length != 1) { Deque\u0026lt;Character\u0026gt; deque = wordToDeque(word); for (int i = 0, j = deque.size() - 1; i \u0026lt; deque.size() / 2; i++, j--) { if (deque.get(i) != deque.get(j)) { return false; } } } return true; } Task 4: Generalized Palindrome and OffByOne 在这里，题目向我们介绍了不仅有第一个字符与最后一个字符相同称为回文数，还存在其他类型的回文数，比如相差1位也被称为回文数，根据题目的顺序来写，不难写出，\n1 2 3 4 5 6 7 public class OffByOne implements CharacterComparator { @Override public boolean equalChars(char x, char y) { int diff = Math.abs(x - y); return diff == 1; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import org.junit.Test; import static org.junit.Assert.*; public class TestOffByOne { // You must use this CharacterComparator and not instantiate // new ones, or the autograder might be upset. static CharacterComparator offByOne = new OffByOne(); // Your tests go here. @Test public void testEqualCharsTrue() { assertTrue(offByOne.equalChars(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)); assertTrue(offByOne.equalChars(\u0026#39;r\u0026#39;, \u0026#39;q\u0026#39;)); assertTrue(offByOne.equalChars(\u0026#39;\u0026amp;\u0026#39;, \u0026#39;%\u0026#39;)); } @Test public void testEqualCharsFalse() { assertFalse(offByOne.equalChars(\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;)); assertFalse(offByOne.equalChars(\u0026#39;z\u0026#39;, \u0026#39;a\u0026#39;)); assertFalse(offByOne.equalChars(\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;)); } } 1 2 3 4 5 6 7 8 9 10 11 12 public boolean isPalindrome(String word, CharacterComparator cc) { int length = word.length(); if (length != 0 \u0026amp;\u0026amp; length != 1) { Deque\u0026lt;Character\u0026gt; deque = wordToDeque(word); for (int i = 0, j = deque.size() - 1; i \u0026lt; deque.size() / 2; i++, j--) { if (!cc.equalChars(word.charAt(i), word.charAt(j))) { return false; } } } return true; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testIsPalindromeWithCCFalse() { CharacterComparator cc = new OffByOne(); assertFalse(palindrome.isPalindrome(\u0026#34;ac\u0026#34;, cc)); assertFalse(palindrome.isPalindrome(\u0026#34;ok\u0026#34;, cc)); } @Test public void testIsPalindromeWithCCTrue() { CharacterComparator cc = new OffByOne(); assertTrue(palindrome.isPalindrome(\u0026#34;ab\u0026#34;, cc)); assertTrue(palindrome.isPalindrome(\u0026#34;flake\u0026#34;, cc)); assertTrue(palindrome.isPalindrome(\u0026#34;%\u0026amp;\u0026#34;, cc)); assertTrue(palindrome.isPalindrome(\u0026#34; \u0026#34;, cc)); } Task 5: OffByN 最后就要求我们更为通用的实现回文数了，主要包括一个构造函数与一个方法，与OffByOne没什么两样，具体实现如下，\n1 2 3 4 5 6 7 8 9 10 11 12 public class OffByN implements CharacterComparator { private int items; public OffByN(int N) { this.items = N; } public boolean equalChars(char x, char y) { int diff = Math.abs(x - y); return diff == this.items; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import org.junit.Test; import static org.junit.Assert.*; public class TestOffByN { static CharacterComparator offBy5 = new OffByN(5); static CharacterComparator offBy1 = new OffByN(1); @Test public void testEqualCharsFiveTrue() { assertTrue(offBy5.equalChars(\u0026#39;a\u0026#39;, \u0026#39;f\u0026#39;)); assertTrue(offBy5.equalChars(\u0026#39;f\u0026#39;, \u0026#39;a\u0026#39;)); } @Test public void testEqualCharsFiveFalse() { assertFalse(offBy5.equalChars(\u0026#39;h\u0026#39;, \u0026#39;f\u0026#39;)); } } 总的代码实现可以看我的GitHub仓库\n写在后面 总的来说并不难，比上一个1A好多了:(\n","date":"2025-03-15T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-project1b-applying-and-testing-data-structures-version-1.0/","title":"CS61B Project1B Applying and Testing Data Structures version 1.0"},{"content":"[YuTaki] CS61B SP18 Project1A: Data Structure 写在前面 本项目取自CS61B SP18的Project1A，仅为个人做题时的思路及想法，如果有更好的想法，欢迎与我联系。\n点这里向我发邮件\n具体思路 LinkedListDeque public LinkedListDeque() 在最开始初始化链表时，大家就应该把思路理清楚。Josh教授在LinkedListDeque这一部分推荐我们使用两个方法来实现，第一个是two sentinel topology，第二个是circular sentinel topology，在这里笔者使用的方法是第二个也是Josh教授推荐我们使用的方法。\n首先大家先看看上半部分，是初始化链表很重要的一部分，我们可以看出来，在这个类中，存在两个实例变量size和sentinel，以及若干方法，同时还存在一个Nested ClassIntNode，这是十分显而易见的，如果不清楚为什么这么做，建议看一下Josh教授的SLList实现，由此我们就可以写出来一部分代码，即\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class LinkedListDeque\u0026lt;T\u0026gt; { private class IntNode { public IntNode prev; public T item; public IntNode next; public IntNode(IntNode p, T i, IntNode n) { this.prev = p; this.item = i; this.next = n; } } private IntNode sentinel; private int size; } 关键点来了，在做完这些后，就该开始初始化链表了。仔细观察一下，sentinel一共存在三个变量，prev item next，我的想法是，sentinel一直指向的是item，而我们需要做的是将这些箭头用编程语言翻译出来。首先看next的那个箭头，它指向的是prev而prev又指向了item，所以可以翻译为sentinel.next = sentinel，再看prev的箭头，即sentinel.prev = sentinel。由此我们就做完了。\n1 2 3 4 5 6 public LinkedListDeque() { sentinel = new IntNode(null, null, null); sentinel.next = sentinel; sentinel.prev = sentinel; size = 0; } 有同学可能会想，为什么不可以在new的时候就把正确的填上去，而是要加上null，毫无意义。一开始整个节点还没有被创建出来，指向一个不存在的东西或许会造成空指针异常。\npublic void addFirst(T item) 在考虑addFirst时，应该清楚一点，在这里应该使用更为通用的方法，即当前已经存在了一个IntNode，我们需要再另外添加一个，这不会像仅存在一个sentinel一样，具有特殊性。对于此题，画图是一个很好的方法，我在这里简易的画了一个，不喜勿喷。\n我们需要添加的是这个5，一步一步来看。首先要初始化一个IntNode，并且还是添加到第一位，那么一定是sentinel.next = new IntNode()，那么括号里具体应该填什么？我创建的参数第一个为新Node的prev，那现在来看，prev代表的就是sentinel本身；第二个参数为变量item，在此不赘述；第三个参数为next，那现在这个next指向的是原先的sentinel.next。至此，我们两个指向右边的箭头就已经全部翻译完毕。\n接下来看看指向左边的两个箭头。首先第一个箭头，即sentinel.next = sentinel.next.prev；第二个箭头，即sentinel.next.next.prev = sentinel.next。\n而最后一个sentinel.prev的箭头则与一开始没有不同，所以不用变化。\n综上可得，\n1 2 3 4 5 public void addFirst(T item) { sentinel.next = new IntNode(sentinel, item, sentinel.next); sentinel.next.next.prev = sentinel.next; size++; } public void addLast(T item) 本题与上题大差不差，唯一需要变得是sentinel.prev，应该由这个来引出。\n1 2 3 4 5 public void addLast(T item) { sentinel.prev = new IntNode(sentinel.prev, item, sentinel); sentinel.prev.prev.next = sentinel.prev; size++; } public boolean isEmpty() 这道题就很简单了，还记得我们上文提到的size变量吗，每当加一个变量时size++，反之size--，判断size是否为0即可。\n1 2 3 public boolean isEmpty() { return size == 0; } public int size() 与上题类似，不赘述。\n1 2 3 public int size() { return size; } public void printDeque() 打印所有IntNode的item，用空格分开，由size可知共有多少项，需要注意的是，还要判断一个base case，简单的迭代。\n1 2 3 4 5 6 7 8 9 10 public void printDeque() { IntNode currentNode = sentinel.next; if (size == 0) { return; } for (int i = 0; i \u0026lt; size; i++) { System.out.print(currentNode.item + \u0026#34; \u0026#34;); currentNode = currentNode.next; } } public T removeFirst() 首先一个base case，若size == 0 return null。再看看上面的图，对于第一个元素，控制他的一定是sentinel.next，所以要在这上面做文章，首先要把next从sentinel之后的第一个元素改变为第二个元素，即sentinel.next = sentinel.next.next.prev = sentinel，这代表的是第二个元素指向第一个元素变成第二个元素（现在的第一个元素）指向sentinel；其次，现在要把sentinel.next指向原先的第二个元素，即sentinel.next = sentinel.next，综上，\n1 2 3 4 5 6 7 8 9 10 11 public T removeFirst() { if (size == 0) { return null; } else { IntNode currentNode = sentinel.next; sentinel.next.next.prev = sentinel; sentinel.next = sentinel.next.next; size--; return currentNode.item; } } public T removeLast() 与上文相反，举一反三即可，\n1 2 3 4 5 6 7 8 9 10 11 public T removeLast() { if (size == 0) { return null; } else { IntNode currentNode = sentinel.prev; sentinel.prev.prev.next = sentinel; sentinel.prev = sentinel.prev.prev; size--; return currentNode.item; } } public T get(int index) 简单的迭代。\n1 2 3 4 5 6 7 8 9 10 11 public T get(int index) { if (index \u0026gt; size) { return null; } else { IntNode currentNode = sentinel.next; for (int i = 0; i \u0026lt; index; i++) { currentNode = currentNode.next; } return currentNode.item; } } public T getrecursive(int index) 这道题需要我们用递归实现get，只用一个get是没法实现递归的，没办法读取元素，需要添加另一个函数，不断递归到达目的地以读取元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private T getRecursive(int index, IntNode temp) { if (index == 0) { return temp.item; } else { return getRecursive(index - 1, temp.next); } } public T getRecursive(int index) { IntNode currentNode = sentinel.next; if (index \u0026gt;= size) { return null; } else { return getRecursive(index, currentNode); } } ArrayDeque 对于此类，我的想法是首先使用Josh教授特别推荐的circular sentinel，其次先把整体思路写出来，最后再做resize部分。\npublic ArrayDeque() 首先来观察一下这幅图，不难看出，题目首先要求我们将数组初始化为可以存放8个内容的数组；对于此类，还存在四个实例变量，分别是size nextFirst items 以及 nextLast，并且Josh教授还把nextFirst和nextLast分别存为了4和5，不过在这里未来的我回过头告诉我，这里应该把8添加一个变量名，由此可以得出，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class ArrayDeque\u0026lt;T\u0026gt; { private int size; private int nextFirst; private T[] items; private int nextLast; private static final int initCapacity = 8; private int capacity; public ArrayDeque() { this.size = 0; this.nextFirst = 4; this.items = (T[]) new Object[initCapacity]; this.nextLast = 5; } } public void T addLast(T item) 将这幅图与上一幅图相比较，可以看出addLast是如何工作的，原先nextLast是5，而现在所添加的元素，到了数组5的位置，nextLast自增，但是我们想一下特殊情况，如果nextLast到了最后也就是7的位置，这时候再有一个addLast该怎么办呢？slide给出的答案是，nextLast会到0的位置上，由此就可以看出，所添加的元素要放在当前nextLast的位置上，由此，不难写出代码，\n1 2 3 4 5 6 7 8 9 public void addLast(T item) { items[nextLast] = item; if (nextLast == initCapacity - 1) { nextLast = 0; } else { nextLast++; } size++; } public void T addFirst(T item) 与上题大体相似，没有什么不同，在此不做过多赘述。\n1 2 3 4 5 6 7 8 9 public void addLast(T item) { items[nextLast] = item; if (nextLast == initCapacity - 1) { nextLast = 0; } else { nextLast++; } size++; } public boolean isEmpty() 简单的判断。\n1 2 3 public boolean isEmpty() { return size == 0; } public int size() 与上文一样，没有什么不同。\n1 2 3 public int size() { return size; } public void printDeque() 此题需要我们打印整个连边，首先很容易想到有一个base case，当链表里面没有东西的时候，直接返回；其次我们需要明白的一点是，数组01234的顺序并不是我们链表的顺序，所以不能简单的迭代打印整个数组，观察教授给我们的提示，\n我们可以看到现在的链表顺序为右上角的Conceptual Deque，而我们数组的顺序跟这个是不一样的，链表的第一个应该是nextFirst + 1，但这里又会有问题，如果现在nextFirst在最后面该怎么办呢？所以这里又需要我们做一个判断，现在我们知道了初始点，那应该在什么时候结束呢？可以发现，nextFirst会不断自增，直到到达最开始的地方，所以在这里我们就可以用一个变量来表示，这个函数用了很多次，我们不妨把它抽象出来，由此我们上面的函数也可以引用这一层抽象，更新为，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 private int plus(int index) { if (index == capacity) { index = 0; } else { index++; } return index; } private int minus(int index) { if (index == 0) { index = capacity - 1; } else { index--; } return index; } public void addFirst(T item) { items[nextFirst] = item; nextFirst = minus(nextFirst); size++; } public void addLast(T item) { items[nextLast] = item; nextLast = plus(nextLast); size++; } public void printDeque() { if (size == 0) { return; } int index = nextFirst; index = plus(index); while (index != nextFirst) { System.out.print(items[index] + \u0026#34; \u0026#34;); index = plus(index); } } public T removeFirst() 首先一个很明显的base case，链表为空时，return null，根据上图可以看出来，第一个元素是位于nextFirst + 1的元素，首先，我们要把这个元素设为null，然后，还要把nextFirst再往后移动一位，所以不难写出，\n1 2 3 4 5 6 7 8 9 10 public T removeFirst() { if (size == 0) { return null; } int current = plus(nextFirst); nextFirst = current; items[nextFirst] = null; size--; return items[current]; } public T removeLast() 这道题与上一道题差别不大，举一反三即可，\n1 2 3 4 5 6 7 8 9 10 public T removeLast() { if (size == 0) { return null; } int current = minus(nextLast); nextLast = current; items[nextLast] = null; size--; return items[current]; } public T get(int index) 这道题确实没想明白，参考了别人的答案，还是想不通。\nresize 接下来，就应该想想可变数组的想法了。题目告诉我们，对于长度大于等于16的数组，应该一直保持使用系数为25%，即若当前有16个元素，那我们的数组长度应当为64，\n根据这幅图可以看出来，我们需要把前一半元素放在新数组的开头，把后一半元素放在新数组的结尾\nresize对于我来说有点困难了，跳过。\n写在后面 LinkedListDeque不难，看图就可以看个大概。ArrayDeque的resize部分有点困难了，未来再说吧。\n","date":"2025-03-12T00:00:00Z","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-project1a-data-structure/","title":"CS61B SP18 Project1A Data Structure"},{"content":"[YuTaki] Make Life More Regular——听歌篇 一、写在前面 让生活更有条理性。\n作为Make Life More Regular的第一篇内容，笔者选择了每天都会做的一件事——听歌。\n你是否还在烦恼自己的歌怎么在平台上突然没有版权了？\n你是否还在厌倦听歌时看着不同的人发着不同的“emo文字”？\n本文章仅为笔者自己平时的听歌流，主要方式为将网络音乐下载到本地进行收听，本文章会主要讲解以什么方式下载以及更优雅的设置听歌方式。\n本文章仅代表笔者个人观点，主观性很强，一千个读者有一千个哈姆雷特。\n若本文章出现了什么错误或您有更好的想法，欢迎与我联系。\n[点这里向我发邮箱~](mailto: yutaki23@163.com)\n二、运行设备与主要应用 操作系统：Android12 OriginOS Salt Palyer 极其优秀的安卓本地音乐播放器，其简洁但不失重要功能深受笔者喜爱。 bilidown 一款简洁易下载哔哩哔哩视频的软件。应作者要求，在此不贴上软件地址，有需要的请自行寻找。 MusicTag 可将本地音乐的歌曲名、作者、专辑、歌词等信息作为元数据导入到歌曲中。在Salt Player中可以读取出来。 三、主要优点与缺点 优点 长期存在。不用再担心自己的歌曲会被版权收掉，只要歌曲一直存在本地，只要硬盘不损坏，歌曲就不会有丢失的一天。 简单干净的页面。不用在听歌的时候看网友所谓的“丧语录”。 缺点 对新歌的感知弱。新歌发布后无法第一时间接收到消息，只能由他人推荐，或自己随缘找到。 四、操作步骤 **找到你喜欢的歌。**一般来说，大家喜欢听的歌都可以在互联网上找到，包括但不限于哔哩哔哩、抖音、YouTube等媒体播放网站。笔者在这里以哔哩哔哩和《麦恩莉》为例。将这首歌的网站复制下来，得到类似于这样的https://www.bilibili.com/video/BVxxxxxx/1一个网站。 下载歌曲。打开bilidown。将网站复制进去，即可得到类似于这样的界面。随后点击音频按钮即可开始下载，注意到，可以提前将音质调为192k，这样音质会更好。之后，会调出下载界面，此处笔者建议统一将文件名改为歌曲名-作者.m4a，这都是为了之后添加歌曲信息时更加方便。 **将元数据导入到歌曲中。**打开MusicTag，会看到这些内容，作为使用了很长时间的人来说，我给出的建议是： **改变工作目录。**将其改为你下载歌曲的文件夹。 自动匹配标签。全选你所下载的歌曲，让软件自动识别其标题、艺术家等内容。 检查。大致查看各元数据是否能对的上，如果不，单独找出来在左侧修改错误的内容，如果是封面错误，点击改变封面选择正确的封面，如果是歌词错误，点击改变歌词选择正确的歌词。笔者的经验是，如果一首歌的封面错误，那大概率歌词也有错，其他信息大概率都有错。最后不要忘记右键保存。 将歌曲传到手机上。笔者的建议为在手机上创建一个Music文件夹，用来专门存放下载的歌曲。打开Salt Player，点击左上角，左侧会出现扫描音乐选项，使用自定义文件夹，将其设置为下载歌曲的文件夹，点击开始扫描。\n**Congratulation!**此时，你就可以发现，你的歌曲已经到了Salt Player里面，并且标题、作者、专辑、封面等内容应有尽有。\n五、写在后面 大致的操作步骤就这些，有关这些应用的其他进阶操作，欢迎各位自己摸索。\n最后，感谢每一位创建这些软件的作者，希望大家尊重开源，享受开源。开源世界有你更精彩。\n六、相关问题 **问：**我只能使用各大网站下载的歌曲吗？\n答：当然不，如果你能找到Flac等更高级的格式当然是最好不过，但请不要在手机上直接下载听歌软件上的歌曲，大部分都有加密，过了VIP期限后就无法再听了。\n问：为什么后缀一定要改成m4a的格式，改成其他的不行吗？\n答：根据笔者尝试，使用mp3格式时会在将元数据导入歌曲中出现问题，其他格式还没有尝试过，有尝试过的朋友可以补充。\n问：为什么要在手机上创建一个新的文件夹？\n答：现在人的手机上大概率会有录音等其他非歌曲内容，Salt Player在识别的时候会将这些内容也识别为歌曲，而创建一个文件夹就可以让Salt Player只识别当前文件夹的内容。\n此网站非正确网站，在此仅为示例，替换成你所找到的歌曲的网站即可。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-03-12T00:00:00Z","permalink":"https://YuTaki23.github.io/p/make-life-more-regular-%E5%90%AC%E6%AD%8C%E7%AF%87/","title":"Make Life More Regular —— 听歌篇"},{"content":"写在前面 本项目取自 UCB CS61B SP18的Project0: NBody Simulation。作为CS61系列的第二门课，专注于数据结构与算法，本项目只是对Java有了个简单的认识。以下为笔者做题时的心得体会，如有错误或更好的想法，欢迎与我联系。\n点这里向我发邮件~\n具体实现 ###The Planet Class and Its Constructor\n这道题让我们了解了Planet这个类具体代表什么，存在哪些参数，还需要创建两个构造函数，两个拥有不同参数的构造函数。\n创建实例变量。在这个类里面按照题目要求一步一步写即可。 创建构造函数1。这个构造函数存在六个不同的参数，按照题目要求写好签名，在构造函数内部使用this即可完成。 创建构造函数2.这个构造函数存在一个参数，即一个已被实例化的Planet，需要将此Planet复制到新Planet中，使用this与p.点表达式即可完成。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Planet { public double xxPos; public double yyPos; public double xxVel; public double yyVel; public double mass; public String imgFileName; public Planet(double xP, double yP, double xV, double yV, double m, String img) { this.xxPos = xP; this.yyPos = yP; this.xxVel = xV; this.yyVel = yV; this.mass = m; this.imgFileName = img; } public Planet(Planet p) { this.xxPos = p.xxPos; this.yyPos = p.yyPos; this.xxVel = p.xxVel; this.yyVel = p.yyVel; this.mass = p.mass; this.imgFileName = p.imgFileName; } } Understanding the Physics 在这里题目向我们介绍了此项目用到的物理知识，都是简单的高中物理知识，我在这里简单说一下。\n万有引力公式。两个粒子之间存在相互吸引的力，大小为$F = \\dfrac{G \\cdot m_1 \\cdot m_2}{r^2}$，方向指向对方。 勾股定理。$r^2 = dx^2 + dy^2$。 在x轴上的力。$F_x = \\dfrac{F \\cdot dx}{r}$。 在y轴上的力。$F_y = \\dfrac{F \\cdot dy}{r}$。 合外力。即同一方向上的力的和。 加速度。$a_x = \\dfrac{F_x}{m}$ $a_y = \\dfrac{F_y}{m}$。 Writing the Planet Class calcDistance 此方法需要我们计算两行星之间的距离，运用勾股定理即可，值得注意的是，此题需要我们在一个Planet上使用点表达式来对另一个行星求解，也就是说，此题无法用static关键字。\n1 2 3 4 5 6 7 8 9 10 public double calcDistance(Planet p) { double x1 = this.xxPos; double y1 = this.yyPos; double x2 = p.xxPos; double y2 = p.yyPos; double xAbs = Math.abs(x1 - x2); double yAbs = Math.abs(y1 - y2); return Math.sqrt((xAbs * xAbs) + (yAbs * yAbs)); } clacForceExertedBy 此方法需要我们计算两行星之间的万有引力，运用上文提到的万有引力公式即可，值得注意的是，此题向我们介绍了一个新的语法static final也即常量，同时也介绍了科学计数法的写法。在这里我们可以将万有引力常数G用科学计数法设为常量。\n1 2 3 4 5 private static final double G = 6.67e-11; public double calcForceExertedBy(Planet p) { double radiusSquare = this.calcDistance(p) * this.calcDistance(p); return (G * this.mass * p.mass) / radiusSquare; } calcForceExertedByX and calcForceExertedByY 此方法需要我们计算两行星之间在x轴方向与在y轴方向上的力，用到的公式即为上文中的3 4两条，值得注意的是，在计算两行星之间的位移差时要注意哪个在前哪个在后。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public double calcForceExertedByX(Planet p) { double distanceX = p.xxPos - this.xxPos; double force = this.calcForceExertedBy(p); double radius = this.calcDistance(p); return (force * distanceX) / radius; } public double calcForceExertedByY(Planet p) { double distanceY = p.yyPos - this.yyPos; double force = this.calcForceExertedBy(p); double radius = this.calcDistance(p); return (force * distanceY) / radius; } calcNetForceExertedByX and calcNetForceExertedByY 此方法需要我们完成一系列行星对一个行星所施加的x轴与y轴方向的合分力（不知道也没有这个东西），值得注意的是，可以用到enhanced for来锻炼自己，以及continue用法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public double calcNetForceExertedByX(Planet[] planets) { double sumForce = 0; for (Planet p : planets) { if (this.equals(p)) { continue; } else { sumForce += this.calcForceExertedByX(p); } } return sumForce; } public double calcNetForceExertedByY(Planet[] planets) { double sumForce = 0; for (Planet p : planets) { if (this.equals(p)) { continue; } else { sumForce += this.calcForceExertedByY(p); } } return sumForce; } update 此方法需要我们计算经过一系列力之后，行星最终会到什么地方去，看着题目很长，实际上很简单，跟着题目给的步骤一步一步做即可，值得注意的是，此题不需要返回任何东西，只是在目前行星更新自己。\n1 2 3 4 5 6 7 8 9 10 public void update(double dt, double fX, double fY) { double accelerationX = fX / this.mass; double accelerationY = fY / this.mass; this.xxVel += dt * accelerationX; this.yyVel += dt * accelerationY; this.xxPos += dt * this.xxVel; this.yyPos += dt * this.yyVel; } Getting Started with the Simulator (NBody.java) ReadRadius 此题需要我们读取一个文件中的半径，根据题目可知，半径在一个文件中的第二位，以double形式存储。观察BasicInDemo.java不难发现，对于In这个类来说，是按顺序来查找文件中的每个变量，并且要以符合的形式来控制，值得注意的是，在这里要加上static关键字，综上易得。\n1 2 3 4 5 public static double readRadius(String filename) { In in = new In(filename); int firstItemInFile = in.readInt(); return in.readDouble(); } ReadPlanets 此题与上题类似，需要我们用In来不断读取内容，得到Planet的全部内容，并将其实例化为一个新的Planet，这里会用到Planet的构造函数1，可以得到，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static Planet[] readPlanets(String filename) { In in = new In(filename); int totalPlanets = in.readInt(); Planet[] planets = new Planet[totalPlanets]; double radius = in.readDouble(); for (int i = 0; i \u0026lt; totalPlanets; i++) { double xP = in.readDouble(); double yP = in.readDouble(); double xV = in.readDouble(); double yV = in.readDouble(); double m = in.readDouble(); String img = in.readString(); planets[i] = new Planet(xP, yP, xV, yV, m, img); } return planets; } Drawing the Initial Universe State (main) Collecting All Needed Input 跟着步骤一步一步来即可，很容易。\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) { String TString = args[0]; String dtString = args[1]; String filename = args[2]; double T = Double.parseDouble(TString); double dt = Double.parseDouble(dtString); Planet[] planets = readPlanets(filename); double radius = readRadius(filename); } Drawing the Background 观察StdDrawDemo.java即可知道如何创建scale与background，跟着Demo走即可。\n1 2 3 4 5 6 private static final String imgPath = \u0026#34;images/starfield.jpg\u0026#34;; StdDraw.setScale(-radius, radius); StdDraw.clear(); StdDraw.picture(0, 0, imgPath); StdDraw.show(); Drawing One Planet 使用StdDraw.picture()即可，题目要求在行星自己的位置上画自己，即xxPos与yyPos和imgFileName.\n1 2 3 public void draw() { StdDraw.picture(xxPos, yyPos, \u0026#34;images/\u0026#34; + imgFileName); } Drawing All of the Planets 简单的迭代\n1 2 3 for (Planet planet : planets) { planet.draw(); } Creating an Animation 步骤都给出来了，写到后面也累了，大家自己看看吧（逃）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 StdDraw.enableDoubleBuffering(); double time = 0; while (time \u0026lt; T) { double[] xForces = new double[planets.length]; double[] yForces = new double[planets.length]; for (int i = 0; i \u0026lt; planets.length; i++) { xForces[i] = planets[i].calcNetForceExertedByX(planets); yForces[i] = planets[i].calcNetForceExertedByY(planets); } for (int j = 0; j \u0026lt; planets.length; j++) { planets[j].update(dt, xForces[j], yForces[j]); } StdDraw.clear(); StdDraw.picture(0, 0, imgPath); for (Planet planet : planets) { planet.draw(); } StdDraw.show(); StdDraw.pause(10); time += dt; 写在后面 本项目已完成，用时大约四小时，当然这也不是我第一次做:( ，作为第二个复习课程的第一个项目，整体难度并不大，大部分代码框架与提示都已给出，跟着题目走即可。\n点这里查看GitHub代码\n","date":"2025-03-08T00:00:00Z","image":"https://YuTaki23.github.io/p/cs61b-sp18-project0-nbody-simulation/image1_hu_d8ded748ccf5e499.png","permalink":"https://YuTaki23.github.io/p/cs61b-sp18-project0-nbody-simulation/","title":"CS61B SP18 Project0 Nbody Simulation"},{"content":"写在前面 本项目为UC Berekly CS61A SP24的 Project4: Scheme。以下为个人对此项目的见解，如有错误或更好的解决方案，欢迎与我联系。\n点这里向我发邮件~\n具体思路 Problem 1 首先通读一下题目，此题需要我们完成两个函数define和lookup，同时给了我们关于Frame的一些信息，Frame有两个instance attribute。\nbindings 这是一个字典，回顾一下字典的相关内容，字典，相当于其他语言的map，存在一个key和一个value，每个字典当中只能有一个唯一的key，但key中存放的数据可以是相同的。此题中，key就代表的是symbol，而value代表的就是其本意，相当于我们在python当中的等号赋值用法，例如，x = 3在这里key就是x，value就是3。 parent 每个frame都可以被嵌套在另一个frame里面，而他们最终的frame都是None。 define 非常显而易见了，上文中也提到过，在此不再赘述。\n1 2 3 def define(self, symbol, value): \u0026#34;\u0026#34;\u0026#34;Define Scheme SYMBOL to have VALUE.\u0026#34;\u0026#34;\u0026#34; self.bindings[symbol] = value lookup 此函数可以想成三个case，题目当中也给了我们很详细的描述。\n若symbol在当前frame里，直接返回value。 若symbol不在当前frame里，且其含有父frame，且父frame里含有此symbol，返回value。关于这个case，有几点需要说明 其含有父frame。问：如何界定此frame是否合法？答：只要不为None，都是合法的。 父frame里含有symbol。问：如何访问父frame？答：用点表达式访问parent即可。 若均不满足以上情况，即symbol不在当前frame里，且没有父frame，arise error。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def lookup(self, symbol): \u0026#34;\u0026#34;\u0026#34;Return the value bound to SYMBOL. Errors if SYMBOL is not found.\u0026#34;\u0026#34;\u0026#34; current_frame = self # case1 若symbol在当前frame if symbol in current_frame.bindings: return current_frame.bindings.get(symbol) # case2 symbol不在当前frame 但在parent frame else: current_frame = current_frame.parent while current_frame is not None: if symbol in current_frame.bindings: return current_frame.bindings.get(symbol) current_frame = current_frame.parent # case3 都不存在 引发error raise SchemeError(\u0026#39;unknown identifier: {0}\u0026#39;.format(symbol)) Problem 2 首先通读一下题目，此题要求我们实现一个scheme_apply函数中的一个case，即BuiltinProcedure。在完成一个表达式时，存在内置的一些操作如 + - * /等，在此，就需要我们实现这些操作。\nBuiltinProcedure含有两个instance attribute。\npy_func 找到对应的操作符号，用python的内置函数来实现表达式，不用我们自己实现（自己似乎也实现不了，有点不切实际）。 need_env 有些内置函数需要特定的环境。 此题可分为三个步骤来写，题目中也给的很清楚。\n将scheme list 转变为python list，与上题很类似。 判断need_env的是否，很简单。 使用*args表示法来调用py_func这里可能需要了解一下什么是 *args表示法。 1 2 3 4 5 6 7 8 9 10 11 12 13 try: # 将scheme list转变为 python list lst = [] while args is not nil: lst.append(args.first) args = args.rest # 判断 need_env if procedure.need_env is True: lst.append(env) # 调用 py_func return procedure.py_func(*lst) except TypeError as err: raise SchemeError(\u0026#39;incorrect number of arguments: {0}\u0026#39;.format(procedure)) Problem 3 此题需要让我们将scheme_eval补充完整，大致题目已给出，我们需要完成的是判断此表达式，并通过上文完成的scheme_apply函数来计算结果。题目还是给了我们大致思路。\n判断operator，使用递归。Recrusion，即自身调用自身，那一定是在scheme_eval函数里调用scheme_eval。对于此函数，我们需要三个参数，expresson environment以及一个默认参数，文中给了我们代码提示first = expr.first，由此即可以判断此处的expression = first，同时还要求我们evaluate to a procedure instance。scheme_apply的开头就给了我们提示 判断operands，依旧使用递归。与上文类似，题目已经给了我们rest = expr.next，同时题目要求我们收集到scheme列表里，下文有提示，使用Pair的map方法，观察map方法，这提供了一个形参fn，显然此处的fn就是scheme_eval，但scheme_eval存在两个形参，这就需要我们进行转换，使用lambda函数。 之后就是调用scheme_apply，很显然，在此不做过多赘述。 1 2 3 4 5 6 7 else: # evaluate operator procedure = scheme_eval(first, env) validate_procedure(procedure) # evaluate operand operands = rest.map(lambda x: scheme_eval(x, env)) return scheme_apply(procedure, operands, env) Problem 4 此题要求我们实现define，简单来说，就是将一个expressions赋值给一个symbol。我们在这里只需要实现第一个部分，即计算一个表达式作为expressions并复制给一个提供给我们的symbol，下方还有提示，需要我们用到Frame里的define。那我们想一想define函数需要我们提供什么参数呢？\nsymbol symbol总是存在于一个表达式的第一位，函数也给了我们一个提示，即signature = expressions.first，由此我们就可以看出我们的symbol就是这个。 expressions 对于一个表达式来说，我们需要赋值的不仅仅是表达式本身，还是它计算后的数值是什么，所以在这里我们还需要用到上文完成的scheme_eval函数。 最后，需要我们返回已绑定的symbol。 1 2 3 4 5 6 signature = expressions.first if scheme_symbolp(signature): # assigning a name to a value e.g. (define x (+ 1 2)) validate_form(expressions, 2, 2) # Checks that expressions is a list of length exactly 2 env.define(signature, scheme_eval(expressions.rest.first, env)) return signature Problem 5 此题向我们描述了quote的用法，在此不做过多赘述，详情可看题目要求。在此仅讲讲需要实现的功能。\n给出一段expressions，需要我们原封不动的返回，但对于Pair来说，不返回nil，由此可见，需要返回的是expressions.first。\n1 2 validate_form(expressions, 1, 1) return expressions.first Congratulation! 第一部分已完成\nProblem 6 此题我们需要完成Scheme中的一个特殊形式begin。\nbegin 用于按顺序组合多个表达式，并返回最后一个表达式的值。例如，\n1 2 3 4 (begin (display \u0026#34;Hello\u0026#34;) ; 执行第一个表达式（输出 \u0026#34;Hello\u0026#34;） (display \u0026#34;World\u0026#34;) ; 执行第二个表达式（输出 \u0026#34;World\u0026#34;） (+ 1 2)) ; 返回最后一个表达式的值 3 那由此我们可以观察到，它会将所有表达式都执行一遍，但只返回最后一个表达式的值，是不是有点像我们说的递归的概念，不断的完成一个动作，直到最后一个动作再返回。由此我们就可以写出代码。\n首先有一个 base case 若此表达式为空，返回None。 开始递归。首先我们想一想，想要evaluate一个表达式，应该怎么做？答：用上文完成的scheme_eval函数。 如何判断是否到达了递归终点？对于一个expressions来说，它就像一个链表，最后一项的rest总是nil，这就到达了递归终点，也就是我们说的base case。 对于recrusion case 来说，我们要不断的调用自身，直到到达base case。 1 2 3 4 5 6 7 8 if expressions is nil: return None exp = scheme_eval(expressions.first, env) if expressions.rest is nil: return exp else: return eval_all(expressions.rest, env) Problem 7 此题依旧需要我们完成Scheme中的一个特殊形式lambda。\nlambda 用于定义匿名函数，此题要求我们逐步计算表达式，并返回最后一个表达式的值。\n其中，LambdaProcedure这个类存在一个实例body，存放的是scheme list，而实例formals存放的是正确的Pair嵌套表达式。\n我们需要做的是创建并返回一个LambdaProcedure实例，那整体思路就很明朗的，再加上此函数还有给我们的提示，使用特定的语法知识，易得。\n1 2 body = expressions.rest return LambdaProcedure(formals, body, env) Problem 8 此题需要我们创建一个新的Frame，其中含有两个参数，formals vals，均为scheme list，需要我们将每一个formal对应到val，且formals于vals的数量都是相等的，一一对应，直到达到scheme list的终点即可。值得注意的是，不是简单的复制父Frame里的内容，笔者在这里第一次就想错了，总的来说，题目已经告诉我们具体做法，在此不做过多赘述。\n1 2 3 4 5 6 child_frame = Frame(self) while formals is not nil: child_frame.define(formals.first, vals.first) formals = formals.rest vals = vals.rest return child_frame Problem 9 此题需要我们完成scheme_apply里的一个LambdaProcedure case，题目已经给出提示，即\n创建一个新Frame，注意到，要想创建一个新的Frame，就应该想到用谁来创建，不能是Procedure本身，因为make_child_frame是在Frame类中实现的，所以应该找到一个Frame，即Procedrure.env 将形参绑定到参数值，想一想，对于一个Procedure来说，存在两个实例，即formals和body，而formals对应的就是make_child_frame中的formals，而body对应的就是eval_all中的expressions。 在当前Frame进行计算，也就是说此时的env应该变成我们创建的新Frame 综上易得，\n1 2 child_frame = procedure.env.make_child_frame(procedure.formals, args) return eval_all(procedure.body, child_frame) Problem 10 此题需要我们完成define的一种新类型，题目已经给了详尽的步骤，在这里讲几个笔者踩到的坑。\n想清楚symbol formals body分别代表什么，首先想明白，signature与expression之间的关系，signature代表的是expression的第一个内容，也就是函数名，而其中symbol也叫函数，也就是signature.first，之后再想想formals，就是除了define和函数名剩下的内容，而body则代表的是除了define之外的所有内容，想清楚这五个之间的关系，对于这道题十分关键。 题目告诉我们可以使用do_lambda_form，但笔者试了很多次也没有找到方法，若有人有更好的意见欢迎与我联系。 在找到正确的formals后还需要使用validate_formals()函数来判断其正确性。 综上可知，\n1 2 3 4 5 6 symbol = signature.first formals = signature.rest validate_formals(formals) body = expressions.rest env.define(symbol, LambdaProcedure(formals, body, env)) return symbol Problem 11 这道题看着题目很长很难，但其实是纸老虎，根据它的题意来即可。\n看看MuProcedure可以发现需要两个参数，formals和body，formals题目已经给出，指的是expressions的第一个内容，而body就是除了第一个内容的其他内容。 完成scheme_apply的mu case，这个内容跟上文的lambda case如出一辙，有区别的是，Frame的区别，因为mu是动态的，所以它的Frame一直在变，就不需要再用Procedure的Frame了。 综上可知，\n1 return MuProcedure(formals, expressions.rest) 1 2 child_frame = env.make_child_frame(procedure.formals, args) return eval_all(procedure.body, child_frame) Part 2 已完成！\nProblem 12 这道题需要我们完成两个函数do_and_form和do_or_form，这两个函数从形式上来说都很相似，所以放在一起做，读题目可知，expressions会给出不定量个内容，我们需要判断每个内容的正确性来判断应返回什么，值得注意的是，对于and和or来说，存在一个关键的地方短路，每当遇到一个合适的内容时，就会舍弃后面的所有内容，仅返回当前内容。\n因此，对于此题来说，递归是个很好的办法，具体步骤如下。\nbase case 1 若expression为空，则返回特定值。 base case 2 每当我们判断出来的当前内容的正确性，则直接返回。 base case 3 当所有内容都判断完毕后还没有找到正确性，则返回最后一个内容。 recrusion case 不断对下一个内容执行当前函数。 代码如下，\n1 2 3 4 5 6 7 8 9 10 11 12 def do_and_form(expressions, env): if expressions is nil: return True currency = scheme_eval(expressions.first, env) if is_scheme_true(currency): if expressions.rest is nil: return currency else: return do_and_form(expressions.rest, env) else: return currency 1 2 3 4 5 6 7 8 9 10 11 12 def do_or_form(expressions, env): if expressions is nil: return False currency = scheme_eval(expressions.first, env) if is_scheme_false(currency): if expressions.rest is nil: return currency else: return do_or_form(expressions.rest, env) else: return currency Problem 13 此题需要我们完成cond，题目也给了我们描述。返回第一个表达式为true的值，若都不是正确的，那么就返回else表达式也就是最后一个表达式的值，这也是一个递归步骤，因此可知步骤为，\nbase case 判断到最后一个表达式，若还没有判断出来，则返回此表达式的值。 recrusion case 从第一个表达式开始逐步判断。 1 2 3 4 if clause.rest is nil: return test else: return eval_all(clause.rest, env) Problem 14 这道题确实没看懂什么意思，在此也不误人子弟了。\n点这里看总的代码实现\n写在后面 后续的题目就不再做了，是关于Scheme的。\n作为UCB的CS61系列的第一门课，在当时还是初学者的我留下了很深的心理阴影，Scheme这个项目也一直停着没有做，这次重新捡回来，也算是给自己的一个交代。\n至此，CS61A结束。\nYuTaki\n2025年3月7日写于博学楼\n","date":"2025-03-07T00:00:00Z","image":"https://YuTaki23.github.io/p/cs61a-sp24-scheme/image1_hu_7934f1e6f9243d37.png","permalink":"https://YuTaki23.github.io/p/cs61a-sp24-scheme/","title":"CS61A SP24 Scheme"}]